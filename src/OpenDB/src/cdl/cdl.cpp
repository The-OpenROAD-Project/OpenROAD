/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2019, The Regents of the University of California
// All rights reserved.
//
// BSD 3-Clause License
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of the copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
///////////////////////////////////////////////////////////////////////////////

#include "cdl.h"

#include <algorithm>
#include <list>
#include <string>
#include <vector>

#include "dbLogger.h"

namespace odb {

void writeLine(FILE* f, const std::string& s)
{
  std::size_t bufferBegin = 0, currentPos = -1;
  while ((currentPos = s.find(' ', currentPos + 1)) != std::string::npos) {
    if (currentPos - bufferBegin < 57)
      continue;

    fwrite(s.substr(bufferBegin, currentPos - bufferBegin).c_str(),
           sizeof(char),
           currentPos - bufferBegin,
           f);
    bufferBegin = currentPos + 1;

    if (bufferBegin < s.size() - 1)
      fwrite("\n+ ", sizeof(char), 3, f);
  }

  if (bufferBegin < s.size() - 1)
    fwrite(
        s.substr(bufferBegin).c_str(), sizeof(char), s.size() - bufferBegin, f);
  fwrite("\n", sizeof(char), 1, f);
}

std::string getUnconnectedNet(dbBlock* block, int& unconnectedNets)
{
  while (block->findNet(
             std::string("_unconnected_" + std::to_string(unconnectedNets++))
                 .c_str())
         != NULL)
    ;
  return "_unconnected_" + std::to_string(unconnectedNets - 1);
}

std::string getNetName(dbBlock* block,
                       dbInst* inst,
                       dbMTerm* pin,
                       int& unconnectedNets)
{
  dbITerm* iterm = inst->getITerm(pin);
  if (iterm == NULL) {
    return getUnconnectedNet(block, unconnectedNets);
  }

  dbNet* net = iterm->getNet();
  if (net == NULL) {
    return getUnconnectedNet(block, unconnectedNets);
  }

  return net->getName();
}

bool cdl::writeCdl(dbBlock* block, const char* fileName, bool includeFillers)
{
  int unconnectedNets = 0;
  FILE* f = fopen(fileName, "w");

  if (f == NULL) {
    error(1, "cannot open file %s", fileName);
    return false;
  }

  writeLine(f, "$ CDL Netlist generated by OpenDB");
  writeLine(f, "");
  writeLine(f, "*.BUSDELIMITER [");
  writeLine(f, "");

  std::string line = ".SUBCKT " + block->getName();
  for (auto&& pin : block->getBTerms()) {
    line += " " + pin->getName();
  }

  writeLine(f, line);

  for (auto&& inst : block->getInsts()) {
    dbMaster* master = inst->getMaster();
    if (!includeFillers && master->isFiller())
      continue;

    line = "X" + inst->getName();
    auto mterms = master->getMTerms();

    std::vector<std::string> nets;
    for (auto&& pin : mterms) {
      nets.push_back(getNetName(block, inst, pin, unconnectedNets));
    }

    std::reverse(nets.begin(), nets.end());

    for (auto net : nets) {
      line += " " + net;
    }

    line += " " + master->getName();
    writeLine(f, line);
  }

  writeLine(f, ".ENDS " + block->getName());

  fclose(f);
  return true;
}

}  // namespace odb
