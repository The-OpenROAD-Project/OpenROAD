/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.1
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGTCL
#define SWIGTCL
#endif


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#include <stdio.h>
#include <tcl.h>
#include <errno.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

/* -----------------------------------------------------------------------------
 * swigrun.swg
 *
 * This file contains generic C API SWIG runtime support for pointer
 * type checking.
 * ----------------------------------------------------------------------------- */

/* This should only be incremented when either the layout of swig_type_info changes,
   or for whatever reason, the runtime changes incompatibly */
#define SWIG_RUNTIME_VERSION "4"

/* define SWIG_TYPE_TABLE_NAME as "SWIG_TYPE_TABLE" */
#ifdef SWIG_TYPE_TABLE
# define SWIG_QUOTE_STRING(x) #x
# define SWIG_EXPAND_AND_QUOTE_STRING(x) SWIG_QUOTE_STRING(x)
# define SWIG_TYPE_TABLE_NAME SWIG_EXPAND_AND_QUOTE_STRING(SWIG_TYPE_TABLE)
#else
# define SWIG_TYPE_TABLE_NAME
#endif

/*
  You can use the SWIGRUNTIME and SWIGRUNTIMEINLINE macros for
  creating a static or dynamic library from the SWIG runtime code.
  In 99.9% of the cases, SWIG just needs to declare them as 'static'.

  But only do this if strictly necessary, ie, if you have problems
  with your compiler or suchlike.
*/

#ifndef SWIGRUNTIME
# define SWIGRUNTIME SWIGINTERN
#endif

#ifndef SWIGRUNTIMEINLINE
# define SWIGRUNTIMEINLINE SWIGRUNTIME SWIGINLINE
#endif

/*  Generic buffer size */
#ifndef SWIG_BUFFER_SIZE
# define SWIG_BUFFER_SIZE 1024
#endif

/* Flags for pointer conversions */
#define SWIG_POINTER_DISOWN        0x1
#define SWIG_CAST_NEW_MEMORY       0x2
#define SWIG_POINTER_NO_NULL       0x4

/* Flags for new pointer objects */
#define SWIG_POINTER_OWN           0x1


/*
   Flags/methods for returning states.

   The SWIG conversion methods, as ConvertPtr, return an integer
   that tells if the conversion was successful or not. And if not,
   an error code can be returned (see swigerrors.swg for the codes).

   Use the following macros/flags to set or process the returning
   states.

   In old versions of SWIG, code such as the following was usually written:

     if (SWIG_ConvertPtr(obj,vptr,ty.flags) != -1) {
       // success code
     } else {
       //fail code
     }

   Now you can be more explicit:

    int res = SWIG_ConvertPtr(obj,vptr,ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
    } else {
      // fail code
    }

   which is the same really, but now you can also do

    Type *ptr;
    int res = SWIG_ConvertPtr(obj,(void **)(&ptr),ty.flags);
    if (SWIG_IsOK(res)) {
      // success code
      if (SWIG_IsNewObj(res) {
        ...
	delete *ptr;
      } else {
        ...
      }
    } else {
      // fail code
    }

   I.e., now SWIG_ConvertPtr can return new objects and you can
   identify the case and take care of the deallocation. Of course that
   also requires SWIG_ConvertPtr to return new result values, such as

      int SWIG_ConvertPtr(obj, ptr,...) {
        if (<obj is ok>) {
          if (<need new object>) {
            *ptr = <ptr to new allocated object>;
            return SWIG_NEWOBJ;
          } else {
            *ptr = <ptr to old object>;
            return SWIG_OLDOBJ;
          }
        } else {
          return SWIG_BADOBJ;
        }
      }

   Of course, returning the plain '0(success)/-1(fail)' still works, but you can be
   more explicit by returning SWIG_BADOBJ, SWIG_ERROR or any of the
   SWIG errors code.

   Finally, if the SWIG_CASTRANK_MODE is enabled, the result code
   allows to return the 'cast rank', for example, if you have this

       int food(double)
       int fooi(int);

   and you call

      food(1)   // cast rank '1'  (1 -> 1.0)
      fooi(1)   // cast rank '0'

   just use the SWIG_AddCast()/SWIG_CheckState()
*/

#define SWIG_OK                    (0)
#define SWIG_ERROR                 (-1)
#define SWIG_IsOK(r)               (r >= 0)
#define SWIG_ArgError(r)           ((r != SWIG_ERROR) ? r : SWIG_TypeError)

/* The CastRankLimit says how many bits are used for the cast rank */
#define SWIG_CASTRANKLIMIT         (1 << 8)
/* The NewMask denotes the object was created (using new/malloc) */
#define SWIG_NEWOBJMASK            (SWIG_CASTRANKLIMIT  << 1)
/* The TmpMask is for in/out typemaps that use temporal objects */
#define SWIG_TMPOBJMASK            (SWIG_NEWOBJMASK << 1)
/* Simple returning values */
#define SWIG_BADOBJ                (SWIG_ERROR)
#define SWIG_OLDOBJ                (SWIG_OK)
#define SWIG_NEWOBJ                (SWIG_OK | SWIG_NEWOBJMASK)
#define SWIG_TMPOBJ                (SWIG_OK | SWIG_TMPOBJMASK)
/* Check, add and del mask methods */
#define SWIG_AddNewMask(r)         (SWIG_IsOK(r) ? (r | SWIG_NEWOBJMASK) : r)
#define SWIG_DelNewMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_NEWOBJMASK) : r)
#define SWIG_IsNewObj(r)           (SWIG_IsOK(r) && (r & SWIG_NEWOBJMASK))
#define SWIG_AddTmpMask(r)         (SWIG_IsOK(r) ? (r | SWIG_TMPOBJMASK) : r)
#define SWIG_DelTmpMask(r)         (SWIG_IsOK(r) ? (r & ~SWIG_TMPOBJMASK) : r)
#define SWIG_IsTmpObj(r)           (SWIG_IsOK(r) && (r & SWIG_TMPOBJMASK))

/* Cast-Rank Mode */
#if defined(SWIG_CASTRANK_MODE)
#  ifndef SWIG_TypeRank
#    define SWIG_TypeRank             unsigned long
#  endif
#  ifndef SWIG_MAXCASTRANK            /* Default cast allowed */
#    define SWIG_MAXCASTRANK          (2)
#  endif
#  define SWIG_CASTRANKMASK          ((SWIG_CASTRANKLIMIT) -1)
#  define SWIG_CastRank(r)           (r & SWIG_CASTRANKMASK)
SWIGINTERNINLINE int SWIG_AddCast(int r) {
  return SWIG_IsOK(r) ? ((SWIG_CastRank(r) < SWIG_MAXCASTRANK) ? (r + 1) : SWIG_ERROR) : r;
}
SWIGINTERNINLINE int SWIG_CheckState(int r) {
  return SWIG_IsOK(r) ? SWIG_CastRank(r) + 1 : 0;
}
#else /* no cast-rank mode */
#  define SWIG_AddCast(r) (r)
#  define SWIG_CheckState(r) (SWIG_IsOK(r) ? 1 : 0)
#endif


#include <string.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *, int *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

/* Structure to store information on one type */
typedef struct swig_type_info {
  const char             *name;			/* mangled name of this type */
  const char             *str;			/* human readable name of this type */
  swig_dycast_func        dcast;		/* dynamic cast function down a hierarchy */
  struct swig_cast_info  *cast;			/* linked list of types that can cast into this type */
  void                   *clientdata;		/* language specific type data */
  int                    owndata;		/* flag if the structure owns the clientdata */
} swig_type_info;

/* Structure to store a type and conversion function used for casting */
typedef struct swig_cast_info {
  swig_type_info         *type;			/* pointer to type that is equivalent to this type */
  swig_converter_func     converter;		/* function to cast the void pointers */
  struct swig_cast_info  *next;			/* pointer to next cast in linked list */
  struct swig_cast_info  *prev;			/* pointer to the previous cast */
} swig_cast_info;

/* Structure used to store module information
 * Each module generates one structure like this, and the runtime collects
 * all of these structures and stores them in a circularly linked list.*/
typedef struct swig_module_info {
  swig_type_info         **types;		/* Array of pointers to swig_type_info structures that are in this module */
  size_t                 size;		        /* Number of types in this module */
  struct swig_module_info *next;		/* Pointer to next element in circularly linked list */
  swig_type_info         **type_initial;	/* Array of initially generated type structures */
  swig_cast_info         **cast_initial;	/* Array of initially generated casting structures */
  void                    *clientdata;		/* Language specific module data */
} swig_module_info;

/*
  Compare two type names skipping the space characters, therefore
  "char*" == "char *" and "Class<int>" == "Class<int >", etc.

  Return 0 when the two name types are equivalent, as in
  strncmp, but skipping ' '.
*/
SWIGRUNTIME int
SWIG_TypeNameComp(const char *f1, const char *l1,
		  const char *f2, const char *l2) {
  for (;(f1 != l1) && (f2 != l2); ++f1, ++f2) {
    while ((*f1 == ' ') && (f1 != l1)) ++f1;
    while ((*f2 == ' ') && (f2 != l2)) ++f2;
    if (*f1 != *f2) return (*f1 > *f2) ? 1 : -1;
  }
  return (int)((l1 - f1) - (l2 - f2));
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if equal, -1 if nb < tb, 1 if nb > tb
*/
SWIGRUNTIME int
SWIG_TypeCmp(const char *nb, const char *tb) {
  int equiv = 1;
  const char* te = tb + strlen(tb);
  const char* ne = nb;
  while (equiv != 0 && *ne) {
    for (nb = ne; *ne; ++ne) {
      if (*ne == '|') break;
    }
    equiv = SWIG_TypeNameComp(nb, ne, tb, te);
    if (*ne) ++ne;
  }
  return equiv;
}

/*
  Check type equivalence in a name list like <name1>|<name2>|...
  Return 0 if not equal, 1 if equal
*/
SWIGRUNTIME int
SWIG_TypeEquiv(const char *nb, const char *tb) {
  return SWIG_TypeCmp(nb, tb) == 0 ? 1 : 0;
}

/*
  Check the typename
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheck(const char *c, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (strcmp(iter->type->name, c) == 0) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Identical to SWIG_TypeCheck, except strcmp is replaced with a pointer comparison
*/
SWIGRUNTIME swig_cast_info *
SWIG_TypeCheckStruct(swig_type_info *from, swig_type_info *ty) {
  if (ty) {
    swig_cast_info *iter = ty->cast;
    while (iter) {
      if (iter->type == from) {
        if (iter == ty->cast)
          return iter;
        /* Move iter to the top of the linked list */
        iter->prev->next = iter->next;
        if (iter->next)
          iter->next->prev = iter->prev;
        iter->next = ty->cast;
        iter->prev = 0;
        if (ty->cast) ty->cast->prev = iter;
        ty->cast = iter;
        return iter;
      }
      iter = iter->next;
    }
  }
  return 0;
}

/*
  Cast a pointer up an inheritance hierarchy
*/
SWIGRUNTIMEINLINE void *
SWIG_TypeCast(swig_cast_info *ty, void *ptr, int *newmemory) {
  return ((!ty) || (!ty->converter)) ? ptr : (*ty->converter)(ptr, newmemory);
}

/*
   Dynamic pointer casting. Down an inheritance hierarchy
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) {
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
    ty = (*ty->dcast)(ptr);
    if (ty) lastty = ty;
  }
  return lastty;
}

/*
  Return the name associated with this type
*/
SWIGRUNTIMEINLINE const char *
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/*
  Return the pretty name associated with this type,
  that is an unmangled type name in a form presentable to the user.
*/
SWIGRUNTIME const char *
SWIG_TypePrettyName(const swig_type_info *type) {
  /* The "str" field contains the equivalent pretty names of the
     type, separated by vertical-bar characters.  We choose
     to print the last name, as it is often (?) the most
     specific. */
  if (!type) return NULL;
  if (type->str != NULL) {
    const char *last_name = type->str;
    const char *s;
    for (s = type->str; *s; s++)
      if (*s == '|') last_name = s+1;
    return last_name;
  }
  else
    return type->name;
}

/*
   Set the clientdata field for a type
*/
SWIGRUNTIME void
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_cast_info *cast = ti->cast;
  /* if (ti->clientdata == clientdata) return; */
  ti->clientdata = clientdata;

  while (cast) {
    if (!cast->converter) {
      swig_type_info *tc = cast->type;
      if (!tc->clientdata) {
	SWIG_TypeClientData(tc, clientdata);
      }
    }
    cast = cast->next;
  }
}
SWIGRUNTIME void
SWIG_TypeNewClientData(swig_type_info *ti, void *clientdata) {
  SWIG_TypeClientData(ti, clientdata);
  ti->owndata = 1;
}

/*
  Search for a swig_type_info structure only by mangled name
  Search is a O(log #types)

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_MangledTypeQueryModule(swig_module_info *start,
                            swig_module_info *end,
		            const char *name) {
  swig_module_info *iter = start;
  do {
    if (iter->size) {
      size_t l = 0;
      size_t r = iter->size - 1;
      do {
	/* since l+r >= 0, we can (>> 1) instead (/ 2) */
	size_t i = (l + r) >> 1;
	const char *iname = iter->types[i]->name;
	if (iname) {
	  int compare = strcmp(name, iname);
	  if (compare == 0) {
	    return iter->types[i];
	  } else if (compare < 0) {
	    if (i) {
	      r = i - 1;
	    } else {
	      break;
	    }
	  } else if (compare > 0) {
	    l = i + 1;
	  }
	} else {
	  break; /* should never happen */
	}
      } while (l <= r);
    }
    iter = iter->next;
  } while (iter != end);
  return 0;
}

/*
  Search for a swig_type_info structure for either a mangled name or a human readable name.
  It first searches the mangled names of the types, which is a O(log #types)
  If a type is not found it then searches the human readable names, which is O(#types).

  We start searching at module start, and finish searching when start == end.
  Note: if start == end at the beginning of the function, we go all the way around
  the circular list.
*/
SWIGRUNTIME swig_type_info *
SWIG_TypeQueryModule(swig_module_info *start,
                     swig_module_info *end,
		     const char *name) {
  /* STEP 1: Search the name field using binary search */
  swig_type_info *ret = SWIG_MangledTypeQueryModule(start, end, name);
  if (ret) {
    return ret;
  } else {
    /* STEP 2: If the type hasn't been found, do a complete search
       of the str field (the human readable name) */
    swig_module_info *iter = start;
    do {
      size_t i = 0;
      for (; i < iter->size; ++i) {
	if (iter->types[i]->str && (SWIG_TypeEquiv(iter->types[i]->str, name)))
	  return iter->types[i];
      }
      iter = iter->next;
    } while (iter != end);
  }

  /* neither found a match */
  return 0;
}

/*
   Pack binary data into a string
*/
SWIGRUNTIME char *
SWIG_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/*
   Unpack binary data from a string
*/
SWIGRUNTIME const char *
SWIG_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = (unsigned char)((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = (unsigned char)((d - ('a'-10)) << 4);
    else
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (unsigned char)(d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (unsigned char)(d - ('a'-10));
    else
      return (char *) 0;
    *u = uu;
  }
  return c;
}

/*
   Pack 'void *' into a string buffer.
*/
SWIGRUNTIME char *
SWIG_PackVoidPtr(char *buff, void *ptr, const char *name, size_t bsz) {
  char *r = buff;
  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackVoidPtr(const char *c, void **ptr, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      *ptr = (void *) 0;
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sizeof(void *));
}

SWIGRUNTIME char *
SWIG_PackDataName(char *buff, void *ptr, size_t sz, const char *name, size_t bsz) {
  char *r = buff;
  size_t lname = (name ? strlen(name) : 0);
  if ((2*sz + 2 + lname) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  if (lname) {
    strncpy(r,name,lname+1);
  } else {
    *r = 0;
  }
  return buff;
}

SWIGRUNTIME const char *
SWIG_UnpackDataName(const char *c, void *ptr, size_t sz, const char *name) {
  if (*c != '_') {
    if (strcmp(c,"NULL") == 0) {
      memset(ptr,0,sz);
      return name;
    } else {
      return 0;
    }
  }
  return SWIG_UnpackData(++c,ptr,sz);
}

#ifdef __cplusplus
}
#endif

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1
#define  SWIG_IOError        	   -2
#define  SWIG_RuntimeError   	   -3
#define  SWIG_IndexError     	   -4
#define  SWIG_TypeError      	   -5
#define  SWIG_DivisionByZero 	   -6
#define  SWIG_OverflowError  	   -7
#define  SWIG_SyntaxError    	   -8
#define  SWIG_ValueError     	   -9
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12
#define  SWIG_NullReferenceError   -13



/* -----------------------------------------------------------------------------
 * error manipulation
 * ----------------------------------------------------------------------------- */

SWIGINTERN const char*
SWIG_Tcl_ErrorType(int code) {
  const char* type = 0;
  switch(code) {
  case SWIG_MemoryError:
    type = "MemoryError";
    break;
  case SWIG_IOError:
    type = "IOError";
    break;
  case SWIG_RuntimeError:
    type = "RuntimeError";
    break;
  case SWIG_IndexError:
    type = "IndexError";
    break;
  case SWIG_TypeError:
    type = "TypeError";
    break;
  case SWIG_DivisionByZero:
    type = "ZeroDivisionError";
    break;
  case SWIG_OverflowError:
    type = "OverflowError";
    break;
  case SWIG_SyntaxError:
    type = "SyntaxError";
    break;
  case SWIG_ValueError:
    type = "ValueError";
    break;
  case SWIG_SystemError:
    type = "SystemError";
    break;
  case SWIG_AttributeError:
    type = "AttributeError";
    break;
  default:
    type = "RuntimeError";
  }
  return type;
}


SWIGINTERN void
SWIG_Tcl_SetErrorObj(Tcl_Interp *interp, const char *ctype, Tcl_Obj *obj)
{
  Tcl_ResetResult(interp);
  Tcl_SetObjResult(interp, obj);
  Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
}

SWIGINTERN void
SWIG_Tcl_SetErrorMsg(Tcl_Interp *interp, const char *ctype, const char *mesg)
{
  Tcl_ResetResult(interp);
  Tcl_SetErrorCode(interp, "SWIG", ctype, NULL);
  Tcl_AppendResult(interp, ctype, " ", mesg, NULL);
  /*
  Tcl_AddErrorInfo(interp, ctype);
  Tcl_AddErrorInfo(interp, " ");
  Tcl_AddErrorInfo(interp, mesg);
  */
}

SWIGINTERNINLINE void
SWIG_Tcl_AddErrorMsg(Tcl_Interp *interp, const char* mesg)
{
  Tcl_AddErrorInfo(interp, mesg);
}



/* -----------------------------------------------------------------------------
 * SWIG API. Portion that goes into the runtime
 * ----------------------------------------------------------------------------- */
#ifdef __cplusplus
extern "C" {
#endif

/* -----------------------------------------------------------------------------
 * Constant declarations
 * ----------------------------------------------------------------------------- */

/* Constant Types */
#define SWIG_TCL_POINTER 4
#define SWIG_TCL_BINARY  5

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    const char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

typedef int   (*swig_wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef int   (*swig_wrapper_func)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
typedef char *(*swig_variable_func)(ClientData, Tcl_Interp *, char *, char *, int);
typedef void  (*swig_delete_func)(ClientData);

typedef struct swig_method {
  const char     *name;
  swig_wrapper   method;
} swig_method;

typedef struct swig_attribute {
  const char     *name;
  swig_wrapper   getmethod;
  swig_wrapper   setmethod;
} swig_attribute;

typedef struct swig_class {
  const char         *name;
  swig_type_info   **type;
  swig_wrapper       constructor;
  void              (*destructor)(void *);
  swig_method        *methods;
  swig_attribute     *attributes;
  struct swig_class **bases;
  const char              **base_names;
  swig_module_info   *module;
  Tcl_HashTable       hashtable;
} swig_class;

typedef struct swig_instance {
  Tcl_Obj       *thisptr;
  void          *thisvalue;
  swig_class   *classptr;
  int            destroy;
  Tcl_Command    cmdtok;
} swig_instance;

/* Structure for command table */
typedef struct {
  const char *name;
  int       (*wrapper)(ClientData, Tcl_Interp *, int, Tcl_Obj *CONST []);
  ClientData  clientdata;
} swig_command_info;

/* Structure for variable linking table */
typedef struct {
  const char *name;
  void *addr;
  char * (*get)(ClientData, Tcl_Interp *, char *, char *, int);
  char * (*set)(ClientData, Tcl_Interp *, char *, char *, int);
} swig_var_info;


/* -----------------------------------------------------------------------------*
 *  Install a constant object 
 * -----------------------------------------------------------------------------*/

static Tcl_HashTable   swigconstTable;
static int             swigconstTableinit = 0;

SWIGINTERN void
SWIG_Tcl_SetConstantObj(Tcl_Interp *interp, const char* name, Tcl_Obj *obj) {
  int newobj;
  Tcl_ObjSetVar2(interp,Tcl_NewStringObj(name,-1), NULL, obj, TCL_GLOBAL_ONLY);
  Tcl_SetHashValue(Tcl_CreateHashEntry(&swigconstTable, name, &newobj), (ClientData) obj);
}

SWIGINTERN Tcl_Obj *
SWIG_Tcl_GetConstantObj(const char *key) {
  Tcl_HashEntry *entryPtr;
  if (!swigconstTableinit) return 0;
  entryPtr = Tcl_FindHashEntry(&swigconstTable, key);
  if (entryPtr) {
    return (Tcl_Obj *) Tcl_GetHashValue(entryPtr);
  }
  return 0;
}

#ifdef __cplusplus
}
#endif



/* -----------------------------------------------------------------------------
 * tclrun.swg
 *
 * This file contains the runtime support for Tcl modules and includes
 * code for managing global variables and pointer type checking.
 * ----------------------------------------------------------------------------- */

/* Common SWIG API */

/* for raw pointers */
#define SWIG_ConvertPtr(oc, ptr, ty, flags)             SWIG_Tcl_ConvertPtr(interp, oc, ptr, ty, flags)
#define SWIG_NewPointerObj(ptr, type, flags)            SWIG_Tcl_NewPointerObj(ptr, type, flags)

/* for raw packed data */
#define SWIG_ConvertPacked(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp, obj, ptr, sz, ty)
#define SWIG_NewPackedObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)

/* for class or struct pointers */
#define SWIG_ConvertInstance(obj, pptr, type, flags)    SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, flags)
#define SWIG_NewInstanceObj(thisvalue, type, flags)     SWIG_Tcl_NewInstanceObj(interp, thisvalue, type, flags)

/* for C or C++ function pointers */
#define SWIG_ConvertFunctionPtr(obj, pptr, type)        SWIG_Tcl_ConvertPtr(interp, obj, pptr, type, 0)
#define SWIG_NewFunctionPtrObj(ptr, type)               SWIG_Tcl_NewPointerObj(ptr, type, 0)

/* for C++ member pointers, ie, member methods */
#define SWIG_ConvertMember(obj, ptr, sz, ty)            SWIG_Tcl_ConvertPacked(interp,obj, ptr, sz, ty)
#define SWIG_NewMemberObj(ptr, sz, type)                SWIG_Tcl_NewPackedObj(ptr, sz, type)


/* Runtime API */

#define SWIG_GetModule(clientdata)                      SWIG_Tcl_GetModule((Tcl_Interp *) (clientdata))	     
#define SWIG_SetModule(clientdata, pointer)          	SWIG_Tcl_SetModule((Tcl_Interp *) (clientdata), pointer)


/* Error manipulation */

#define SWIG_ErrorType(code)                            SWIG_Tcl_ErrorType(code)                                      
#define SWIG_Error(code, msg)            		SWIG_Tcl_SetErrorMsg(interp, SWIG_Tcl_ErrorType(code), msg)
#define SWIG_fail                        		goto fail						    


/* Tcl-specific SWIG API */

#define SWIG_Acquire(ptr)                               SWIG_Tcl_Acquire(ptr)                                     
#define SWIG_MethodCommand                           	SWIG_Tcl_MethodCommand				       
#define SWIG_Disown(ptr)                             	SWIG_Tcl_Disown(ptr)				       
#define SWIG_ConvertPtrFromString(c, ptr, ty, flags) 	SWIG_Tcl_ConvertPtrFromString(interp, c, ptr, ty, flags)  
#define SWIG_MakePtr(c, ptr, ty, flags)              	SWIG_Tcl_MakePtr(c, ptr, ty, flags)		       
#define SWIG_PointerTypeFromString(c)                	SWIG_Tcl_PointerTypeFromString(c)			       
#define SWIG_GetArgs                                 	SWIG_Tcl_GetArgs					       
#define SWIG_GetConstantObj(key)                     	SWIG_Tcl_GetConstantObj(key)			       
#define SWIG_ObjectConstructor                       	SWIG_Tcl_ObjectConstructor				       
#define SWIG_Thisown(ptr)                            	SWIG_Tcl_Thisown(ptr)				       
#define SWIG_ObjectDelete                            	SWIG_Tcl_ObjectDelete				       


#define SWIG_TCL_DECL_ARGS_2(arg1, arg2)                (Tcl_Interp *interp SWIGUNUSED, arg1, arg2)
#define SWIG_TCL_CALL_ARGS_2(arg1, arg2)                (interp, arg1, arg2)
/* -----------------------------------------------------------------------------
 * pointers/data manipulation
 * ----------------------------------------------------------------------------- */

/* For backward compatibility only */
#define SWIG_POINTER_EXCEPTION  0
#define SWIG_GetConstant        SWIG_GetConstantObj
#define SWIG_Tcl_GetConstant    SWIG_Tcl_GetConstantObj

#if TCL_MAJOR_VERSION >= 8 && TCL_MINOR_VERSION >= 5
#define SWIG_TCL_HASHTABLE_INIT {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
#else
#define SWIG_TCL_HASHTABLE_INIT {0}
#endif

#include "assert.h"

#ifdef __cplusplus
extern "C" {
#endif

/* Object support */

SWIGRUNTIME Tcl_HashTable*
SWIG_Tcl_ObjectTable(void) {
  static Tcl_HashTable  swigobjectTable;
  static int            swigobjectTableinit = 0;
  if (!swigobjectTableinit) {
    Tcl_InitHashTable(&swigobjectTable, TCL_ONE_WORD_KEYS);
    swigobjectTableinit = 1;
  }
  return &swigobjectTable;
}

/* Acquire ownership of a pointer */
SWIGRUNTIME void
SWIG_Tcl_Acquire(void *ptr) {
  int newobj;
  Tcl_CreateHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr, &newobj);
}

SWIGRUNTIME int
SWIG_Tcl_Thisown(void *ptr) {
  if (Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr)) {
    return 1;
  }
  return 0;
}

/* Disown a pointer.  Returns 1 if we owned it to begin with */
SWIGRUNTIME int
SWIG_Tcl_Disown(void *ptr) {
  Tcl_HashEntry *entryPtr = Tcl_FindHashEntry(SWIG_Tcl_ObjectTable(), (char *) ptr);
  if (entryPtr) {
    Tcl_DeleteHashEntry(entryPtr);
    return 1;
  }
  return 0;
}

/* Convert a pointer value */
SWIGRUNTIME int
SWIG_Tcl_ConvertPtrFromString(Tcl_Interp *interp, const char *c, void **ptr, swig_type_info *ty, int flags) {
  swig_cast_info *tc;
  /* Pointer values must start with leading underscore */
  while (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0)
      return (flags & SWIG_POINTER_NO_NULL) ? SWIG_NullReferenceError : SWIG_OK;

    /* Empty string: not a pointer */
    if (*c == 0) return SWIG_ERROR; 

    /* Hmmm. It could be an object name. */

    /* Check if this is a command at all. Prevents <c> cget -this         */
    /* from being called when c is not a command, firing the unknown proc */
    if (Tcl_VarEval(interp,"info commands ", c, (char *) NULL) == TCL_OK) {
      Tcl_Obj *result = Tcl_GetObjResult(interp);
      if (*(Tcl_GetStringFromObj(result, NULL)) == 0) {
        /* It's not a command, so it can't be a pointer */
        Tcl_ResetResult(interp);
        return SWIG_ERROR;
      }
    } else {
      /* This will only fail if the argument is multiple words. */
      /* Multiple words are also not commands.                  */
      Tcl_ResetResult(interp);
      return SWIG_ERROR;
    }

    /* Check if this is really a SWIG pointer */
    if (Tcl_VarEval(interp,c," cget -this", (char *) NULL) != TCL_OK) {
      Tcl_ResetResult(interp);
      return SWIG_ERROR;
    }

    c = Tcl_GetStringFromObj(Tcl_GetObjResult(interp), NULL);
  }

  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (ty) {
    tc = c ? SWIG_TypeCheck(c,ty) : 0;
    if (!tc) {
      return SWIG_ERROR;
    }
    if (flags & SWIG_POINTER_DISOWN) {
      SWIG_Disown((void *) *ptr);
    }
    {
      int newmemory = 0;
      *ptr = SWIG_TypeCast(tc,(void *) *ptr,&newmemory);
      assert(!newmemory); /* newmemory handling not yet implemented */
    }
  }
  return SWIG_OK;
}

/* Convert a pointer value */
SWIGRUNTIMEINLINE int
SWIG_Tcl_ConvertPtr(Tcl_Interp *interp, Tcl_Obj *oc, void **ptr, swig_type_info *ty, int flags) {
  return SWIG_Tcl_ConvertPtrFromString(interp, Tcl_GetStringFromObj(oc,NULL), ptr, ty, flags);
}

/* Convert a pointer value */
SWIGRUNTIME char *
SWIG_Tcl_PointerTypeFromString(char *c) {
  char d;
  /* Pointer values must start with leading underscore. NULL has no type */
  if (*c != '_') {
    return 0;
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if (!(((d >= '0') && (d <= '9')) || ((d >= 'a') && (d <= 'f')))) break;
    c++;
  }
  return c;
}

/* Convert a packed pointer value */
SWIGRUNTIME int
SWIG_Tcl_ConvertPacked(Tcl_Interp *SWIGUNUSEDPARM(interp) , Tcl_Obj *obj, void *ptr, int sz, swig_type_info *ty) {
  swig_cast_info *tc;
  const char  *c;

  if (!obj) goto type_error;
  c = Tcl_GetStringFromObj(obj,NULL);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return SWIG_OK;

 type_error:

  return SWIG_ERROR;
}


/* Take a pointer and convert it to a string */
SWIGRUNTIME void
SWIG_Tcl_MakePtr(char *c, void *ptr, swig_type_info *ty, int SWIGUNUSEDPARM(flags)) {
  if (ptr) {
    *(c++) = '_';
    c = SWIG_PackData(c,&ptr,sizeof(void *));
    strcpy(c,ty->name);
  } else {
    strcpy(c,"NULL");
  }
}

/* Create a new pointer object */
SWIGRUNTIMEINLINE Tcl_Obj *
SWIG_Tcl_NewPointerObj(void *ptr, swig_type_info *type, int flags) {
  Tcl_Obj *robj;
  char result[SWIG_BUFFER_SIZE];
  SWIG_MakePtr(result,ptr,type,flags);
  robj = Tcl_NewStringObj(result,-1);
  return robj;
}

SWIGRUNTIME Tcl_Obj *
SWIG_Tcl_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return Tcl_NewStringObj(result,-1);
}

/* -----------------------------------------------------------------------------*
 *  Get type list 
 * -----------------------------------------------------------------------------*/

SWIGRUNTIME swig_module_info * 
SWIG_Tcl_GetModule(Tcl_Interp *interp) {
  const char *data;
  swig_module_info *ret = 0;
  
  /* first check if pointer already created */
  data = Tcl_GetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, TCL_GLOBAL_ONLY);
  if (data) {
    SWIG_UnpackData(data, &ret, sizeof(swig_type_info **));
  }

  return ret;
}

SWIGRUNTIME void
SWIG_Tcl_SetModule(Tcl_Interp *interp, swig_module_info *module) {
  char buf[SWIG_BUFFER_SIZE];
  char *data;

  /* create a new pointer */
  data = SWIG_PackData(buf, &module, sizeof(swig_type_info **));
  *data = 0;
  Tcl_SetVar(interp, (char *)"swig_runtime_data_type_pointer" SWIG_RUNTIME_VERSION SWIG_TYPE_TABLE_NAME, buf, TCL_GLOBAL_ONLY);
}

/* -----------------------------------------------------------------------------*
 *  Object auxiliaries
 * -----------------------------------------------------------------------------*/


SWIGRUNTIME void
SWIG_Tcl_ObjectDelete(ClientData clientData) {
  swig_instance *si = (swig_instance *) clientData;
  if (!si) return;
  if (si->destroy && SWIG_Disown(si->thisvalue)) {
    if (si->classptr->destructor) {
      (si->classptr->destructor)(si->thisvalue);
    }
  }
  Tcl_DecrRefCount(si->thisptr);
  free(si);
}

/* Function to invoke object methods given an instance */
SWIGRUNTIME int
SWIG_Tcl_MethodCommand(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST _objv[]) {
  char *method,   *attrname;
  swig_instance   *inst = (swig_instance *) clientData;
  swig_method     *meth;
  swig_attribute  *attr;
  Tcl_Obj         *oldarg;
  Tcl_Obj         **objv;
  int              rcode;
  swig_class      *cls;
  swig_class      *cls_stack[64];
  int              cls_stack_bi[64];
  int              cls_stack_top = 0;
  int              numconf = 2;
  int              bi;

  objv = (Tcl_Obj **) _objv;
  if (objc < 2) {
    Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
    return TCL_ERROR;
  }
  method = Tcl_GetStringFromObj(objv[1],NULL);
  if (strcmp(method,"-acquire") == 0) {
    inst->destroy = 1;
    SWIG_Acquire(inst->thisvalue);
    return TCL_OK;
  }
  if (strcmp(method,"-disown") == 0) {
    if (inst->destroy) {
      SWIG_Disown(inst->thisvalue);
    }
    inst->destroy = 0;
    return TCL_OK;
  }
  if (strcmp(method,"-delete") == 0) {
    Tcl_DeleteCommandFromToken(interp,inst->cmdtok);
    return TCL_OK;
  }
  cls_stack[cls_stack_top] = inst->classptr;
  cls_stack_bi[cls_stack_top] = -1;
  while (1) {
    Tcl_HashEntry* hashentry;
    bi = cls_stack_bi[cls_stack_top];
    cls = cls_stack[cls_stack_top];
    if (bi != -1) {
      if (!cls->bases[bi] && cls->base_names[bi]) {
        /* lookup and cache the base class */
	swig_type_info *info = SWIG_TypeQueryModule(cls->module, cls->module, cls->base_names[bi]);
	if (info) cls->bases[bi] = (swig_class *) info->clientdata;
      }
      cls = cls->bases[bi];
      if (cls) {
        cls_stack_bi[cls_stack_top]++;
        cls_stack_top++;
        cls_stack[cls_stack_top] = cls;
        cls_stack_bi[cls_stack_top] = -1;
        continue;
      }
    }
    if (!cls) {
      cls_stack_top--;
      if (cls_stack_top < 0) break;
      else continue;
    }
    cls_stack_bi[cls_stack_top]++;

    hashentry = Tcl_FindHashEntry(&(cls->hashtable), method);
    if (hashentry) {
        ClientData cd = Tcl_GetHashValue(hashentry);
        swig_wrapper method_wrapper = (swig_wrapper)cd;
        oldarg = objv[1];
        objv[1] = inst->thisptr;
        Tcl_IncrRefCount(inst->thisptr);
        rcode = (method_wrapper)(clientData,interp,objc,objv);
        objv[1] = oldarg;
        Tcl_DecrRefCount(inst->thisptr);
        return rcode;
    }
    /* Check class methods for a match */
    if (strcmp(method,"cget") == 0) {
      if (objc < 3) {
        Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
        return TCL_ERROR;
      }
      attrname = Tcl_GetStringFromObj(objv[2],NULL);
      attr = cls->attributes;
      while (attr && attr->name) {
        if ((strcmp(attr->name, attrname) == 0) && (attr->getmethod)) {
          oldarg = objv[1];
          objv[1] = inst->thisptr;
          Tcl_IncrRefCount(inst->thisptr);
          rcode = (*attr->getmethod)(clientData,interp,2, objv);
          objv[1] = oldarg;
          Tcl_DecrRefCount(inst->thisptr);
          return rcode;
        }
        attr++;
      }
      if (strcmp(attrname, "-this") == 0) {
        Tcl_SetObjResult(interp, Tcl_DuplicateObj(inst->thisptr));
        return TCL_OK;
      }
      if (strcmp(attrname, "-thisown") == 0) {
        if (SWIG_Thisown(inst->thisvalue)) {
          Tcl_SetResult(interp,(char*)"1",TCL_STATIC);
        } else {
          Tcl_SetResult(interp,(char*)"0",TCL_STATIC);
        }
        return TCL_OK;
      }
    } else if (strcmp(method, "configure") == 0) {
      int i;
      if (objc < 4) {
        Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
        return TCL_ERROR;
      }
      i = 2;
      while (i < objc) {
        attrname = Tcl_GetStringFromObj(objv[i],NULL);
        attr = cls->attributes;
        while (attr && attr->name) {
          if ((strcmp(attr->name, attrname) == 0) && (attr->setmethod)) {
            oldarg = objv[i];
            objv[i] = inst->thisptr;
            Tcl_IncrRefCount(inst->thisptr);
            rcode = (*attr->setmethod)(clientData,interp,3, &objv[i-1]);
            objv[i] = oldarg;
            Tcl_DecrRefCount(inst->thisptr);
            if (rcode != TCL_OK) return rcode;
            numconf += 2;
          }
          attr++;
        }
        i+=2;
      }
    }
  }
  if (strcmp(method,"configure") == 0) {
    if (numconf >= objc) {
      return TCL_OK;
    } else {
      Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
      return TCL_ERROR;
    }
  }
  if (strcmp(method,"cget") == 0) {
    Tcl_SetResult(interp,(char *) "Invalid attribute name.", TCL_STATIC);
    return TCL_ERROR;
  }
  Tcl_SetResult(interp, (char *) "Invalid method. Must be one of: configure cget -acquire -disown -delete", TCL_STATIC);
  cls = inst->classptr;
  bi = 0;
  while (cls) {
    meth = cls->methods;
    while (meth && meth->name) {
      char *cr = (char *) Tcl_GetStringResult(interp);
      size_t meth_len = strlen(meth->name);
      char* where = strchr(cr,':');
      while(where) {
        where = strstr(where, meth->name);
        if(where) {
          if(where[-1] == ' ' && (where[meth_len] == ' ' || where[meth_len]==0)) {
            break;
          } else {
            where++;
          }
        }
      }

      if (!where)
        Tcl_AppendElement(interp, (char *) meth->name);
      meth++;
    }
    cls = inst->classptr->bases[bi++];
  }
  return TCL_ERROR;
}

/* This function takes the current result and turns it into an object command */
SWIGRUNTIME Tcl_Obj *
SWIG_Tcl_NewInstanceObj(Tcl_Interp *interp, void *thisvalue, swig_type_info *type, int flags) {
  Tcl_Obj *robj = SWIG_NewPointerObj(thisvalue, type,0);
  /* Check to see if this pointer belongs to a class or not */
  if (thisvalue && (type->clientdata) && (interp)) {
    Tcl_CmdInfo    ci;
    char          *name;
    name = Tcl_GetStringFromObj(robj,NULL);
    if (!Tcl_GetCommandInfo(interp,name, &ci) || (flags)) {
      swig_instance *newinst = (swig_instance *) malloc(sizeof(swig_instance));
      newinst->thisptr = Tcl_DuplicateObj(robj);
      Tcl_IncrRefCount(newinst->thisptr);
      newinst->thisvalue = thisvalue;
      newinst->classptr = (swig_class *) type->clientdata;
      newinst->destroy = flags;
      newinst->cmdtok = Tcl_CreateObjCommand(interp, Tcl_GetStringFromObj(robj,NULL), (swig_wrapper_func) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
      if (flags) {
        SWIG_Acquire(thisvalue);
      }
    }
  }
  return robj;
}

/* Function to create objects */
SWIGRUNTIME int
SWIG_Tcl_ObjectConstructor(ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Tcl_Obj          *newObj = 0;
  void             *thisvalue = 0;
  swig_instance   *newinst = 0;
  swig_class      *classptr = (swig_class *) clientData;
  swig_wrapper     cons = 0;
  char             *name = 0;
  int               firstarg = 0;
  int               thisarg = 0;
  int               destroy = 1;

  if (!classptr) {
    Tcl_SetResult(interp, (char *) "swig: internal runtime error. No class object defined.", TCL_STATIC);
    return TCL_ERROR;
  }
  cons = classptr->constructor;
  if (objc > 1) {
    char *s = Tcl_GetStringFromObj(objv[1],NULL);
    if (strcmp(s,"-this") == 0) {
      thisarg = 2;
      cons = 0;
    } else if (strcmp(s,"-args") == 0) {
      firstarg = 1;
    } else if (objc == 2) {
      firstarg = 1;
      name = s;
    } else if (objc >= 3) {
      char *s1;
      name = s;
      s1 = Tcl_GetStringFromObj(objv[2],NULL);
      if (strcmp(s1,"-this") == 0) {
	thisarg = 3;
	cons = 0;
      } else {
	firstarg = 1;
      }
    }
  }
  if (cons) {
    int result;
    result = (*cons)(0, interp, objc-firstarg, &objv[firstarg]);
    if (result != TCL_OK) {
      return result;
    }
    newObj = Tcl_DuplicateObj(Tcl_GetObjResult(interp));
    if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
  } else if (thisarg > 0) {
    if (thisarg < objc) {
      destroy = 0;
      newObj = Tcl_DuplicateObj(objv[thisarg]);
      if (!name) name = Tcl_GetStringFromObj(newObj,NULL);
    } else {
      Tcl_SetResult(interp, (char *) "wrong # args.", TCL_STATIC);
      return TCL_ERROR;
    }
  } else {
    Tcl_SetResult(interp, (char *) "No constructor available.", TCL_STATIC);
    return TCL_ERROR;
  }
  if (SWIG_Tcl_ConvertPtr(interp,newObj, (void **) &thisvalue, *(classptr->type), 0) != SWIG_OK) {
    Tcl_DecrRefCount(newObj);
    return TCL_ERROR;
  }
  newinst = (swig_instance *) malloc(sizeof(swig_instance));
  newinst->thisptr = newObj;
  Tcl_IncrRefCount(newObj);
  newinst->thisvalue = thisvalue;
  newinst->classptr = classptr;
  newinst->destroy = destroy;
  if (destroy) {
    SWIG_Acquire(thisvalue);
  }
  newinst->cmdtok = Tcl_CreateObjCommand(interp,name, (swig_wrapper) SWIG_MethodCommand, (ClientData) newinst, (swig_delete_func) SWIG_ObjectDelete);
  return TCL_OK;
}

/* -----------------------------------------------------------------------------*
 *   Get arguments 
 * -----------------------------------------------------------------------------*/
SWIGRUNTIME int
SWIG_Tcl_GetArgs(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], const char *fmt, ...) {
  int        argno = 0, opt = 0;
  long       tempi;
  double     tempd;
  const char *c;
  va_list    ap;
  void      *vptr;
  Tcl_Obj   *obj = 0;
  swig_type_info *ty;

  va_start(ap,fmt);
  for (c = fmt; (*c && (*c != ':') && (*c != ';')); c++,argno++) {
    if (*c == '|') {
      opt = 1;
      c++;
    }
    if (argno >= (objc-1)) {
      if (!opt) {
        Tcl_SetResult(interp, (char *) "Wrong number of arguments ", TCL_STATIC);
        goto argerror;
      } else {
        va_end(ap);
        return TCL_OK;
      }
    }

    vptr = va_arg(ap,void *);
    if (vptr) {
      if (isupper(*c)) {
        obj = SWIG_Tcl_GetConstantObj(Tcl_GetStringFromObj(objv[argno+1],0));
        if (!obj) obj = objv[argno+1];
      } else {
        obj = objv[argno+1];
      }
      switch(*c) {
      case 'i': case 'I':
      case 'l': case 'L':
      case 'h': case 'H':
      case 'b': case 'B':
        if (Tcl_GetLongFromObj(interp,obj,&tempi) != TCL_OK) goto argerror;
        if ((*c == 'i') || (*c == 'I')) *((int *)vptr) = (int)tempi;
        else if ((*c == 'l') || (*c == 'L')) *((long *)vptr) = (long)tempi;
        else if ((*c == 'h') || (*c == 'H')) *((short*)vptr) = (short)tempi;
        else if ((*c == 'b') || (*c == 'B')) *((unsigned char *)vptr) = (unsigned char)tempi;
        break;
      case 'f': case 'F':
      case 'd': case 'D':
        if (Tcl_GetDoubleFromObj(interp,obj,&tempd) != TCL_OK) goto argerror;
        if ((*c == 'f') || (*c == 'F')) *((float *) vptr) = (float)tempd;
        else if ((*c == 'd') || (*c == 'D')) *((double*) vptr) = tempd;
        break;
      case 's': case 'S':
        if (*(c+1) == '#') {
          int *vlptr = (int *) va_arg(ap, void *);
          *((char **) vptr) = Tcl_GetStringFromObj(obj, vlptr);
          c++;
        } else {
          *((char **)vptr) = Tcl_GetStringFromObj(obj,NULL);
        }
        break;
      case 'c': case 'C':
        *((char *)vptr) = *(Tcl_GetStringFromObj(obj,NULL));
        break;
      case 'p': case 'P':
        ty = (swig_type_info *) va_arg(ap, void *);
        if (SWIG_Tcl_ConvertPtr(interp, obj, (void **) vptr, ty, 0) != SWIG_OK) goto argerror;
        break;
      case 'o': case 'O':
        *((Tcl_Obj **)vptr) = objv[argno+1];
        break;
      default:
        break;
      }
    }
  }

  if ((*c != ';') && ((objc-1) > argno)) {
    Tcl_SetResult(interp, (char *) "Wrong # args.", TCL_STATIC);
    goto argerror;
  }
  va_end(ap);
  return TCL_OK;

 argerror:
  {
    char temp[32];
    sprintf(temp,"%d", argno+1);
    c = strchr(fmt,':');
    if (!c) c = strchr(fmt,';');
    if (!c) c = (char *)"";
    Tcl_AppendResult(interp,c," argument ", temp, NULL);
    va_end(ap);
    return TCL_ERROR;
  }
}

#ifdef __cplusplus
}
#endif



#define SWIG_exception_fail(code, msg) do { SWIG_Error(code, msg); SWIG_fail; } while(0) 

#define SWIG_contract_assert(expr, msg) if (!(expr)) { SWIG_Error(SWIG_RuntimeError, msg); SWIG_fail; } else 



/* -------- TYPES TABLE (BEGIN) -------- */

#define SWIGTYPE_p_Cell swig_types[0]
#define SWIGTYPE_p_CellPortIterator swig_types[1]
#define SWIGTYPE_p_Clock swig_types[2]
#define SWIGTYPE_p_ClockEdge swig_types[3]
#define SWIGTYPE_p_ClockGroups swig_types[4]
#define SWIGTYPE_p_ClockIterator swig_types[5]
#define SWIGTYPE_p_ClockSet swig_types[6]
#define SWIGTYPE_p_Corner swig_types[7]
#define SWIGTYPE_p_Crpr swig_types[8]
#define SWIGTYPE_p_EarlyLate swig_types[9]
#define SWIGTYPE_p_EarlyLateAll swig_types[10]
#define SWIGTYPE_p_Edge swig_types[11]
#define SWIGTYPE_p_EdgeSeq swig_types[12]
#define SWIGTYPE_p_ExceptionFrom swig_types[13]
#define SWIGTYPE_p_ExceptionThru swig_types[14]
#define SWIGTYPE_p_ExceptionThruSeq swig_types[15]
#define SWIGTYPE_p_ExceptionTo swig_types[16]
#define SWIGTYPE_p_FloatSeq swig_types[17]
#define SWIGTYPE_p_Instance swig_types[18]
#define SWIGTYPE_p_InstanceChildIterator swig_types[19]
#define SWIGTYPE_p_InstanceNetIterator swig_types[20]
#define SWIGTYPE_p_InstancePinIterator swig_types[21]
#define SWIGTYPE_p_InstanceSeq swig_types[22]
#define SWIGTYPE_p_InstanceSet swig_types[23]
#define SWIGTYPE_p_IntSeq swig_types[24]
#define SWIGTYPE_p_LeafInstanceIterator swig_types[25]
#define SWIGTYPE_p_LibertyCell swig_types[26]
#define SWIGTYPE_p_LibertyCellPortIterator swig_types[27]
#define SWIGTYPE_p_LibertyCellTimingArcSetIterator swig_types[28]
#define SWIGTYPE_p_LibertyLibrary swig_types[29]
#define SWIGTYPE_p_LibertyLibraryIterator swig_types[30]
#define SWIGTYPE_p_LibertyPort swig_types[31]
#define SWIGTYPE_p_LibertyPortMemberIterator swig_types[32]
#define SWIGTYPE_p_Library swig_types[33]
#define SWIGTYPE_p_LibraryIterator swig_types[34]
#define SWIGTYPE_p_LogicValue swig_types[35]
#define SWIGTYPE_p_MaxSkewCheck swig_types[36]
#define SWIGTYPE_p_MaxSkewCheckSeq swig_types[37]
#define SWIGTYPE_p_MinMax swig_types[38]
#define SWIGTYPE_p_MinMaxAll swig_types[39]
#define SWIGTYPE_p_MinMaxAllNull swig_types[40]
#define SWIGTYPE_p_MinPeriodCheck swig_types[41]
#define SWIGTYPE_p_MinPeriodCheckSeq swig_types[42]
#define SWIGTYPE_p_MinPulseWidthCheck swig_types[43]
#define SWIGTYPE_p_MinPulseWidthCheckSeq swig_types[44]
#define SWIGTYPE_p_MinPulseWidthCheckSeqIterator swig_types[45]
#define SWIGTYPE_p_Net swig_types[46]
#define SWIGTYPE_p_NetConnectedPinIterator swig_types[47]
#define SWIGTYPE_p_NetPinIterator swig_types[48]
#define SWIGTYPE_p_NetSet swig_types[49]
#define SWIGTYPE_p_NetTermIterator swig_types[50]
#define SWIGTYPE_p_OperatingConditions swig_types[51]
#define SWIGTYPE_p_Path swig_types[52]
#define SWIGTYPE_p_PathClkOrData swig_types[53]
#define SWIGTYPE_p_PathEnd swig_types[54]
#define SWIGTYPE_p_PathGroupNameSet swig_types[55]
#define SWIGTYPE_p_PathRef swig_types[56]
#define SWIGTYPE_p_Pin swig_types[57]
#define SWIGTYPE_p_PinConnectedPinIterator swig_types[58]
#define SWIGTYPE_p_PinSeq swig_types[59]
#define SWIGTYPE_p_PinSet swig_types[60]
#define SWIGTYPE_p_Polygon90 swig_types[61]
#define SWIGTYPE_p_Polygon90Set swig_types[62]
#define SWIGTYPE_p_Port swig_types[63]
#define SWIGTYPE_p_PortMemberIterator swig_types[64]
#define SWIGTYPE_p_PortSeq swig_types[65]
#define SWIGTYPE_p_ReducedParasiticType swig_types[66]
#define SWIGTYPE_p_ReportPathFormat swig_types[67]
#define SWIGTYPE_p_RiseFall swig_types[68]
#define SWIGTYPE_p_RiseFallBoth swig_types[69]
#define SWIGTYPE_p_SetupHold swig_types[70]
#define SWIGTYPE_p_SetupHoldAll swig_types[71]
#define SWIGTYPE_p_SlowDrvrIterator swig_types[72]
#define SWIGTYPE_p_StringSeq swig_types[73]
#define SWIGTYPE_p_StringSet swig_types[74]
#define SWIGTYPE_p_Tcl_Interp swig_types[75]
#define SWIGTYPE_p_Term swig_types[76]
#define SWIGTYPE_p_TimingArc swig_types[77]
#define SWIGTYPE_p_TimingArcSet swig_types[78]
#define SWIGTYPE_p_TimingArcSetArcIterator swig_types[79]
#define SWIGTYPE_p_TimingDerateCellType swig_types[80]
#define SWIGTYPE_p_TimingDerateType swig_types[81]
#define SWIGTYPE_p_TimingRole swig_types[82]
#define SWIGTYPE_p_Transition swig_types[83]
#define SWIGTYPE_p_Vertex swig_types[84]
#define SWIGTYPE_p_VertexInEdgeIterator swig_types[85]
#define SWIGTYPE_p_VertexIterator swig_types[86]
#define SWIGTYPE_p_VertexOutEdgeIterator swig_types[87]
#define SWIGTYPE_p_VertexPathIterator swig_types[88]
#define SWIGTYPE_p_Wireload swig_types[89]
#define SWIGTYPE_p_WireloadSelection swig_types[90]
#define SWIGTYPE_p_char swig_types[91]
#define SWIGTYPE_p_dbNet swig_types[92]
#define SWIGTYPE_p_difference_type swig_types[93]
#define SWIGTYPE_p_edge_iterator swig_types[94]
#define SWIGTYPE_p_node_iterator swig_types[95]
#define SWIGTYPE_p_object_iterator swig_types[96]
#define SWIGTYPE_p_odb__Point swig_types[97]
#define SWIGTYPE_p_odb__Rect swig_types[98]
#define SWIGTYPE_p_odb__dbAccessPoint swig_types[99]
#define SWIGTYPE_p_odb__dbBPin swig_types[100]
#define SWIGTYPE_p_odb__dbBTerm swig_types[101]
#define SWIGTYPE_p_odb__dbBlock swig_types[102]
#define SWIGTYPE_p_odb__dbBlockage swig_types[103]
#define SWIGTYPE_p_odb__dbBoolProperty swig_types[104]
#define SWIGTYPE_p_odb__dbBox swig_types[105]
#define SWIGTYPE_p_odb__dbCCSeg swig_types[106]
#define SWIGTYPE_p_odb__dbCapNode swig_types[107]
#define SWIGTYPE_p_odb__dbChip swig_types[108]
#define SWIGTYPE_p_odb__dbDoubleProperty swig_types[109]
#define SWIGTYPE_p_odb__dbGroup swig_types[110]
#define SWIGTYPE_p_odb__dbITerm swig_types[111]
#define SWIGTYPE_p_odb__dbInst swig_types[112]
#define SWIGTYPE_p_odb__dbIntProperty swig_types[113]
#define SWIGTYPE_p_odb__dbLib swig_types[114]
#define SWIGTYPE_p_odb__dbMPin swig_types[115]
#define SWIGTYPE_p_odb__dbMTerm swig_types[116]
#define SWIGTYPE_p_odb__dbMaster swig_types[117]
#define SWIGTYPE_p_odb__dbModInst swig_types[118]
#define SWIGTYPE_p_odb__dbModule swig_types[119]
#define SWIGTYPE_p_odb__dbNet swig_types[120]
#define SWIGTYPE_p_odb__dbObstruction swig_types[121]
#define SWIGTYPE_p_odb__dbProperty swig_types[122]
#define SWIGTYPE_p_odb__dbRSeg swig_types[123]
#define SWIGTYPE_p_odb__dbRegion swig_types[124]
#define SWIGTYPE_p_odb__dbRow swig_types[125]
#define SWIGTYPE_p_odb__dbSBox swig_types[126]
#define SWIGTYPE_p_odb__dbSWire swig_types[127]
#define SWIGTYPE_p_odb__dbSite swig_types[128]
#define SWIGTYPE_p_odb__dbStringProperty swig_types[129]
#define SWIGTYPE_p_odb__dbTarget swig_types[130]
#define SWIGTYPE_p_odb__dbTechLayer swig_types[131]
#define SWIGTYPE_p_odb__dbTechLayerCornerSpacingRule swig_types[132]
#define SWIGTYPE_p_odb__dbTechLayerCutClassRule swig_types[133]
#define SWIGTYPE_p_odb__dbTechLayerCutSpacingRule swig_types[134]
#define SWIGTYPE_p_odb__dbTechLayerCutSpacingTableDefRule swig_types[135]
#define SWIGTYPE_p_odb__dbTechLayerCutSpacingTableOrthRule swig_types[136]
#define SWIGTYPE_p_odb__dbTechLayerMinStepRule swig_types[137]
#define SWIGTYPE_p_odb__dbTechLayerSpacingRule swig_types[138]
#define SWIGTYPE_p_odb__dbTechLayerSpacingTablePrlRule swig_types[139]
#define SWIGTYPE_p_odb__dbTechMinCutRule swig_types[140]
#define SWIGTYPE_p_odb__dbTechMinEncRule swig_types[141]
#define SWIGTYPE_p_odb__dbTechNonDefaultRule swig_types[142]
#define SWIGTYPE_p_odb__dbTechV55InfluenceEntry swig_types[143]
#define SWIGTYPE_p_odb__dbTechVia swig_types[144]
#define SWIGTYPE_p_odb__dbTechViaGenerateRule swig_types[145]
#define SWIGTYPE_p_odb__dbTechViaRule swig_types[146]
#define SWIGTYPE_p_odb__dbTrackGrid swig_types[147]
#define SWIGTYPE_p_odb__dbVia swig_types[148]
#define SWIGTYPE_p_odb__dbWire swig_types[149]
#define SWIGTYPE_p_p_dbNet swig_types[150]
#define SWIGTYPE_p_p_std__vectorT_dbNet_p_t swig_types[151]
#define SWIGTYPE_p_size_type swig_types[152]
#define SWIGTYPE_p_sta__Sta swig_types[153]
#define SWIGTYPE_p_std__out_of_range swig_types[154]
#define SWIGTYPE_p_std__vectorT_dbNet_p_t swig_types[155]
#define SWIGTYPE_p_value_type swig_types[156]
#define SWIGTYPE_std__ptrdiff_t swig_types[157]
#define SWIGTYPE_std__size_t swig_types[158]
static swig_type_info *swig_types[160];
static swig_module_info swig_module = {swig_types, 159, 0, 0, 0, 0};
#define SWIG_TypeQuery(name) SWIG_TypeQueryModule(&swig_module, &swig_module, name)
#define SWIG_MangledTypeQuery(name) SWIG_MangledTypeQueryModule(&swig_module, &swig_module, name)

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Dbsta_Init
#define SWIG_name    "dbsta"
#define SWIG_prefix  "sta::"
#define SWIG_namespace "sta"

#define SWIG_version "0.0"

#define SWIGVERSION 0x040001 
#define SWIG_VERSION SWIGVERSION


#define SWIG_as_voidptr(a) const_cast< void * >(static_cast< const void * >(a)) 
#define SWIG_as_voidptrptr(a) ((void)SWIG_as_voidptr(*a),reinterpret_cast< void** >(a)) 


#include <stdexcept>



#ifdef __cplusplus
extern "C" {
#endif
#ifdef MAC_TCL
#pragma export on
#endif
SWIGEXPORT int SWIG_init(Tcl_Interp *);
#ifdef MAC_TCL
#pragma export off
#endif
#ifdef __cplusplus
}
#endif

/* Compatibility version for TCL stubs */
#ifndef SWIG_TCL_STUBS_VERSION
#define SWIG_TCL_STUBS_VERSION "8.1"
#endif




#include "odb/db.h"
#include "db_sta/dbSta.hh"
#include "db_sta/dbNetwork.hh"
#include "ord/OpenRoad.hh"

namespace ord {
// Defined in OpenRoad.i
OpenRoad *getOpenRoad();
}

using sta::Instance;






// OpenSTA, Static Timing Analyzer
// Copyright (c) 2022, Parallax Software, Inc.
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

////////////////////////////////////////////////////////////////
//
// Most of the TCL SWIG interface code is in this file.  This and any
// optional interface code is %included into a final interface file
// used by the application.
//
// Define TCL methods for each network object.  This works despite the
// fact that the underlying implementation does not have class methods
// corresponding to the TCL methods defined here.
//
// Note the function name changes from sta naming convention
// (lower/capitalize) to TCL naming convention (lower/underscore).
//
////////////////////////////////////////////////////////////////

#include <limits>

#include "Machine.hh"
#include "StaConfig.hh"  // STA_VERSION
#include "Stats.hh"
#include "Report.hh"
#include "Error.hh"
#include "StringUtil.hh"
#include "PatternMatch.hh"
#include "MinMax.hh"
#include "Fuzzy.hh"
#include "FuncExpr.hh"
#include "Units.hh"
#include "Transition.hh"
#include "TimingRole.hh"
#include "TimingArc.hh"
#include "Liberty.hh"
#include "EquivCells.hh"
#include "Wireload.hh"
#include "PortDirection.hh"
#include "Network.hh"
#include "Clock.hh"
#include "PortDelay.hh"
#include "ExceptionPath.hh"
#include "Sdc.hh"
#include "Graph.hh"
#include "Parasitics.hh"
#include "DelayCalc.hh"
#include "DcalcAnalysisPt.hh"
#include "Corner.hh"
#include "PathVertex.hh"
#include "PathRef.hh"
#include "PathExpanded.hh"
#include "PathEnd.hh"
#include "PathGroup.hh"
#include "PathAnalysisPt.hh"
#include "Property.hh"
#include "WritePathSpice.hh"
#include "Search.hh"
#include "Sta.hh"
#include "search/Tag.hh"
#include "search/CheckTiming.hh"
#include "search/CheckMinPulseWidths.hh"
#include "search/Levelize.hh"
#include "search/ReportPath.hh"
#include "search/Power.hh"

namespace sta {

////////////////////////////////////////////////////////////////
//
// C++ helper functions used by the interface functions.
// These are not visible in the TCL API.
//
////////////////////////////////////////////////////////////////

typedef Vector<Library*> LibrarySeq;
typedef CellSeq TmpCellSeq;
typedef LibertyCellSeq TmpLibertyCellSeq;
typedef PortSeq TmpPortSeq;
typedef LibertyPortSeq TmpLibertyPortSeq;
typedef PinSet TmpPinSet;
typedef PinSeq TmpPinSeq;
typedef InstanceSeq TmpInstanceSeq;
typedef InstanceSet TmpInstanceSet;
typedef MinPulseWidthCheckSeq::Iterator MinPulseWidthCheckSeqIterator;
typedef FloatSeq TmpFloatSeq;
typedef string TmpString;
typedef Set<const char*, CharPtrLess> StringSet;
typedef MinMaxAll MinMaxAllNull;
typedef ClockSet TmpClockSet;
typedef StringSeq TmpStringSeq;

using std::vector;

// Get the network for commands.
Network *
cmdNetwork()
{
  return Sta::sta()->cmdNetwork();
}

// Make sure the network has been read and linked.
// Throwing an error means the caller doesn't have to check the result.
Network *
cmdLinkedNetwork()
{
  Network *network = cmdNetwork();
  if (network->isLinked())
    return network;
  else {
    Report *report = Sta::sta()->report();
    report->error(201, "no network has been linked.");
    return nullptr;
  }
}

// Make sure an editable network has been read and linked.
NetworkEdit *
cmdEditNetwork()
{
  Network *network = cmdLinkedNetwork();
  if (network->isEditable())
    return dynamic_cast<NetworkEdit*>(network);
  else {
    Report *report = Sta::sta()->report();
    report->error(202, "network does not support edits.");
    return nullptr;
  }
}

// Get the graph for commands.
// Throw to cmd level on failure.
Graph *
cmdGraph()
{
  cmdLinkedNetwork();
  return Sta::sta()->ensureGraph();
}

template <class TYPE>
Vector<TYPE> *
tclListSeq(Tcl_Obj *const source,
	   swig_type_info *swig_type,
	   Tcl_Interp *interp)
{
  int argc;
  Tcl_Obj **argv;

  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK
      && argc > 0) {
    Vector<TYPE> *seq = new Vector<TYPE>;
    for (int i = 0; i < argc; i++) {
      void *obj;
      // Ignore returned TCL_ERROR because can't get swig_type_info.
      SWIG_ConvertPtr(argv[i], &obj, swig_type, false);
      seq->push_back(reinterpret_cast<TYPE>(obj));
    }
    return seq;
  }
  else
    return nullptr;
}

LibertyLibrarySeq *
tclListSeqLibertyLibrary(Tcl_Obj *const source,
			 Tcl_Interp *interp)
{
  return tclListSeq<LibertyLibrary*>(source, SWIGTYPE_p_LibertyLibrary, interp);
}

vector<LibertyCell*> *
tclListSeqLibertyCell(Tcl_Obj *const source,
		      Tcl_Interp *interp)
{
  return tclListSeq<LibertyCell*>(source, SWIGTYPE_p_LibertyCell, interp);
}

template <class TYPE>
Set<TYPE> *
tclListSet(Tcl_Obj *const source,
	   swig_type_info *swig_type,
	   Tcl_Interp *interp)
{
  int argc;
  Tcl_Obj **argv;

  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK
      && argc > 0) {
    Set<TYPE> *set = new Set<TYPE>;
    for (int i = 0; i < argc; i++) {
      void *obj;
      // Ignore returned TCL_ERROR because can't get swig_type_info.
      SWIG_ConvertPtr(argv[i], &obj, swig_type, false);
      set->insert(reinterpret_cast<TYPE>(obj));
    }
    return set;
  }
  else
    return nullptr;
}

PinSet *
tclListSetPin(Tcl_Obj *const source,
              Tcl_Interp *interp)
{
  return tclListSet<Pin*>(source, SWIGTYPE_p_Pin, interp);
}

StringSet *
tclListSetConstChar(Tcl_Obj *const source,
		    Tcl_Interp *interp)
{
  int argc;
  Tcl_Obj **argv;

  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK) {
    StringSet *set = new StringSet;
    for (int i = 0; i < argc; i++) {
      int length;
      const char *str = Tcl_GetStringFromObj(argv[i], &length);
      set->insert(str);
    }
    return set;
  }
  else
    return nullptr;
}

StringSeq *
tclListSeqConstChar(Tcl_Obj *const source,
		    Tcl_Interp *interp)
{
  int argc;
  Tcl_Obj **argv;

  if (Tcl_ListObjGetElements(interp, source, &argc, &argv) == TCL_OK) {
    StringSeq *seq = new StringSeq;
    for (int i = 0; i < argc; i++) {
      int length;
      const char *str = Tcl_GetStringFromObj(argv[i], &length);
      seq->push_back(str);
    }
    return seq;
  }
  else
    return nullptr;
}

////////////////////////////////////////////////////////////////

TmpPinSet *
findStartpoints()
{
  PinSet *pins = new PinSet;
  VertexPinCollector visitor(pins);
  Sta::sta()->visitStartpoints(&visitor);
  return pins;
}

TmpPinSet *
findEndpoints()
{
  PinSet *pins = new PinSet;
  VertexPinCollector visitor(pins);
  Sta::sta()->visitEndpoints(&visitor);
  return pins;
}

void
pushPowerResultFloats(PowerResult &power,
		      TmpFloatSeq *floats)
{
  floats->push_back(power.internal());
  floats->push_back(power.switching());
  floats->push_back(power.leakage());
  floats->push_back(power.total());
}

////////////////////////////////////////////////////////////////

void
tclArgError(Tcl_Interp *interp,
            const char *msg,
            const char *arg)
{
  // Swig does not add try/catch around arg parsing so this cannot use Report::error.
  string error_msg = "Error: ";
  error_msg += msg;
  char *error = stringPrint(error_msg.c_str(), arg);
  Tcl_SetResult(interp, error, TCL_VOLATILE);
  stringDelete(error);
}

void
objectListNext(const char *list,
	       const char *type,
	       // Return values.
	       bool &type_match,
	       const char *&next)
{
  // Default return values (failure).
  type_match = false;
  next = nullptr;
  // _hexaddress_p_type
  const char *s = list;
  char ch = *s++;
  if (ch == '_') {
    while (*s && isxdigit(*s))
      s++;
    if ((s - list - 1) == sizeof(void*) * 2
	&& *s && *s++ == '_'
	&& *s && *s++ == 'p'
	&& *s && *s++ == '_') {
      const char *t = type;
      while (*s && *s != ' ') {
	if (*s != *t)
	  return;
	s++;
	t++;
      }
      type_match = true;
      if (*s)
	next = s + 1;
      else
	next = nullptr;
    }
  }
}

} // namespace

using namespace sta;


SWIGINTERN char const *Library_name(Library *self){
  return cmdNetwork()->name(self);
}

#include <limits.h>
#if !defined(SWIG_NO_LLONG_MAX)
# if !defined(LLONG_MAX) && defined(__GNUC__) && defined (__LONG_LONG_MAX__)
#   define LLONG_MAX __LONG_LONG_MAX__
#   define LLONG_MIN (-LLONG_MAX - 1LL)
#   define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)
# endif
#endif


SWIGINTERNINLINE Tcl_Obj *
SWIG_FromCharPtrAndSize(const char* carray, size_t size)
{
  return (size < INT_MAX) ? Tcl_NewStringObj(carray, static_cast< int >(size)) : NULL;
}


SWIGINTERNINLINE Tcl_Obj * 
SWIG_FromCharPtr(const char *cptr)
{ 
  return SWIG_FromCharPtrAndSize(cptr, (cptr ? strlen(cptr) : 0));
}


SWIGINTERN int
SWIG_AsCharPtrAndSize(Tcl_Obj *obj, char** cptr, size_t* psize, int *alloc)
{ 
  int len = 0;
  char *cstr = Tcl_GetStringFromObj(obj, &len);
  if (cstr) {
    if (cptr)  *cptr = cstr;
    if (psize) *psize = len + 1;
    if (alloc) *alloc = SWIG_OLDOBJ;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}




SWIGINTERN Cell *Library_find_cell(Library *self,char const *name){
  return cmdNetwork()->findCell(self, name);
}

SWIGINTERN int
SWIG_AsVal_bool SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, bool *val)
{
  int v;
  if (Tcl_GetBooleanFromObj(0, obj, &v) == TCL_OK) {
    if (val) *val = v ? true : false;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}

SWIGINTERN TmpCellSeq *Library_find_cells_matching(Library *self,char const *pattern,bool regexp,bool nocase){
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  TmpCellSeq *cells = new TmpCellSeq;
  cmdNetwork()->findCellsMatching(self, &matcher, cells);
  return cells;
}
SWIGINTERN bool LibraryIterator_has_next(LibraryIterator *self){ return self->hasNext(); }

  #define SWIG_From_bool   Tcl_NewBooleanObj 

SWIGINTERN Library *LibraryIterator_next(LibraryIterator *self){ return self->next(); }
SWIGINTERN void LibraryIterator_finish(LibraryIterator *self){ delete self; }
SWIGINTERN Library *Cell_library(Cell *self){ return cmdNetwork()->library(self); }
SWIGINTERN LibertyCell *Cell_liberty_cell(Cell *self){ return cmdNetwork()->libertyCell(self); }
SWIGINTERN bool Cell_is_leaf(Cell *self){ return cmdNetwork()->isLeaf(self); }
SWIGINTERN CellPortIterator *Cell_port_iterator(Cell *self){ return cmdNetwork()->portIterator(self); }
SWIGINTERN Port *Cell_find_port(Cell *self,char const *name){
  return cmdNetwork()->findPort(self, name);
}
SWIGINTERN TmpPortSeq *Cell_find_ports_matching(Cell *self,char const *pattern,bool regexp,bool nocase){
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  TmpPortSeq *ports = new TmpPortSeq;
  cmdNetwork()->findPortsMatching(self, &matcher, ports);
  return ports;
}
SWIGINTERN bool CellPortIterator_has_next(CellPortIterator *self){ return self->hasNext(); }
SWIGINTERN Port *CellPortIterator_next(CellPortIterator *self){ return self->next(); }
SWIGINTERN void CellPortIterator_finish(CellPortIterator *self){ delete self; }
SWIGINTERN bool LibertyCellPortIterator_has_next(LibertyCellPortIterator *self){ return self->hasNext(); }
SWIGINTERN LibertyPort *LibertyCellPortIterator_next(LibertyCellPortIterator *self){ return self->next(); }
SWIGINTERN void LibertyCellPortIterator_finish(LibertyCellPortIterator *self){ delete self; }
SWIGINTERN char const *Port_bus_name(Port *self){ return cmdNetwork()->busName(self); }
SWIGINTERN Cell *Port_cell(Port *self){ return cmdNetwork()->cell(self); }
SWIGINTERN LibertyPort *Port_liberty_port(Port *self){ return cmdNetwork()->libertyPort(self); }
SWIGINTERN bool Port_is_bus(Port *self){ return cmdNetwork()->isBus(self); }
SWIGINTERN PortMemberIterator *Port_member_iterator(Port *self){ return cmdNetwork()->memberIterator(self); }
SWIGINTERN bool PortMemberIterator_has_next(PortMemberIterator *self){ return self->hasNext(); }
SWIGINTERN Port *PortMemberIterator_next(PortMemberIterator *self){ return self->next(); }
SWIGINTERN void PortMemberIterator_finish(PortMemberIterator *self){ delete self; }
SWIGINTERN char const *LibertyLibrary_name(LibertyLibrary *self){ return self->name(); }
SWIGINTERN LibertyCell *LibertyLibrary_find_liberty_cell(LibertyLibrary *self,char const *name){
  return self->findLibertyCell(name);
}
SWIGINTERN TmpLibertyCellSeq *LibertyLibrary_find_liberty_cells_matching(LibertyLibrary *self,char const *pattern,bool regexp,bool nocase){
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  // TmpLibertyCellSeq deletes temporary CellSeq after conversion to tcl list.
  TmpLibertyCellSeq *cells = new TmpLibertyCellSeq;
  self->findLibertyCellsMatching(&matcher, cells);
  return cells;
}
SWIGINTERN Wireload *LibertyLibrary_find_wireload(LibertyLibrary *self,char const *model_name){
  return self->findWireload(model_name);
}
SWIGINTERN WireloadSelection *LibertyLibrary_find_wireload_selection(LibertyLibrary *self,char const *selection_name){
  return self->findWireloadSelection(selection_name);
}
SWIGINTERN OperatingConditions *LibertyLibrary_find_operating_conditions(LibertyLibrary *self,char const *op_cond_name){
  return self->findOperatingConditions(op_cond_name);
}
SWIGINTERN OperatingConditions *LibertyLibrary_default_operating_conditions(LibertyLibrary *self){
  return self->defaultOperatingConditions();
}
SWIGINTERN bool LibertyLibraryIterator_has_next(LibertyLibraryIterator *self){ return self->hasNext(); }
SWIGINTERN LibertyLibrary *LibertyLibraryIterator_next(LibertyLibraryIterator *self){ return self->next(); }
SWIGINTERN void LibertyLibraryIterator_finish(LibertyLibraryIterator *self){ delete self; }
SWIGINTERN char const *LibertyCell_name(LibertyCell *self){ return self->name(); }
SWIGINTERN bool LibertyCell_is_leaf(LibertyCell *self){ return self->isLeaf(); }
SWIGINTERN bool LibertyCell_is_buffer(LibertyCell *self){ return self->isBuffer(); }
SWIGINTERN bool LibertyCell_is_inverter(LibertyCell *self){ return self->isInverter(); }
SWIGINTERN LibertyLibrary *LibertyCell_liberty_library(LibertyCell *self){ return self->libertyLibrary(); }
SWIGINTERN Cell *LibertyCell_cell(LibertyCell *self){ return reinterpret_cast<Cell*>(self); }
SWIGINTERN LibertyPort *LibertyCell_find_liberty_port(LibertyCell *self,char const *name){
  return self->findLibertyPort(name);
}
SWIGINTERN TmpLibertyPortSeq *LibertyCell_find_liberty_ports_matching(LibertyCell *self,char const *pattern,bool regexp,bool nocase){
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  TmpLibertyPortSeq *ports = new TmpLibertyPortSeq;
  self->findLibertyPortsMatching(&matcher, ports);
  return ports;
}
SWIGINTERN LibertyCellPortIterator *LibertyCell_liberty_port_iterator(LibertyCell *self){ return new LibertyCellPortIterator(self); }
SWIGINTERN LibertyCellTimingArcSetIterator *LibertyCell_timing_arc_set_iterator(LibertyCell *self){ return new LibertyCellTimingArcSetIterator(self); }
SWIGINTERN char const *LibertyPort_bus_name(LibertyPort *self){ return self->busName(); }
SWIGINTERN Cell *LibertyPort_cell(LibertyPort *self){ return self->cell(); }
SWIGINTERN bool LibertyPort_is_bus(LibertyPort *self){ return self->isBus(); }
SWIGINTERN LibertyPortMemberIterator *LibertyPort_member_iterator(LibertyPort *self){ return new LibertyPortMemberIterator(self); }
SWIGINTERN char const *LibertyPort_function(LibertyPort *self){
  FuncExpr *func = self->function();
  if (func)
    return func->asString();
  else
    return nullptr;
}
SWIGINTERN char const *LibertyPort_tristate_enable(LibertyPort *self){
  FuncExpr *enable = self->tristateEnable();
  if (enable)
    return enable->asString();
  else
    return nullptr;
}
SWIGINTERN float LibertyPort_capacitance(LibertyPort *self,Corner *corner,MinMax const *min_max){
  Sta *sta = Sta::sta();
  return sta->capacitance(self, corner, min_max);
}

  #define SWIG_From_double   Tcl_NewDoubleObj 


SWIGINTERNINLINE Tcl_Obj *
SWIG_From_float  (float value)
{    
  return SWIG_From_double  (value);
}

SWIGINTERN bool LibertyPortMemberIterator_has_next(LibertyPortMemberIterator *self){ return self->hasNext(); }
SWIGINTERN LibertyPort *LibertyPortMemberIterator_next(LibertyPortMemberIterator *self){ return self->next(); }
SWIGINTERN void LibertyPortMemberIterator_finish(LibertyPortMemberIterator *self){ delete self; }
SWIGINTERN LibertyPort *TimingArcSet_from(TimingArcSet *self){ return self->from(); }
SWIGINTERN LibertyPort *TimingArcSet_to(TimingArcSet *self){ return self->to(); }
SWIGINTERN TimingRole *TimingArcSet_role(TimingArcSet *self){ return self->role(); }
SWIGINTERN char const *TimingArcSet_sdf_cond(TimingArcSet *self){ return self->sdfCond(); }
SWIGINTERN char const *TimingArcSet_full_name(TimingArcSet *self){
  const char *from = self->from()->name();
  const char *to = self->to()->name();
  const char *cell_name = self->libertyCell()->name();
  return stringPrintTmp("%s %s -> %s",
			cell_name,
			from,
			to);
}
SWIGINTERN bool LibertyCellTimingArcSetIterator_has_next(LibertyCellTimingArcSetIterator *self){ return self->hasNext(); }
SWIGINTERN TimingArcSet *LibertyCellTimingArcSetIterator_next(LibertyCellTimingArcSetIterator *self){ return self->next(); }
SWIGINTERN void LibertyCellTimingArcSetIterator_finish(LibertyCellTimingArcSetIterator *self){ delete self; }
SWIGINTERN bool TimingArcSetArcIterator_has_next(TimingArcSetArcIterator *self){ return self->hasNext(); }
SWIGINTERN TimingArc *TimingArcSetArcIterator_next(TimingArcSetArcIterator *self){ return self->next(); }
SWIGINTERN void TimingArcSetArcIterator_finish(TimingArcSetArcIterator *self){ delete self; }
SWIGINTERN LibertyPort *TimingArc_from(TimingArc *self){ return self->from(); }
SWIGINTERN LibertyPort *TimingArc_to(TimingArc *self){ return self->to(); }
SWIGINTERN Transition *TimingArc_from_edge(TimingArc *self){ return self->fromEdge(); }
SWIGINTERN char const *TimingArc_from_edge_name(TimingArc *self){ return self->fromEdge()->asRiseFall()->name(); }
SWIGINTERN Transition *TimingArc_to_edge(TimingArc *self){ return self->toEdge(); }
SWIGINTERN char const *TimingArc_to_edge_name(TimingArc *self){ return self->toEdge()->asRiseFall()->name(); }
SWIGINTERN TimingRole *TimingArc_role(TimingArc *self){ return self->role(); }
SWIGINTERN Instance *Instance_parent(Instance *self){ return cmdLinkedNetwork()->parent(self); }
SWIGINTERN Cell *Instance_cell(Instance *self){ return cmdLinkedNetwork()->cell(self); }
SWIGINTERN LibertyCell *Instance_liberty_cell(Instance *self){ return cmdLinkedNetwork()->libertyCell(self); }
SWIGINTERN bool Instance_is_leaf(Instance *self){ return cmdLinkedNetwork()->isLeaf(self); }
SWIGINTERN InstanceChildIterator *Instance_child_iterator(Instance *self){ return cmdLinkedNetwork()->childIterator(self); }
SWIGINTERN InstancePinIterator *Instance_pin_iterator(Instance *self){ return cmdLinkedNetwork()->pinIterator(self); }
SWIGINTERN InstanceNetIterator *Instance_net_iterator(Instance *self){ return cmdLinkedNetwork()->netIterator(self); }
SWIGINTERN Pin *Instance_find_pin(Instance *self,char const *name){
  return cmdLinkedNetwork()->findPin(self, name);
}
SWIGINTERN char const *Pin_port_name(Pin *self){ return cmdLinkedNetwork()->portName(self); }
SWIGINTERN Instance *Pin_instance(Pin *self){ return cmdLinkedNetwork()->instance(self); }
SWIGINTERN Net *Pin_net(Pin *self){ return cmdLinkedNetwork()->net(self); }
SWIGINTERN Port *Pin_port(Pin *self){ return cmdLinkedNetwork()->port(self); }
SWIGINTERN Term *Pin_term(Pin *self){ return cmdLinkedNetwork()->term(self); }
SWIGINTERN LibertyPort *Pin_liberty_port(Pin *self){ return cmdLinkedNetwork()->libertyPort(self); }
SWIGINTERN bool Pin_is_driver(Pin *self){ return cmdLinkedNetwork()->isDriver(self); }
SWIGINTERN bool Pin_is_load(Pin *self){ return cmdLinkedNetwork()->isLoad(self); }
SWIGINTERN bool Pin_is_leaf(Pin *self){ return cmdLinkedNetwork()->isLeaf(self); }
SWIGINTERN bool Pin_is_hierarchical(Pin *self){ return cmdLinkedNetwork()->isHierarchical(self); }
SWIGINTERN bool Pin_is_top_level_port(Pin *self){ return cmdLinkedNetwork()->isTopLevelPort(self); }
SWIGINTERN PinConnectedPinIterator *Pin_connected_pin_iterator(Pin *self){ return cmdLinkedNetwork()->connectedPinIterator(self); }
SWIGINTERN Vertex **Pin_vertices(Pin *self){
  Vertex *vertex, *vertex_bidirect_drvr;
  static Vertex *vertices[3];

  cmdGraph()->pinVertices(self, vertex, vertex_bidirect_drvr);
  vertices[0] = vertex;
  vertices[1] = vertex_bidirect_drvr;
  vertices[2] = nullptr;
  return vertices;
}
SWIGINTERN float Pin_capacitance(Pin *self,RiseFall const *rf,Corner const *corner,MinMax const *min_max){
  cmdLinkedNetwork();
  float pin_cap, wire_cap;
  Sta::sta()->connectedCap(self, rf, corner, min_max, pin_cap, wire_cap);
  return pin_cap + wire_cap;
}
SWIGINTERN float Pin_pin_capacitance(Pin *self,RiseFall const *rf,Corner const *corner,MinMax const *min_max){
  cmdLinkedNetwork();
  float pin_cap, wire_cap;
  Sta::sta()->connectedCap(self, rf, corner, min_max, pin_cap, wire_cap);
  return pin_cap;
}
SWIGINTERN float Pin_wire_capacitance(Pin *self,RiseFall const *rf,Corner const *corner,MinMax const *min_max){
  cmdLinkedNetwork();
  float pin_cap, wire_cap;
  Sta::sta()->connectedCap(self, rf, corner, min_max, pin_cap, wire_cap);
  return wire_cap;
}
SWIGINTERN Net *Term_net(Term *self){ return cmdLinkedNetwork()->net(self); }
SWIGINTERN Pin *Term_pin(Term *self){ return cmdLinkedNetwork()->pin(self); }
SWIGINTERN bool InstanceChildIterator_has_next(InstanceChildIterator *self){ return self->hasNext(); }
SWIGINTERN Instance *InstanceChildIterator_next(InstanceChildIterator *self){ return self->next(); }
SWIGINTERN void InstanceChildIterator_finish(InstanceChildIterator *self){ delete self; }
SWIGINTERN bool InstancePinIterator_has_next(InstancePinIterator *self){ return self->hasNext(); }
SWIGINTERN Pin *InstancePinIterator_next(InstancePinIterator *self){ return self->next(); }
SWIGINTERN void InstancePinIterator_finish(InstancePinIterator *self){ delete self; }
SWIGINTERN bool InstanceNetIterator_has_next(InstanceNetIterator *self){ return self->hasNext(); }
SWIGINTERN Net *InstanceNetIterator_next(InstanceNetIterator *self){ return self->next(); }
SWIGINTERN void InstanceNetIterator_finish(InstanceNetIterator *self){ delete self; }
SWIGINTERN bool LeafInstanceIterator_has_next(LeafInstanceIterator *self){ return self->hasNext(); }
SWIGINTERN Instance *LeafInstanceIterator_next(LeafInstanceIterator *self){ return self->next(); }
SWIGINTERN void LeafInstanceIterator_finish(LeafInstanceIterator *self){ delete self; }
SWIGINTERN Instance *Net_instance(Net *self){ return cmdLinkedNetwork()->instance(self); }
SWIGINTERN Net *Net_highest_connected_net(Net *self){ return cmdLinkedNetwork()->highestConnectedNet(self); }
SWIGINTERN NetPinIterator *Net_pin_iterator(Net *self){ return cmdLinkedNetwork()->pinIterator(self);}
SWIGINTERN NetTermIterator *Net_term_iterator(Net *self){return cmdLinkedNetwork()->termIterator(self);}
SWIGINTERN NetConnectedPinIterator *Net_connected_pin_iterator(Net *self){ return cmdLinkedNetwork()->connectedPinIterator(self); }
SWIGINTERN bool Net_is_power(Net *self){ return cmdLinkedNetwork()->isPower(self);}
SWIGINTERN bool Net_is_ground(Net *self){ return cmdLinkedNetwork()->isGround(self);}
SWIGINTERN float Net_capacitance(Net *self,Corner *corner,MinMax const *min_max){
  cmdLinkedNetwork();
  float pin_cap, wire_cap;
  Sta::sta()->connectedCap(self, corner, min_max, pin_cap, wire_cap);
  return pin_cap + wire_cap;
}
SWIGINTERN float Net_pin_capacitance(Net *self,Corner *corner,MinMax const *min_max){
  cmdLinkedNetwork();
  float pin_cap, wire_cap;
  Sta::sta()->connectedCap(self, corner, min_max, pin_cap, wire_cap);
  return pin_cap;
}
SWIGINTERN float Net_wire_capacitance(Net *self,Corner *corner,MinMax const *min_max){
  cmdLinkedNetwork();
  float pin_cap, wire_cap;
  Sta::sta()->connectedCap(self, corner, min_max, pin_cap, wire_cap);
  return wire_cap;
}
SWIGINTERN TmpPortSeq *Net_ports(Net *self){
  Network *network = cmdLinkedNetwork();
  PortSeq *ports = new PortSeq;
  if (network->isTopInstance(network->instance(self))) {
    NetTermIterator *term_iter = network->termIterator(self);
    while (term_iter->hasNext()) {
      Term *term = term_iter->next();
      Port *port = network->port(network->pin(term));
      ports->push_back(port);
    }
    delete term_iter;
  }
  return ports;
}
SWIGINTERN bool NetPinIterator_has_next(NetPinIterator *self){ return self->hasNext(); }
SWIGINTERN Pin *NetPinIterator_next(NetPinIterator *self){ return self->next(); }
SWIGINTERN void NetPinIterator_finish(NetPinIterator *self){ delete self; }
SWIGINTERN bool NetTermIterator_has_next(NetTermIterator *self){ return self->hasNext(); }
SWIGINTERN Term *NetTermIterator_next(NetTermIterator *self){ return self->next(); }
SWIGINTERN void NetTermIterator_finish(NetTermIterator *self){ delete self; }
SWIGINTERN bool NetConnectedPinIterator_has_next(NetConnectedPinIterator *self){ return self->hasNext(); }
SWIGINTERN Pin *NetConnectedPinIterator_next(NetConnectedPinIterator *self){ return self->next(); }
SWIGINTERN void NetConnectedPinIterator_finish(NetConnectedPinIterator *self){ delete self; }
SWIGINTERN bool PinConnectedPinIterator_has_next(PinConnectedPinIterator *self){ return self->hasNext(); }
SWIGINTERN Pin *PinConnectedPinIterator_next(PinConnectedPinIterator *self){ return self->next(); }
SWIGINTERN void PinConnectedPinIterator_finish(PinConnectedPinIterator *self){ delete self; }
SWIGINTERN float Clock_period(Clock *self){ return self->period(); }
SWIGINTERN FloatSeq *Clock_waveform(Clock *self){ return self->waveform(); }
SWIGINTERN float Clock_time(Clock *self,RiseFall *rf){ return self->edge(rf)->time(); }
SWIGINTERN bool Clock_is_generated(Clock *self){ return self->isGenerated(); }
SWIGINTERN bool Clock_waveform_valid(Clock *self){ return self->waveformValid(); }
SWIGINTERN bool Clock_is_virtual(Clock *self){ return self->isVirtual(); }
SWIGINTERN bool Clock_is_propagated(Clock *self){ return self->isPropagated(); }
SWIGINTERN PinSet &Clock_sources(Clock *self){ return self->pins(); }
SWIGINTERN float Clock_slew(Clock *self,RiseFall const *rf,MinMax const *min_max){
  return self->slew(rf, min_max);
}
SWIGINTERN bool ClockIterator_has_next(ClockIterator *self){ return self->hasNext(); }
SWIGINTERN Clock *ClockIterator_next(ClockIterator *self){ return self->next(); }
SWIGINTERN void ClockIterator_finish(ClockIterator *self){ delete self; }
SWIGINTERN Clock *ClockEdge_clock(ClockEdge *self){ return self->clock(); }
SWIGINTERN RiseFall *ClockEdge_transition(ClockEdge *self){ return self->transition(); }
SWIGINTERN float ClockEdge_time(ClockEdge *self){ return self->time(); }
SWIGINTERN Pin *Vertex_pin(Vertex *self){ return self->pin(); }
SWIGINTERN bool Vertex_is_bidirect_driver(Vertex *self){ return self->isBidirectDriver(); }
SWIGINTERN int Vertex_level(Vertex *self){ return Sta::sta()->vertexLevel(self); }

SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_long  (long value)
{
  if (((long) INT_MIN <= value) && (value <= (long) INT_MAX)) {
    return Tcl_NewIntObj(static_cast< int >(value));
  } else {
    return Tcl_NewLongObj(value);
  }
}


SWIGINTERNINLINE Tcl_Obj *
SWIG_From_int  (int value)
{    
  return SWIG_From_long  (value);
}

SWIGINTERN int Vertex_tag_group_index(Vertex *self){ return self->tagGroupIndex(); }
SWIGINTERN Slew Vertex_slew(Vertex *self,RiseFall const *rf,MinMax const *min_max){
  Sta *sta = Sta::sta();
  return sta->vertexSlew(self, rf, min_max);
}
SWIGINTERN Slew Vertex_slew_corner(Vertex *self,RiseFall const *rf,Corner const *corner,MinMax const *min_max){
  Sta *sta = Sta::sta();
  return sta->vertexSlew(self, rf, corner, min_max);
}
SWIGINTERN VertexOutEdgeIterator *Vertex_out_edge_iterator(Vertex *self){
  return new VertexOutEdgeIterator(self, Sta::sta()->graph());
}
SWIGINTERN VertexInEdgeIterator *Vertex_in_edge_iterator(Vertex *self){
  return new VertexInEdgeIterator(self, Sta::sta()->graph());
}
SWIGINTERN TmpFloatSeq *Vertex_arrivals_clk(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf){
  Sta *sta = Sta::sta();
  TmpFloatSeq *floats = new FloatSeq;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    floats->push_back(delayAsFloat(sta->vertexArrival(self, rf, clk_edge,
						      path_ap)));
  }
  return floats;
}

SWIGINTERN int
SWIG_AsVal_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, long* val)
{
  long v;
  if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
    if (val) *val = (long) v;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_int SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, int *val)
{
  long v;
  int res = SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v < INT_MIN || v > INT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< int >(v);
    }
  }  
  return res;
}

SWIGINTERN TmpStringSeq *Vertex_arrivals_clk_delays(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf,int digits){
  Sta *sta = Sta::sta();
  StringSeq *arrivals = new StringSeq;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    arrivals->push_back(delayAsString(sta->vertexArrival(self, rf, clk_edge,
							 path_ap),
				      sta, digits));
  }
  return arrivals;
}
SWIGINTERN TmpFloatSeq *Vertex_requireds_clk(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf){
  Sta *sta = Sta::sta();
  TmpFloatSeq *floats = new FloatSeq;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    floats->push_back(delayAsFloat(sta->vertexRequired(self, rf, clk_edge,
						       path_ap)));
  }
  return floats;
}
SWIGINTERN TmpStringSeq *Vertex_requireds_clk_delays(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf,int digits){
  Sta *sta = Sta::sta();
  StringSeq *requireds = new StringSeq;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    requireds->push_back(delayAsString(sta->vertexRequired(self, rf, clk_edge,
							   path_ap),
				       sta, digits));
  }
  return requireds;
}
SWIGINTERN Slack Vertex_slack(Vertex *self,MinMax *min_max){
  Sta *sta = Sta::sta();
  return sta->vertexSlack(self, min_max);
}
SWIGINTERN TmpFloatSeq *Vertex_slacks(Vertex *self,RiseFall *rf){
  Sta *sta = Sta::sta();
  TmpFloatSeq *floats = new FloatSeq;
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    floats->push_back(delayAsFloat(sta->vertexSlack(self, rf, path_ap)));
  }
  return floats;
}
SWIGINTERN TmpFloatSeq *Vertex_slacks_clk(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf){
  Sta *sta = Sta::sta();
  TmpFloatSeq *floats = new FloatSeq;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    floats->push_back(delayAsFloat(sta->vertexSlack(self, rf, clk_edge,
						    path_ap)));
  }
  return floats;
}
SWIGINTERN TmpStringSeq *Vertex_slacks_clk_delays(Vertex *self,RiseFall const *rf,Clock *clk,RiseFall const *clk_rf,int digits){
  Sta *sta = Sta::sta();
  StringSeq *slacks = new StringSeq;
  const ClockEdge *clk_edge = nullptr;
  if (clk)
    clk_edge = clk->edge(clk_rf);
  for (auto path_ap : sta->corners()->pathAnalysisPts()) {
    slacks->push_back(delayAsString(sta->vertexSlack(self, rf, clk_edge,
						     path_ap),
				    sta, digits));
  }
  return slacks;
}
SWIGINTERN VertexPathIterator *Vertex_path_iterator(Vertex *self,RiseFall const *rf,MinMax const *min_max){
  return Sta::sta()->vertexPathIterator(self, rf, min_max);
}
SWIGINTERN bool Vertex_has_downstream_clk_pin(Vertex *self){
  return self->hasDownstreamClkPin();
}
SWIGINTERN bool Vertex_is_clock(Vertex *self){
  Sta *sta = Sta::sta();
  Search *search = sta->search();
  return search->isClock(self);
}
SWIGINTERN bool Vertex_is_disabled_constraint(Vertex *self){ return self->isDisabledConstraint(); }
SWIGINTERN Vertex *Edge_from(Edge *self){ return self->from(Sta::sta()->graph()); }
SWIGINTERN Vertex *Edge_to(Edge *self){ return self->to(Sta::sta()->graph()); }
SWIGINTERN Pin *Edge_from_pin(Edge *self){ return self->from(Sta::sta()->graph())->pin(); }
SWIGINTERN Pin *Edge_to_pin(Edge *self){ return self->to(Sta::sta()->graph())->pin(); }
SWIGINTERN TimingRole *Edge_role(Edge *self){ return self->role(); }
SWIGINTERN char const *Edge_sense(Edge *self){ return timingSenseString(self->sense()); }
SWIGINTERN TimingArcSetArcIterator *Edge_timing_arc_iterator(Edge *self){ return new TimingArcSetArcIterator(self->timingArcSet()); }
SWIGINTERN bool Edge_is_disabled_loop(Edge *self){ return Sta::sta()->isDisabledLoop(self); }
SWIGINTERN bool Edge_is_disabled_constraint(Edge *self){ return Sta::sta()->isDisabledConstraint(self);}
SWIGINTERN bool Edge_is_disabled_constant(Edge *self){ return Sta::sta()->isDisabledConstant(self); }
SWIGINTERN bool Edge_is_disabled_cond_default(Edge *self){ return Sta::sta()->isDisabledCondDefault(self); }
SWIGINTERN TmpPinSet *Edge_disabled_constant_pins(Edge *self){ return Sta::sta()->disabledConstantPins(self); }
SWIGINTERN bool Edge_is_disabled_bidirect_inst_path(Edge *self){ return Sta::sta()->isDisabledBidirectInstPath(self); }
SWIGINTERN bool Edge_is_disabled_bidirect_net_path(Edge *self){ return Sta::sta()->isDisabledBidirectNetPath(self); }
SWIGINTERN bool Edge_is_disabled_preset_clear(Edge *self){ return Sta::sta()->isDisabledPresetClr(self); }
SWIGINTERN char const *Edge_sim_timing_sense(Edge *self){return timingSenseString(Sta::sta()->simTimingSense(self));}
SWIGINTERN TmpFloatSeq *Edge_arc_delays(Edge *self,TimingArc *arc){
  Sta *sta = Sta::sta();
  TmpFloatSeq *floats = new FloatSeq;
  for (auto dcalc_ap : sta->corners()->dcalcAnalysisPts())
    floats->push_back(delayAsFloat(sta->arcDelay(self, arc, dcalc_ap)));
  return floats;
}
SWIGINTERN TmpStringSeq *Edge_arc_delay_strings(Edge *self,TimingArc *arc,int digits){
  Sta *sta = Sta::sta();
  StringSeq *delays = new StringSeq;
  for (auto dcalc_ap : sta->corners()->dcalcAnalysisPts())
    delays->push_back(delayAsString(sta->arcDelay(self, arc, dcalc_ap),
				    sta, digits));
  return delays;
}
SWIGINTERN bool Edge_delay_annotated(Edge *self,TimingArc *arc,Corner const *corner,MinMax const *min_max){
  DcalcAnalysisPt *dcalc_ap = corner->findDcalcAnalysisPt(min_max);
  return Sta::sta()->arcDelayAnnotated(self, arc, dcalc_ap);
}
SWIGINTERN float Edge_arc_delay(Edge *self,TimingArc *arc,Corner const *corner,MinMax const *min_max){
  DcalcAnalysisPt *dcalc_ap = corner->findDcalcAnalysisPt(min_max);
  return delayAsFloat(Sta::sta()->arcDelay(self, arc, dcalc_ap));
}
SWIGINTERN char const *Edge_cond(Edge *self){
  FuncExpr *cond = self->timingArcSet()->cond();
  if (cond)
    return cond->asString();
  else
    return nullptr;
}
SWIGINTERN char const *Edge_mode_name(Edge *self){
  return self->timingArcSet()->modeName();
}
SWIGINTERN char const *Edge_mode_value(Edge *self){
  return self->timingArcSet()->modeValue();
}
SWIGINTERN char const *Edge_latch_d_to_q_en(Edge *self){
  if (self->role() == TimingRole::latchDtoQ()) {
    Sta *sta = Sta::sta();
    const Network *network = sta->cmdNetwork();
    const Graph *graph = sta->graph();
    Pin *from_pin = self->from(graph)->pin();
    Instance *inst = network->instance(from_pin);
    LibertyCell *lib_cell = network->libertyCell(inst);
    TimingArcSet *d_q_set = self->timingArcSet();
    LibertyPort *enable_port;
    FuncExpr *enable_func;
    RiseFall *enable_rf;
    lib_cell->latchEnable(d_q_set, enable_port, enable_func, enable_rf);
    const char *en_name = enable_port->name();
    return stringPrintTmp("%s %s", en_name, enable_rf->asString());

  }
  return "";
}
SWIGINTERN bool VertexIterator_has_next(VertexIterator *self){ return self->hasNext(); }
SWIGINTERN Vertex *VertexIterator_next(VertexIterator *self){ return self->next(); }
SWIGINTERN void VertexIterator_finish(VertexIterator *self){ delete self; }
SWIGINTERN bool VertexInEdgeIterator_has_next(VertexInEdgeIterator *self){ return self->hasNext(); }
SWIGINTERN Edge *VertexInEdgeIterator_next(VertexInEdgeIterator *self){ return self->next(); }
SWIGINTERN void VertexInEdgeIterator_finish(VertexInEdgeIterator *self){ delete self; }
SWIGINTERN bool VertexOutEdgeIterator_has_next(VertexOutEdgeIterator *self){ return self->hasNext(); }
SWIGINTERN Edge *VertexOutEdgeIterator_next(VertexOutEdgeIterator *self){ return self->next(); }
SWIGINTERN void VertexOutEdgeIterator_finish(VertexOutEdgeIterator *self){ delete self; }
SWIGINTERN float PathRef_arrival(PathRef *self){
  Sta *sta = Sta::sta();
  return delayAsFloat(self->arrival(sta));
}
SWIGINTERN float PathRef_required(PathRef *self){
  Sta *sta = Sta::sta();
  return delayAsFloat(self->required(sta));
}
SWIGINTERN float PathRef_slack(PathRef *self){
  Sta *sta = Sta::sta();
  return delayAsFloat(self->slack(sta));
}
SWIGINTERN Pin *PathRef_pin(PathRef *self){
  Sta *sta = Sta::sta();
  return self->pin(sta);
}
SWIGINTERN char const *PathRef_tag(PathRef *self){
  Sta *sta = Sta::sta();
  return self->tag(sta)->asString(sta);
}
SWIGINTERN TmpPinSeq *PathRef_pins(PathRef *self){
  Sta *sta = Sta::sta();
  PinSeq *pins = new PinSeq;
  PathRef path1(self);
  while (!path1.isNull()) {
    pins->push_back(path1.vertex(sta)->pin());
    PathRef prev_path;
    path1.prevPath(sta, prev_path);
    path1.init(prev_path);
  }
  return pins;
}
SWIGINTERN bool PathEnd_is_unconstrained(PathEnd *self){ return self->isUnconstrained(); }
SWIGINTERN bool PathEnd_is_check(PathEnd *self){ return self->isCheck(); }
SWIGINTERN bool PathEnd_is_latch_check(PathEnd *self){ return self->isLatchCheck(); }
SWIGINTERN bool PathEnd_is_data_check(PathEnd *self){ return self->isDataCheck(); }
SWIGINTERN bool PathEnd_is_output_delay(PathEnd *self){ return self->isOutputDelay(); }
SWIGINTERN bool PathEnd_is_path_delay(PathEnd *self){ return self->isPathDelay(); }
SWIGINTERN bool PathEnd_is_gated_clock(PathEnd *self){ return self->isGatedClock(); }
SWIGINTERN Vertex *PathEnd_vertex(PathEnd *self){ return self->vertex(Sta::sta()); }
SWIGINTERN PathRef *PathEnd_path(PathEnd *self){ return &self->pathRef(); }
SWIGINTERN RiseFall *PathEnd_end_transition(PathEnd *self){ return const_cast<RiseFall*>(self->path()->transition(Sta::sta())); }
SWIGINTERN Slack PathEnd_slack(PathEnd *self){ return self->slack(Sta::sta()); }
SWIGINTERN ArcDelay PathEnd_margin(PathEnd *self){ return self->margin(Sta::sta()); }
SWIGINTERN Required PathEnd_data_required_time(PathEnd *self){ return self->requiredTimeOffset(Sta::sta()); }
SWIGINTERN Arrival PathEnd_data_arrival_time(PathEnd *self){ return self->dataArrivalTimeOffset(Sta::sta()); }
SWIGINTERN TimingRole *PathEnd_check_role(PathEnd *self){ return self->checkRole(Sta::sta()); }
SWIGINTERN MinMax *PathEnd_min_max(PathEnd *self){ return const_cast<MinMax*>(self->minMax(Sta::sta())); }
SWIGINTERN float PathEnd_source_clk_offset(PathEnd *self){ return self->sourceClkOffset(Sta::sta()); }
SWIGINTERN Arrival PathEnd_source_clk_latency(PathEnd *self){ return self->sourceClkLatency(Sta::sta()); }
SWIGINTERN Arrival PathEnd_source_clk_insertion_delay(PathEnd *self){ return self->sourceClkInsertionDelay(Sta::sta()); }
SWIGINTERN Clock *PathEnd_target_clk(PathEnd *self){ return self->targetClk(Sta::sta()); }
SWIGINTERN ClockEdge *PathEnd_target_clk_edge(PathEnd *self){ return self->targetClkEdge(Sta::sta()); }
SWIGINTERN Path *PathEnd_target_clk_path(PathEnd *self){ return self->targetClkPath(); }
SWIGINTERN float PathEnd_target_clk_time(PathEnd *self){ return self->targetClkTime(Sta::sta()); }
SWIGINTERN float PathEnd_target_clk_offset(PathEnd *self){ return self->targetClkOffset(Sta::sta()); }
SWIGINTERN float PathEnd_target_clk_mcp_adjustment(PathEnd *self){ return self->targetClkMcpAdjustment(Sta::sta()); }
SWIGINTERN Arrival PathEnd_target_clk_delay(PathEnd *self){ return self->targetClkDelay(Sta::sta()); }
SWIGINTERN Arrival PathEnd_target_clk_insertion_delay(PathEnd *self){ return self->targetClkInsertionDelay(Sta::sta()); }
SWIGINTERN float PathEnd_target_clk_uncertainty(PathEnd *self){ return self->targetNonInterClkUncertainty(Sta::sta()); }
SWIGINTERN float PathEnd_inter_clk_uncertainty(PathEnd *self){ return self->interClkUncertainty(Sta::sta()); }
SWIGINTERN Arrival PathEnd_target_clk_arrival(PathEnd *self){ return self->targetClkArrival(Sta::sta()); }
SWIGINTERN bool PathEnd_path_delay_margin_is_external(PathEnd *self){ return self->pathDelayMarginIsExternal();}
SWIGINTERN Crpr PathEnd_common_clk_pessimism(PathEnd *self){ return self->commonClkPessimism(Sta::sta()); }
SWIGINTERN RiseFall *PathEnd_target_clk_end_trans(PathEnd *self){ return const_cast<RiseFall*>(self->targetClkEndTrans(Sta::sta())); }
SWIGINTERN bool MinPulseWidthCheckSeqIterator_has_next(MinPulseWidthCheckSeqIterator *self){ return self->hasNext(); }
SWIGINTERN MinPulseWidthCheck *MinPulseWidthCheckSeqIterator_next(MinPulseWidthCheckSeqIterator *self){ return self->next(); }
SWIGINTERN void MinPulseWidthCheckSeqIterator_finish(MinPulseWidthCheckSeqIterator *self){ delete self; }
SWIGINTERN bool VertexPathIterator_has_next(VertexPathIterator *self){ return self->hasNext(); }
SWIGINTERN PathRef *VertexPathIterator_next(VertexPathIterator *self){
  Path *path = self->next();
  return new PathRef(path);
}
SWIGINTERN void VertexPathIterator_finish(VertexPathIterator *self){ delete self; }
SWIGINTERN bool SlowDrvrIterator_has_next(SlowDrvrIterator *self){ return self->hasNext(); }
SWIGINTERN Instance *SlowDrvrIterator_next(SlowDrvrIterator *self){ return self->next(); }
SWIGINTERN void SlowDrvrIterator_finish(SlowDrvrIterator *self){
  delete self->container();
  delete self;
}
SWIGINTERN float OperatingConditions_process(OperatingConditions *self){ return self->process(); }
SWIGINTERN float OperatingConditions_voltage(OperatingConditions *self){ return self->voltage(); }
SWIGINTERN float OperatingConditions_temperature(OperatingConditions *self){ return self->temperature(); }
SWIGINTERN char const *Corner_name(Corner *self){ return self->name(); }


float float_inf = INF;
int group_count_max = PathGroup::group_count_max;

const char *
version()
{
  return STA_VERSION;
}

const char *
git_sha1()
{
  return STA_GIT_SHA1;
}

void
report_error(int id,
             const char *msg)
{
  Report *report = Sta::sta()->report();
  report->error(id, "%s", msg);
}

void
report_file_error(int id,
                  const char *filename,
                  int line,
                  const char *msg)
{
  Report *report = Sta::sta()->report();
  report->error(id, filename, line, "%s", msg);
}

void
report_warn(int id,
            const char *msg)
{
  Report *report = Sta::sta()->report();
  report->warn(id, "%s", msg);
}

void
report_file_warn(int id,
                 const char *filename,
                 int line,
                 const char *msg)
{
  Report *report = Sta::sta()->report();
  report->fileWarn(id, filename, line, "%s", msg);
}

void
report_line(const char *msg)
{
  Report *report = Sta::sta()->report();
  report->reportLineString(msg);
}

void
fflush()
{
  fflush(stdout);
  fflush(stderr);
}

void
redirect_file_begin(const char *filename)
{
  Sta::sta()->report()->redirectFileBegin(filename);
}

void
redirect_file_append_begin(const char *filename)
{
  Sta::sta()->report()->redirectFileAppendBegin(filename);
}

void
redirect_file_end()
{
  Sta::sta()->report()->redirectFileEnd();
}

void
redirect_string_begin()
{
  Sta::sta()->report()->redirectStringBegin();
}

const char *
redirect_string_end()
{
  return Sta::sta()->report()->redirectStringEnd();
}

void
log_begin_cmd(const char *filename)
{
  Sta::sta()->report()->logBegin(filename);
}

void
log_end()
{
  Sta::sta()->report()->logEnd();
}

void
set_debug(const char *what,
	  int level)
{
  Sta::sta()->setDebugLevel(what, level);
}

bool
is_object(const char *obj)
{
  // _hexaddress_p_type
  const char *s = obj;
  char ch = *s++;
  if (ch != '_')
    return false;
  while (*s && isxdigit(*s))
    s++;
  if ((s - obj - 1) == sizeof(void*) * 2
      && *s && *s++ == '_'
      && *s && *s++ == 'p'
      && *s && *s++ == '_') {
    while (*s && *s != ' ')
      s++;
    return *s == '\0';
  }
  else
    return false;
}

// Assumes is_object is true.
const char *
object_type(const char *obj)
{
  return &obj[1 + sizeof(void*) * 2 + 3];
}

bool
is_object_list(const char *list,
	       const char *type)
{
  const char *s = list;
  while (s) {
    bool type_match;
    const char *next;
    objectListNext(s, type, type_match, next);
    if (type_match)
      s = next;
    else
      return false;
  }
  return true;
}

void
set_rise_fall_short_names(const char *rise_short_name,
			  const char *fall_short_name)
{
  RiseFall::rise()->setShortName(rise_short_name);
  RiseFall::fall()->setShortName(fall_short_name);

  RiseFallBoth::rise()->setShortName(rise_short_name);
  RiseFallBoth::fall()->setShortName(fall_short_name);

  Transition::rise()->setName(rise_short_name);
  Transition::fall()->setName(fall_short_name);
}

const char *
rise_short_name()
{
  return RiseFall::rise()->shortName();
}

const char *
fall_short_name()
{
  return RiseFall::fall()->shortName();
}

bool
pin_is_constrained(Pin *pin)
{
  return Sta::sta()->sdc()->isConstrained(pin);
}

bool
instance_is_constrained(Instance *inst)
{
  return Sta::sta()->sdc()->isConstrained(inst);
}

bool
net_is_constrained(Net *net)
{
  return Sta::sta()->sdc()->isConstrained(net);
}

bool
clk_thru_tristate_enabled()
{
  return Sta::sta()->clkThruTristateEnabled();
}

void
set_clk_thru_tristate_enabled(bool enabled)
{
  Sta::sta()->setClkThruTristateEnabled(enabled);
}

bool
network_is_linked()
{
  return Sta::sta()->cmdNetwork()->isLinked();
}

void
set_path_divider(char divider)
{
  cmdNetwork()->setPathDivider(divider);
}

void
set_current_instance(Instance *inst)
{
  Sta::sta()->setCurrentInstance(inst);
}

bool
read_liberty_cmd(char *filename,
		 Corner *corner,
		 const MinMaxAll *min_max,
		 bool infer_latches)
{
  LibertyLibrary *lib = Sta::sta()->readLiberty(filename, corner, min_max,
						infer_latches);
  return (lib != nullptr);
}

bool
set_min_library_cmd(char *min_filename,
		    char *max_filename)
{
  return Sta::sta()->setMinLibrary(min_filename, max_filename);
}

Library *
find_library(const char *name)
{
  return cmdNetwork()->findLibrary(name);
}

LibraryIterator *
library_iterator()
{
  return cmdNetwork()->libraryIterator();
}

LibertyLibrary *
find_liberty(const char *name)
{
  return cmdNetwork()->findLiberty(name);
}

LibertyLibraryIterator *
liberty_library_iterator()
{
  return cmdNetwork()->libertyLibraryIterator();
}

LibertyCell *
find_liberty_cell(const char *name)
{
  return cmdNetwork()->findLibertyCell(name);
}

TmpCellSeq *
find_cells_matching(const char *pattern,
		    bool regexp,
		    bool nocase)
{
  Network *network = cmdNetwork();
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  TmpCellSeq *cells = new TmpCellSeq;
  LibraryIterator *lib_iter = network->libraryIterator();
  while (lib_iter->hasNext()) {
    Library *lib = lib_iter->next();
    network->findCellsMatching(lib, &matcher, cells);
  }
  delete lib_iter;
  return cells;
}

LibertyCellSeq *
find_library_buffers(LibertyLibrary *library)
{
  return library->buffers();
}

void
make_equiv_cells(LibertyLibrary *lib)
{
  LibertyLibrarySeq libs;
  libs.push_back(lib);
  Sta::sta()->makeEquivCells(&libs, nullptr);
}

LibertyCellSeq *
find_equiv_cells(LibertyCell *cell)
{
  return Sta::sta()->equivCells(cell);
}

bool
equiv_cells(LibertyCell *cell1,
	    LibertyCell *cell2)
{
  return sta::equivCells(cell1, cell2);
}

bool
equiv_cell_ports(LibertyCell *cell1,
		 LibertyCell *cell2)
{
  return equivCellPorts(cell1, cell2);
}

bool
equiv_cell_timing_arcs(LibertyCell *cell1,
		       LibertyCell *cell2)
{
  return equivCellTimingArcSets(cell1, cell2);
}

void
set_cmd_namespace_cmd(const char *namespc)
{
  if (stringEq(namespc, "sdc"))
    Sta::sta()->setCmdNamespace(CmdNamespace::sdc);
  else if (stringEq(namespc, "sta"))
    Sta::sta()->setCmdNamespace(CmdNamespace::sta);
  else
    criticalError(269, "unknown namespace");
}

bool
link_design_cmd(const char *top_cell_name)
{
  return Sta::sta()->linkDesign(top_cell_name);
}

bool
link_make_black_boxes()
{
  return Sta::sta()->linkMakeBlackBoxes();
}

void
set_link_make_black_boxes(bool make)
{
  Sta::sta()->setLinkMakeBlackBoxes(make);
}

Instance *
top_instance()
{
  return cmdLinkedNetwork()->topInstance();
}

const char *
liberty_port_direction(const LibertyPort *port)
{
  return port->direction()->name();
}
	     
const char *
port_direction(const Port *port)
{
  return cmdLinkedNetwork()->direction(port)->name();
}
	     
const char *
pin_direction(const Pin *pin)
{
  return cmdLinkedNetwork()->direction(pin)->name();
}

TmpPortSeq *
find_ports_matching(const char *pattern,
		    bool regexp,
		    bool nocase)
{
  Network *network = cmdLinkedNetwork();
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  Cell *top_cell = network->cell(network->topInstance());
  PortSeq ports1;
  network->findPortsMatching(top_cell, &matcher, &ports1);
  // Expand bus/bundle ports.
  TmpPortSeq *ports = new TmpPortSeq;
  PortSeq::Iterator port_iter(ports1);
  while (port_iter.hasNext()) {
    Port *port = port_iter.next();
    if (network->isBus(port)
	|| network->isBundle(port)) {
      PortMemberIterator *member_iter = network->memberIterator(port);
      while (member_iter->hasNext()) {
	Port *member = member_iter->next();
	ports->push_back(member);
      }
      delete member_iter;
    }
    else
      ports->push_back(port);
  }
  return ports;
}

TmpPinSeq *
find_port_pins_matching(const char *pattern,
			bool regexp,
			bool nocase)
{
  Network *network = cmdLinkedNetwork();
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  PortSeq ports;
  Instance *top_inst = network->topInstance();
  Cell *top_cell = network->cell(top_inst);
  network->findPortsMatching(top_cell, &matcher, &ports);
  TmpPinSeq *pins = new TmpPinSeq;
  PortSeq::Iterator port_iter(ports);
  while (port_iter.hasNext()) {
    Port *port = port_iter.next();
    if (network->isBus(port)
	|| network->isBundle(port)) {
      PortMemberIterator *member_iter = network->memberIterator(port);
      while (member_iter->hasNext()) {
	Port *member = member_iter->next();
	Pin *pin = network->findPin(top_inst, member);
	if (pin)
	  pins->push_back(pin);
      }
      delete member_iter;
    }
    else {
      Pin *pin = network->findPin(top_inst, port);
      if (pin)
	pins->push_back(pin);
    }
  }
  return pins;
}

Pin *
find_pin(const char *path_name)
{
  return cmdLinkedNetwork()->findPin(path_name);
}

TmpPinSeq *
find_pins_matching(const char *pattern,
		   bool regexp,
		   bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = cmdLinkedNetwork();
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  Instance *current_instance = sta->currentInstance();
  TmpPinSeq *pins = new TmpPinSeq;
  network->findPinsMatching(current_instance, &matcher, pins);
  return pins;
}

TmpPinSeq *
find_pins_hier_matching(const char *pattern,
			bool regexp,
			bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = cmdLinkedNetwork();
  Instance *current_instance = sta->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  TmpPinSeq *pins = new TmpPinSeq;
  network->findPinsHierMatching(current_instance, &matcher, pins);
  return pins;
}

Instance *
find_instance(char *path_name)
{
  return cmdLinkedNetwork()->findInstance(path_name);
}

TmpInstanceSeq *
network_leaf_instances()
{
  InstanceSeq *insts = new InstanceSeq;
  LeafInstanceIterator *iter = cmdLinkedNetwork()->leafInstanceIterator();
  while (iter->hasNext()) {
    Instance *inst = iter->next();
    insts->push_back(inst);
  }
  delete iter;
  return insts;
}

TmpInstanceSeq *
find_instances_matching(const char *pattern,
			bool regexp,
			bool nocase)
{
  Sta *sta = Sta::sta();
  Instance *current_instance = sta->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  TmpInstanceSeq *insts = new InstanceSeq;
  cmdLinkedNetwork()->findInstancesMatching(current_instance, &matcher, insts);
  return insts;
}

TmpInstanceSeq *
find_instances_hier_matching(const char *pattern,
			     bool regexp,
			     bool nocase)
{
  Sta *sta = Sta::sta();
  Network *network = cmdLinkedNetwork();
  Instance *current_instance = sta->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  TmpInstanceSeq *insts = new InstanceSeq;
  network->findInstancesHierMatching(current_instance, &matcher, insts);
  return insts;
}

TmpInstanceSet *
find_register_instances(ClockSet *clks,
			const RiseFallBoth *clk_tr,
			bool edge_triggered,
			bool latches)
{
  cmdLinkedNetwork();
  InstanceSet *insts = Sta::sta()->findRegisterInstances(clks, clk_tr,
							 edge_triggered,
							 latches);
  delete clks;
  return insts;
}

TmpPinSet *
find_register_data_pins(ClockSet *clks,
			const RiseFallBoth *clk_tr,
			bool edge_triggered,
			bool latches)
{
  cmdLinkedNetwork();
  PinSet *pins = Sta::sta()->findRegisterDataPins(clks, clk_tr,
						  edge_triggered, latches);
  delete clks;
  return pins;
}

TmpPinSet *
find_register_clk_pins(ClockSet *clks,
		       const RiseFallBoth *clk_tr,
		       bool edge_triggered,
		       bool latches)
{
  cmdLinkedNetwork();
  PinSet *pins = Sta::sta()->findRegisterClkPins(clks, clk_tr,
						 edge_triggered, latches);
  delete clks;
  return pins;
}

TmpPinSet *
find_register_async_pins(ClockSet *clks,
			 const RiseFallBoth *clk_tr,
			 bool edge_triggered,
			 bool latches)
{
  cmdLinkedNetwork();
  PinSet *pins = Sta::sta()->findRegisterAsyncPins(clks, clk_tr,
						   edge_triggered, latches);
  delete clks;
  return pins;
}

TmpPinSet *
find_register_output_pins(ClockSet *clks,
			  const RiseFallBoth *clk_tr,
			  bool edge_triggered,
			  bool latches)
{
  cmdLinkedNetwork();
  PinSet *pins = Sta::sta()->findRegisterOutputPins(clks, clk_tr,
						    edge_triggered, latches);
  delete clks;
  return pins;
}

Net *
find_net(char *path_name)
{
  return cmdLinkedNetwork()->findNet(path_name);
}

NetSeq *
find_nets_matching(const char *pattern,
		   bool regexp,
		   bool nocase)
{
  Network *network = cmdLinkedNetwork();
  Instance *current_instance = Sta::sta()->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  NetSeq *nets = new NetSeq;
  network->findNetsMatching(current_instance, &matcher, nets);
  return nets;
}

NetSeq *
find_nets_hier_matching(const char *pattern,
			bool regexp,
			bool nocase)
{
  Network *network = cmdLinkedNetwork();
  Instance *current_instance = Sta::sta()->currentInstance();
  PatternMatch matcher(pattern, regexp, nocase, Sta::sta()->tclInterp());
  NetSeq *nets = new NetSeq;
  network->findNetsHierMatching(current_instance, &matcher, nets);
  return nets;
}

TmpPortSeq *
filter_ports(const char *property,
	     const char *op,
	     const char *pattern,
	     PortSeq *ports)
{
  Sta *sta = Sta::sta();
  TmpPortSeq *filtered_ports = new TmpPortSeq;
  PortSeq::Iterator port_iter(ports);
  bool exact_match = stringEq(op, "==");
  while (port_iter.hasNext()) {
    Port *port = port_iter.next();
    PropertyValue value(getProperty(port, property, sta));
    const char *prop = value.stringValue();
    if (prop &&
	((exact_match && stringEq(prop, pattern))
	 || (!exact_match && patternMatch(pattern, prop))))
      filtered_ports->push_back(port);
  }
  delete ports;
  return filtered_ports;
}

TmpInstanceSeq *
filter_insts(const char *property,
	     const char *op,
	     const char *pattern,
	     InstanceSeq *insts)
{
  Sta *sta = Sta::sta();
  cmdLinkedNetwork();
  TmpInstanceSeq *filtered_insts = new TmpInstanceSeq;
  TmpInstanceSeq::Iterator inst_iter(insts);
  bool exact_match = stringEq(op, "==");
  while (inst_iter.hasNext()) {
    Instance *inst = inst_iter.next();
    PropertyValue value(getProperty(inst, property, sta));
    const char *prop = value.stringValue();
    if (prop &&
	((exact_match && stringEq(prop, pattern))
	 || (!exact_match && patternMatch(pattern, prop))))
      filtered_insts->push_back(inst);
  }
  delete insts;
  return filtered_insts;
}

PinSeq *
filter_pins(const char *property,
	    const char *op,
	    const char *pattern,
	    PinSeq *pins)
{
  Sta *sta = Sta::sta();
  PinSeq *filtered_pins = new PinSeq;
  PinSeq::Iterator pin_iter(pins);
  bool exact_match = stringEq(op, "==");
  while (pin_iter.hasNext()) {
    Pin *pin = pin_iter.next();
    PropertyValue value(getProperty(pin, property, sta));
    const char *prop = value.stringValue();
    if (prop &&
	((exact_match && stringEq(prop, pattern))
	 || (!exact_match && patternMatch(pattern, prop))))
      filtered_pins->push_back(pin);
  }
  delete pins;
  return filtered_pins;
}

PropertyValue
pin_property(const Pin *pin,
	     const char *property)
{
  cmdLinkedNetwork();
  return getProperty(pin, property, Sta::sta());
}

PropertyValue
instance_property(const Instance *inst,
		  const char *property)
{
  cmdLinkedNetwork();
  return getProperty(inst, property, Sta::sta());
}

PropertyValue
net_property(const Net *net,
	     const char *property)
{
  cmdLinkedNetwork();
  return getProperty(net, property, Sta::sta());
}

PropertyValue
port_property(const Port *port,
	      const char *property)
{
  return getProperty(port, property, Sta::sta());
}


PropertyValue
liberty_cell_property(const LibertyCell *cell,
		      const char *property)
{
  return getProperty(cell, property, Sta::sta());
}

PropertyValue
cell_property(const Cell *cell,
	      const char *property)
{
  return getProperty(cell, property, Sta::sta());
}

PropertyValue
liberty_port_property(const LibertyPort *port,
		      const char *property)
{
  return getProperty(port, property, Sta::sta());
}

PropertyValue
library_property(const Library *lib,
		 const char *property)
{
  return getProperty(lib, property, Sta::sta());
}

PropertyValue
liberty_library_property(const LibertyLibrary *lib,
			 const char *property)
{
  return getProperty(lib, property, Sta::sta());
}

PropertyValue
edge_property(Edge *edge,
	      const char *property)
{
  cmdGraph();
  return getProperty(edge, property, Sta::sta());
}

PropertyValue
clock_property(Clock *clk,
	       const char *property)
{
  cmdLinkedNetwork();
  return getProperty(clk, property, Sta::sta());
}

PropertyValue
path_end_property(PathEnd *end,
		  const char *property)
{
  cmdLinkedNetwork();
  return getProperty(end, property, Sta::sta());
}

PropertyValue
path_ref_property(PathRef *path,
		  const char *property)
{
  cmdLinkedNetwork();
  return getProperty(path, property, Sta::sta());
}

PropertyValue
timing_arc_set_property(TimingArcSet *arc_set,
			const char *property)
{
  cmdLinkedNetwork();
  return getProperty(arc_set, property, Sta::sta());
}

LeafInstanceIterator *
leaf_instance_iterator()
{
  return cmdLinkedNetwork()->leafInstanceIterator();
}

////////////////////////////////////////////////////////////////

void
define_corners_cmd(StringSet *corner_names)
{
  Sta *sta = Sta::sta();
  sta->makeCorners(corner_names);
  delete corner_names;
}

Corner *
cmd_corner()
{
  return Sta::sta()->cmdCorner();
}

void
set_cmd_corner(Corner *corner)
{
  Sta::sta()->setCmdCorner(corner);
}

Corner *
find_corner(const char *corner_name)
{
  return Sta::sta()->findCorner(corner_name);
}

Corners *
corners()
{
  return Sta::sta()->corners();
}

bool
multi_corner()
{
  return Sta::sta()->multiCorner();
}

////////////////////////////////////////////////////////////////

void
set_analysis_type_cmd(const char *analysis_type)
{
  AnalysisType type;
  if (stringEq(analysis_type, "single"))
    type = AnalysisType::single;
  else if (stringEq(analysis_type, "bc_wc"))
    type = AnalysisType::bc_wc;
  else if (stringEq(analysis_type, "on_chip_variation"))
    type = AnalysisType::ocv;
  else {
    criticalError(270, "unknown analysis type");
    type = AnalysisType::single;
  }
  Sta::sta()->setAnalysisType(type);
}

OperatingConditions *
operating_conditions(const MinMax *min_max)
{
  return Sta::sta()->operatingConditions(min_max);
}

void
set_operating_conditions_cmd(OperatingConditions *op_cond,
			     const MinMaxAll *min_max)
{
  Sta::sta()->setOperatingConditions(op_cond, min_max);
}

EdgeSeq *
filter_timing_arcs(const char *property,
		   const char *op,
		   const char *pattern,
		   EdgeSeq *edges)
{
  Sta *sta = Sta::sta();
  EdgeSeq *filtered_edges = new EdgeSeq;
  EdgeSeq::Iterator edge_iter(edges);
  bool exact_match = stringEq(op, "==");
  while (edge_iter.hasNext()) {
    Edge *edge = edge_iter.next();
    PropertyValue value(getProperty(edge, property, sta));
    const char *prop = value.stringValue();
    if (prop &&
	((exact_match && stringEq(prop, pattern))
	 || (!exact_match && patternMatch(pattern, prop))))
      filtered_edges->push_back(edge);
  }
  delete edges;
  return filtered_edges;
}

const char *
operating_condition_analysis_type()
{
  switch (Sta::sta()->sdc()->analysisType()){
  case AnalysisType::single:
    return "single";
  case AnalysisType::bc_wc:
    return "bc_wc";
  case AnalysisType::ocv:
    return "on_chip_variation";
  }
  // Prevent warnings from lame compilers.
  return "?";
}

void
set_instance_pvt(Instance *inst,
		 const MinMaxAll *min_max,
		 float process,
		 float voltage,
		 float temperature)
{
  cmdLinkedNetwork();
  Pvt *pvt = new Pvt(process, voltage, temperature);
  Sta::sta()->setPvt(inst, min_max, pvt);
}

float
port_ext_pin_cap(Port *port,
		 const MinMax *min_max)
{
  cmdLinkedNetwork();
  float pin_cap, wire_cap;
  int fanout;
  Sta::sta()->portExtCaps(port, min_max, pin_cap, wire_cap, fanout);
  return pin_cap;
}

void
set_port_pin_cap(Port *port,
		 const RiseFallBoth *rf,
		 const MinMaxAll *min_max,
		 float cap)
{
  Sta::sta()->setPortExtPinCap(port, rf, min_max, cap);
}

float
port_ext_wire_cap(Port *port,
                  const MinMax *min_max)
{
  cmdLinkedNetwork();
  float pin_cap, wire_cap;
  int fanout;
  Sta::sta()->portExtCaps(port, min_max, pin_cap, wire_cap, fanout);
  return wire_cap;
}

void
set_port_wire_cap(Port *port,
		  bool subtract_pin_cap,
		  const RiseFallBoth *rf,
		  const MinMaxAll *min_max,
		  float cap)
{
  Sta::sta()->setPortExtWireCap(port, subtract_pin_cap, rf, min_max, cap);
}

void
set_port_ext_fanout_cmd(Port *port,
			int fanout,
			const MinMaxAll *min_max)
{
  Sta::sta()->setPortExtFanout(port, fanout, min_max);
}

float
port_ext_fanout(Port *port,
                const MinMax *min_max)
{
  cmdLinkedNetwork();
  float pin_cap, wire_cap;
  int fanout;
  Sta::sta()->portExtCaps(port, min_max, pin_cap, wire_cap, fanout);
  return fanout;
}

void
set_net_wire_cap(Net *net,
		 bool subtract_pin_cap,
		 Corner *corner,
		 const MinMaxAll *min_max,
		 float cap)
{
  Sta::sta()->setNetWireCap(net, subtract_pin_cap, corner, min_max, cap);
}

void
set_wire_load_mode_cmd(const char *mode_name)
{
  WireloadMode mode = stringWireloadMode(mode_name);
  if (mode == WireloadMode::unknown)
    criticalError(271, "unknown wire load mode");
  else
    Sta::sta()->setWireloadMode(mode);
}

void
set_net_resistance(Net *net,
		   const MinMaxAll *min_max,
		   float res)
{
  Sta::sta()->setResistance(net, min_max, res);
}

void
set_wire_load_cmd(Wireload *wireload,
		  const MinMaxAll *min_max)
{
  Sta::sta()->setWireload(wireload, min_max);
}

void
set_wire_load_selection_group_cmd(WireloadSelection *selection,
				  const MinMaxAll *min_max)
{
  Sta::sta()->setWireloadSelection(selection, min_max);
}

void
make_clock(const char *name,
	   PinSet *pins,
	   bool add_to_pins,
	   float period,
	   FloatSeq *waveform,
	   char *comment)
{
  cmdLinkedNetwork();
  Sta::sta()->makeClock(name, pins, add_to_pins, period, waveform, comment);
}

void
make_generated_clock(const char *name,
		     PinSet *pins,
		     bool add_to_pins,
		     Pin *src_pin,
		     Clock *master_clk,
		     Pin *pll_out,
		     Pin *pll_fdbk,
		     int divide_by,
		     int multiply_by,
		     float duty_cycle,
		     bool invert,
		     bool combinational,
		     IntSeq *edges,
		     FloatSeq *edge_shifts,
		     char *comment)
{
  cmdLinkedNetwork();
  Sta::sta()->makeGeneratedClock(name, pins, add_to_pins,
				 src_pin, master_clk, pll_out, pll_fdbk,
				 divide_by, multiply_by, duty_cycle, invert,
				 combinational, edges, edge_shifts,
				 comment);
}

void
remove_clock_cmd(Clock *clk)
{
  cmdLinkedNetwork();
  Sta::sta()->removeClock(clk);
}

void
set_propagated_clock_cmd(Clock *clk)
{
  cmdLinkedNetwork();
  Sta::sta()->setPropagatedClock(clk);
}

void
set_propagated_clock_pin_cmd(Pin *pin)
{
  cmdLinkedNetwork();
  Sta::sta()->setPropagatedClock(pin);
}

void
unset_propagated_clock_cmd(Clock *clk)
{
  cmdLinkedNetwork();
  Sta::sta()->removePropagatedClock(clk);
}

void
unset_propagated_clock_pin_cmd(Pin *pin)
{
  cmdLinkedNetwork();
  Sta::sta()->removePropagatedClock(pin);
}

void
set_clock_slew_cmd(Clock *clk,
		   const RiseFallBoth *rf,
		   const MinMaxAll *min_max,
		   float slew)
{
  cmdLinkedNetwork();
  Sta::sta()->setClockSlew(clk, rf, min_max, slew);
}

void
unset_clock_slew_cmd(Clock *clk)
{
  cmdLinkedNetwork();
  Sta::sta()->removeClockSlew(clk);
}

void
set_clock_latency_cmd(Clock *clk,
		      Pin *pin,
		      const RiseFallBoth *rf,
		      MinMaxAll *min_max, float delay)
{
  cmdLinkedNetwork();
  Sta::sta()->setClockLatency(clk, pin, rf, min_max, delay);
}

void
set_clock_insertion_cmd(Clock *clk,
			Pin *pin,
			const RiseFallBoth *rf,
			const MinMaxAll *min_max,
			const EarlyLateAll *early_late,
			float delay)
{
  cmdLinkedNetwork();
  Sta::sta()->setClockInsertion(clk, pin, rf, min_max, early_late, delay);
}

void
unset_clock_latency_cmd(Clock *clk,
			Pin *pin)
{
  cmdLinkedNetwork();
  Sta::sta()->removeClockLatency(clk, pin);
}

void
unset_clock_insertion_cmd(Clock *clk,
			  Pin *pin)
{
  cmdLinkedNetwork();
  Sta::sta()->removeClockInsertion(clk, pin);
}

void
set_clock_uncertainty_clk(Clock *clk,
			  const SetupHoldAll *setup_hold,
			  float uncertainty)
{
  cmdLinkedNetwork();
  Sta::sta()->setClockUncertainty(clk, setup_hold, uncertainty);
}

void
unset_clock_uncertainty_clk(Clock *clk,
			    const SetupHoldAll *setup_hold)
{
  cmdLinkedNetwork();
  Sta::sta()->removeClockUncertainty(clk, setup_hold);
}

void
set_clock_uncertainty_pin(Pin *pin,
			  const MinMaxAll *min_max,
			  float uncertainty)
{
  cmdLinkedNetwork();
  Sta::sta()->setClockUncertainty(pin, min_max, uncertainty);
}

void
unset_clock_uncertainty_pin(Pin *pin,
			    const MinMaxAll *min_max)
{
  cmdLinkedNetwork();
  Sta::sta()->removeClockUncertainty(pin, min_max);
}

void
set_inter_clock_uncertainty(Clock *from_clk,
			    const RiseFallBoth *from_tr,
			    Clock *to_clk,
			    const RiseFallBoth *to_tr,
			    const MinMaxAll *min_max,
			    float uncertainty)
{
  cmdLinkedNetwork();
  Sta::sta()->setClockUncertainty(from_clk, from_tr, to_clk, to_tr, min_max,
				  uncertainty);
}

void
unset_inter_clock_uncertainty(Clock *from_clk,
			      const RiseFallBoth *from_tr,
			      Clock *to_clk,
			      const RiseFallBoth *to_tr,
			      const MinMaxAll *min_max)
{
  cmdLinkedNetwork();
  Sta::sta()->removeClockUncertainty(from_clk, from_tr, to_clk, to_tr, min_max);
}

void
set_clock_gating_check_cmd(const RiseFallBoth *rf,
			   const SetupHold *setup_hold,
			   float margin)
{
  Sta::sta()->setClockGatingCheck(rf, setup_hold, margin);
}

void
set_clock_gating_check_clk_cmd(Clock *clk,
			       const RiseFallBoth *rf,
			       const SetupHold *setup_hold,
			       float margin)
{
  Sta::sta()->setClockGatingCheck(clk, rf, setup_hold, margin);
}

void
set_clock_gating_check_pin_cmd(Pin *pin,
			       const RiseFallBoth *rf,
			       const SetupHold *setup_hold,
			       float margin,
			       LogicValue active_value)
{
  Sta::sta()->setClockGatingCheck(pin, rf, setup_hold, margin, active_value);
}

void
set_clock_gating_check_instance_cmd(Instance *inst,
				    const RiseFallBoth *rf,
				    const SetupHold *setup_hold,
				    float margin,
				    LogicValue active_value)
{
  Sta::sta()->setClockGatingCheck(inst, rf, setup_hold, margin, active_value);
}

void
set_data_check_cmd(Pin *from,
		   const RiseFallBoth *from_rf,
		   Pin *to,
		   const RiseFallBoth *to_rf,
		   Clock *clk,
		   const SetupHoldAll *setup_hold,
		   float margin)
{
  Sta::sta()->setDataCheck(from, from_rf, to, to_rf, clk, setup_hold, margin);
}

void
unset_data_check_cmd(Pin *from,
		     const RiseFallBoth *from_tr,
		     Pin *to,
		     const RiseFallBoth *to_tr,
		     Clock *clk,
		     const SetupHoldAll *setup_hold)
{
  Sta::sta()->removeDataCheck(from, from_tr, to, to_tr, clk, setup_hold);
}

void
set_input_delay_cmd(Pin *pin,
		    RiseFallBoth *rf,
		    Clock *clk,
		    RiseFall *clk_rf,
		    Pin *ref_pin,
		    bool source_latency_included,
		    bool network_latency_included,
		    MinMaxAll *min_max,
		    bool add,
		    float delay)
{
  cmdLinkedNetwork();
  Sta::sta()->setInputDelay(pin, rf, clk, clk_rf, ref_pin,
			    source_latency_included, network_latency_included,
			    min_max, add, delay);
}

void
unset_input_delay_cmd(Pin *pin,
		      RiseFallBoth *rf, 
		      Clock *clk,
		      RiseFall *clk_rf, 
		      MinMaxAll *min_max)
{
  cmdLinkedNetwork();
  Sta::sta()->removeInputDelay(pin, rf, clk, clk_rf, min_max);
}

void
set_output_delay_cmd(Pin *pin,
		     const RiseFallBoth *rf,
		     Clock *clk,
		     const RiseFall *clk_rf,
		     Pin *ref_pin,
		     bool source_latency_included,
		     bool network_latency_included,
		     const MinMaxAll *min_max,
		     bool add,
		     float delay)
{
  cmdLinkedNetwork();
  Sta::sta()->setOutputDelay(pin, rf, clk, clk_rf, ref_pin,
			     source_latency_included, network_latency_included,
			     min_max, add, delay);
}

void
unset_output_delay_cmd(Pin *pin,
		       RiseFallBoth *rf, 
		       Clock *clk,
		       RiseFall *clk_rf, 
		       MinMaxAll *min_max)
{
  cmdLinkedNetwork();
  Sta::sta()->removeOutputDelay(pin, rf, clk, clk_rf, min_max);
}

void
disable_cell(LibertyCell *cell,
	     LibertyPort *from,
	     LibertyPort *to)
{
  cmdLinkedNetwork();
  Sta::sta()->disable(cell, from, to);
}

void
unset_disable_cell(LibertyCell *cell,
		   LibertyPort *from,
		   LibertyPort *to)
{
  cmdLinkedNetwork();
  Sta::sta()->removeDisable(cell, from, to);
}

void
disable_lib_port(LibertyPort *port)
{
  cmdLinkedNetwork();
  Sta::sta()->disable(port);
}

void
unset_disable_lib_port(LibertyPort *port)
{
  cmdLinkedNetwork();
  Sta::sta()->removeDisable(port);
}

void
disable_port(Port *port)
{
  cmdLinkedNetwork();
  Sta::sta()->disable(port);
}

void
unset_disable_port(Port *port)
{
  cmdLinkedNetwork();
  Sta::sta()->removeDisable(port);
}

void
disable_instance(Instance *instance,
		 LibertyPort *from,
		 LibertyPort *to)
{
  cmdLinkedNetwork();
  Sta::sta()->disable(instance, from, to);
}

void
unset_disable_instance(Instance *instance,
		       LibertyPort *from,
		       LibertyPort *to)
{
  cmdLinkedNetwork();
  Sta::sta()->removeDisable(instance, from, to);
}

void
disable_pin(Pin *pin)
{
  cmdLinkedNetwork();
  Sta::sta()->disable(pin);
}

void
unset_disable_pin(Pin *pin)
{
  cmdLinkedNetwork();
  Sta::sta()->removeDisable(pin);
}

void
disable_edge(Edge *edge)
{
  cmdLinkedNetwork();
  Sta::sta()->disable(edge);
}

void
unset_disable_edge(Edge *edge)
{
  cmdLinkedNetwork();
  Sta::sta()->removeDisable(edge);
}

void
disable_timing_arc_set(TimingArcSet *arc_set)
{
  cmdLinkedNetwork();
  Sta::sta()->disable(arc_set);
}

void
unset_disable_timing_arc_set(TimingArcSet *arc_set)
{
  cmdLinkedNetwork();
  Sta::sta()->removeDisable(arc_set);
}

void
disable_clock_gating_check_inst(Instance *inst)
{
  cmdLinkedNetwork();
  Sta::sta()->disableClockGatingCheck(inst);
}

void
disable_clock_gating_check_pin(Pin *pin)
{
  cmdLinkedNetwork();
  Sta::sta()->disableClockGatingCheck(pin);
}

void
unset_disable_clock_gating_check_inst(Instance *inst)
{
  cmdLinkedNetwork();
  Sta::sta()->removeDisableClockGatingCheck(inst);
}

void
unset_disable_clock_gating_check_pin(Pin *pin)
{
  cmdLinkedNetwork();
  Sta::sta()->removeDisableClockGatingCheck(pin);
}

void
make_false_path(ExceptionFrom *from,
		ExceptionThruSeq *thrus,
		ExceptionTo *to,
		const MinMaxAll *min_max,
		const char *comment)
{
  cmdLinkedNetwork();
  Sta::sta()->makeFalsePath(from, thrus, to, min_max, comment);
}

void
make_multicycle_path(ExceptionFrom *from,
		     ExceptionThruSeq *thrus,
		     ExceptionTo *to,
		     const MinMaxAll *min_max,
		     bool use_end_clk,
		     int path_multiplier,
		     const char *comment)
{
  cmdLinkedNetwork();
  Sta::sta()->makeMulticyclePath(from, thrus, to, min_max, use_end_clk,
				 path_multiplier, comment);
}

void
make_path_delay(ExceptionFrom *from,
		ExceptionThruSeq *thrus,
		ExceptionTo *to,
		const MinMax *min_max,
		bool ignore_clk_latency,
		float delay,
		const char *comment)
{
  cmdLinkedNetwork();
  Sta::sta()->makePathDelay(from, thrus, to, min_max, 
			    ignore_clk_latency, delay, comment);
}

void
reset_path_cmd(ExceptionFrom *
	       from, ExceptionThruSeq *thrus,
	       ExceptionTo *to,
	       const MinMaxAll *min_max)
{
  cmdLinkedNetwork();
  Sta::sta()->resetPath(from, thrus, to, min_max);
  // from/to and thru are owned and deleted by the caller.
  // ExceptionThruSeq thrus arg is made by TclListSeqExceptionThru
  // in the swig converter so it is deleted here.
  delete thrus;
}

void
make_group_path(const char *name,
		bool is_default,
		ExceptionFrom *from,
		ExceptionThruSeq *thrus,
		ExceptionTo *to,
		const char *comment)
{
  cmdLinkedNetwork();
  if (name[0] == '\0')
    name = nullptr;
  Sta::sta()->makeGroupPath(name, is_default, from, thrus, to, comment);
}

bool
is_path_group_name(const char *name)
{
  cmdLinkedNetwork();
  return Sta::sta()->isGroupPathName(name);
}

ExceptionFrom *
make_exception_from(PinSet *from_pins,
		    ClockSet *from_clks,
		    InstanceSet *from_insts,
		    const RiseFallBoth *from_tr)
{
  cmdLinkedNetwork();
  return Sta::sta()->makeExceptionFrom(from_pins, from_clks, from_insts,
				       from_tr);
}

void
delete_exception_from(ExceptionFrom *from)
{
  Sta::sta()->deleteExceptionFrom(from);
}

void
check_exception_from_pins(ExceptionFrom *from,
			  const char *file,
			  int line)
{
  Sta::sta()->checkExceptionFromPins(from, file, line);
}

ExceptionThru *
make_exception_thru(PinSet *pins,
		    NetSet *nets,
		    InstanceSet *insts,
		    const RiseFallBoth *rf)
{
  cmdLinkedNetwork();
  return Sta::sta()->makeExceptionThru(pins, nets, insts, rf);
}

void
delete_exception_thru(ExceptionThru *thru)
{
  Sta::sta()->deleteExceptionThru(thru);
}

ExceptionTo *
make_exception_to(PinSet *to_pins,
		  ClockSet *to_clks,
		  InstanceSet *to_insts,
		  const RiseFallBoth *rf,
 		  RiseFallBoth *end_rf)
{
  cmdLinkedNetwork();
  return Sta::sta()->makeExceptionTo(to_pins, to_clks, to_insts, rf, end_rf);
}

void
delete_exception_to(ExceptionTo *to)
{
  Sta::sta()->deleteExceptionTo(to);
}

void
check_exception_to_pins(ExceptionTo *to,
			const char *file,
			int line)
{
  Sta::sta()->checkExceptionToPins(to, file, line);
}

void
set_input_slew_cmd(Port *port,
		   const RiseFallBoth *rf,
		   const MinMaxAll *min_max,
		   float slew)
{
  cmdLinkedNetwork();
  Sta::sta()->setInputSlew(port, rf, min_max, slew);
}

void
set_drive_cell_cmd(LibertyLibrary *library,
		   LibertyCell *cell,
		   Port *port,
		   LibertyPort *from_port,
		   float from_slew_rise,
		   float from_slew_fall,
		   LibertyPort *to_port,
		   const RiseFallBoth *rf,
		   const MinMaxAll *min_max)
{
  float from_slews[RiseFall::index_count];
  from_slews[RiseFall::riseIndex()] = from_slew_rise;
  from_slews[RiseFall::fallIndex()] = from_slew_fall;
  Sta::sta()->setDriveCell(library, cell, port, from_port, from_slews,
			   to_port, rf, min_max);
}

void
set_drive_resistance_cmd(Port *port,
			 const RiseFallBoth *rf,
			 const MinMaxAll *min_max,
			 float res)
{
  cmdLinkedNetwork();
  Sta::sta()->setDriveResistance(port, rf, min_max, res);
}

void
set_slew_limit_clk(Clock *clk,
		   const RiseFallBoth *rf,
		   PathClkOrData clk_data,
		   const MinMax *min_max,
		   float slew)
{
  cmdLinkedNetwork();
  Sta::sta()->setSlewLimit(clk, rf, clk_data, min_max, slew);
}

void
set_slew_limit_port(Port *port,
		    const MinMax *min_max,
		    float slew)
{
  cmdLinkedNetwork();
  Sta::sta()->setSlewLimit(port, min_max, slew);
}

void
set_slew_limit_cell(Cell *cell,
		    const MinMax *min_max,
		    float slew)
{
  cmdLinkedNetwork();
  Sta::sta()->setSlewLimit(cell, min_max, slew);
}

void
set_port_capacitance_limit(Port *port,
			   const MinMax *min_max,
			   float cap)
{
  Sta::sta()->setCapacitanceLimit(port, min_max, cap);
}

void
set_pin_capacitance_limit(Pin *pin,
			  const MinMax *min_max,
			  float cap)
{
  Sta::sta()->setCapacitanceLimit(pin, min_max, cap);
}

void
set_cell_capacitance_limit(Cell *cell,
			   const MinMax *min_max,
			   float cap)
{
  Sta::sta()->setCapacitanceLimit(cell, min_max, cap);
}

void
set_latch_borrow_limit_pin(Pin *pin,
			   float limit)
{
  Sta::sta()->setLatchBorrowLimit(pin, limit);
}

void
set_latch_borrow_limit_inst(Instance *inst,
			    float limit)
{
  Sta::sta()->setLatchBorrowLimit(inst, limit);
}

void
set_latch_borrow_limit_clk(Clock *clk, float limit)
{
  Sta::sta()->setLatchBorrowLimit(clk, limit);
}

void
set_min_pulse_width_global(const RiseFallBoth *rf,
			   float min_width)
{
  Sta::sta()->setMinPulseWidth(rf, min_width);
}

void
set_min_pulse_width_pin(Pin *pin,
			const RiseFallBoth *rf,
			float min_width)
{
  Sta::sta()->setMinPulseWidth(pin, rf, min_width);
}

void
set_min_pulse_width_clk(Clock *clk,
			const RiseFallBoth *rf,
			float min_width)
{
  Sta::sta()->setMinPulseWidth(clk, rf, min_width);
}

void
set_min_pulse_width_inst(Instance *inst,
			 const RiseFallBoth *rf,
			 float min_width)
{
  Sta::sta()->setMinPulseWidth(inst, rf, min_width);
}

void
set_max_area_cmd(float area)
{
  Sta::sta()->setMaxArea(area);
}

void
set_port_fanout_limit(Port *port,
		      const MinMax *min_max,
		      float fanout)
{
  Sta::sta()->setFanoutLimit(port, min_max, fanout);
}

void
set_cell_fanout_limit(Cell *cell,
		      const MinMax *min_max,
		      float fanout)
{
  Sta::sta()->setFanoutLimit(cell, min_max, fanout);
}

void
set_logic_value_cmd(Pin *pin,
		    LogicValue value)
{
  Sta::sta()->setLogicValue(pin, value);
}

void
set_case_analysis_cmd(Pin *pin,
		      LogicValue value)
{
  Sta::sta()->setCaseAnalysis(pin, value);
}

void
unset_case_analysis_cmd(Pin *pin)
{
  Sta::sta()->removeCaseAnalysis(pin);
}

void
set_timing_derate_cmd(TimingDerateType type,
		      PathClkOrData clk_data,
		      const RiseFallBoth *rf,
		      const EarlyLate *early_late,
		      float derate)
{
  Sta::sta()->setTimingDerate(type, clk_data, rf, early_late, derate);
}

void
set_timing_derate_net_cmd(const Net *net,
			  PathClkOrData clk_data,
			  const RiseFallBoth *rf,
			  const EarlyLate *early_late,
			  float derate)
{
  Sta::sta()->setTimingDerate(net, clk_data, rf, early_late, derate);
}

void
set_timing_derate_inst_cmd(const Instance *inst,
			   TimingDerateCellType type,
			   PathClkOrData clk_data,
			   const RiseFallBoth *rf,
			   const EarlyLate *early_late,
			   float derate)
{
  Sta::sta()->setTimingDerate(inst, type, clk_data, rf, early_late, derate);
}

void
set_timing_derate_cell_cmd(const LibertyCell *cell,
			   TimingDerateCellType type,
			   PathClkOrData clk_data,
			   const RiseFallBoth *rf,
			   const EarlyLate *early_late,
			   float derate)
{
  Sta::sta()->setTimingDerate(cell, type, clk_data, rf, early_late, derate);
}

void
unset_timing_derate_cmd()
{
  Sta::sta()->unsetTimingDerate();
}

ClockIterator *
clock_iterator()
{
  return new ClockIterator(Sta::sta()->sdc());
}

Clock *
find_clock(const char *name)
{
  cmdLinkedNetwork();
  return Sta::sta()->sdc()->findClock(name);
}

bool
is_clock_src(const Pin *pin)
{
  return Sta::sta()->isClockSrc(pin);
}

Clock *
default_arrival_clock()
{
  return Sta::sta()->sdc()->defaultArrivalClock();
}

ClockSeq *
find_clocks_matching(const char *pattern,
		     bool regexp,
		     bool nocase)
{
  cmdLinkedNetwork();
  ClockSeq *clks = new ClockSeq;
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  PatternMatch matcher(pattern, regexp, nocase, sta->tclInterp());
  sdc->findClocksMatching(&matcher, clks);
  return clks;
}

void
update_generated_clks()
{
  cmdLinkedNetwork();
  Sta::sta()->updateGeneratedClks();
}

bool
is_clock(Pin *pin)
{
  Sta *sta = Sta::sta();
  return sta->isClock(pin);
}

bool
is_ideal_clock(Pin *pin)
{
  Sta *sta = Sta::sta();
  return sta->isIdealClock(pin);
}

bool
is_clock_search(const Pin *pin)
{
  Sta *sta = Sta::sta();
  Graph *graph = sta->graph();
  Search *search = sta->search();
  Vertex *vertex, *bidirect_drvr_vertex;
  graph->pinVertices(pin, vertex, bidirect_drvr_vertex);
  return search->isClock(vertex);
}

bool
is_genclk_src(const Pin *pin)
{
  Sta *sta = Sta::sta();
  Graph *graph = sta->graph();
  Search *search = sta->search();
  Vertex *vertex, *bidirect_drvr_vertex;
  graph->pinVertices(pin, vertex, bidirect_drvr_vertex);
  return search->isGenClkSrc(vertex);
}

// format_unit functions print with fixed digits and suffix.
// Pass value arg as string to support NaNs.
const char *
format_time(const char *value,
	    int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->timeUnit()->asString(value1, digits);
}

const char *
format_capacitance(const char *value,
		   int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->capacitanceUnit()->asString(value1, digits);
}

const char *
format_resistance(const char *value,
		  int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->resistanceUnit()->asString(value1, digits);
}

const char *
format_voltage(const char *value,
	       int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->voltageUnit()->asString(value1, digits);
}

const char *
format_power(const char *value,
	     int digits)
{
  float value1 = strtof(value, nullptr);
  return Sta::sta()->units()->powerUnit()->asString(value1, digits);
}

const char *
format_distance(const char *value,
		int digits)
{
  float value1 = strtof(value, nullptr);
  Unit *dist_unit = Sta::sta()->units()->distanceUnit();
  return dist_unit->asString(value1, digits);
}

const char *
format_area(const char *value,
	    int digits)
{
  float value1 = strtof(value, nullptr);
  Unit *dist_unit = Sta::sta()->units()->distanceUnit();
  return dist_unit->asString(value1 / dist_unit->scale(), digits);
}

////////////////////////////////////////////////////////////////

// Unit converstion from sta unit to user interface and visa versa.
double
time_ui_sta(double value)
{
  return value * Sta::sta()->units()->timeUnit()->scale();
}

double
time_sta_ui(double value)
{
  return value / Sta::sta()->units()->timeUnit()->scale();
}

double
capacitance_ui_sta(double value)
{
  return value * Sta::sta()->units()->capacitanceUnit()->scale();
}

double
capacitance_sta_ui(double value)
{
  return value / Sta::sta()->units()->capacitanceUnit()->scale();
}

double
resistance_ui_sta(double value)
{
  return value * Sta::sta()->units()->resistanceUnit()->scale();
}

double
resistance_sta_ui(double value)
{
  return value / Sta::sta()->units()->resistanceUnit()->scale();
}

double
voltage_ui_sta(double value)
{
  return value * Sta::sta()->units()->voltageUnit()->scale();
}

double
voltage_sta_ui(double value)
{
  return value / Sta::sta()->units()->voltageUnit()->scale();
}

double
current_ui_sta(double value)
{
  return value * Sta::sta()->units()->currentUnit()->scale();
}

double
current_sta_ui(double value)
{
  return value / Sta::sta()->units()->currentUnit()->scale();
}

double
power_ui_sta(double value)
{
  return value * Sta::sta()->units()->powerUnit()->scale();
}

double
power_sta_ui(double value)
{
  return value / Sta::sta()->units()->powerUnit()->scale();
}

double
distance_ui_sta(double value)
{
  return value * Sta::sta()->units()->distanceUnit()->scale();
}

double
distance_sta_ui(double value)
{
  return value / Sta::sta()->units()->distanceUnit()->scale();
}

double
area_ui_sta(double value)
{
  double scale = Sta::sta()->units()->distanceUnit()->scale();
  return value * scale * scale;
}

double
area_sta_ui(double value)
{
  double scale = Sta::sta()->units()->distanceUnit()->scale();
  return value / (scale * scale);
}

////////////////////////////////////////////////////////////////

void
set_cmd_unit_scale(const char *unit_name,
		   float scale)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    unit->setScale(scale);
}

void
set_cmd_unit_digits(const char *unit_name,
		    int digits)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    unit->setDigits(digits);
}

void
set_cmd_unit_suffix(const char *unit_name,
		    const char *suffix)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit) {
    unit->setSuffix(suffix);
  }
}

const char *
unit_scale_abreviation(const char *unit_name)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    return unit->scaleAbreviation();
  else
    return "";
}

const char *
unit_suffix(const char *unit_name)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    return unit->suffix();
  else
    return "";
}

////////////////////////////////////////////////////////////////

VertexIterator *
vertex_iterator()
{
  return new VertexIterator(cmdGraph());
}

void
set_arc_delay(Edge *edge,
	      TimingArc *arc,
	      const Corner *corner,
	      const MinMaxAll *min_max,
	      float delay)
{
  cmdGraph();
  Sta::sta()->setArcDelay(edge, arc, corner, min_max, delay);
}

void
set_annotated_slew(Vertex *vertex,
		   const Corner *corner,
		   const MinMaxAll *min_max,
		   const RiseFallBoth *rf,
		   float slew)
{
  cmdGraph();
  Sta::sta()->setAnnotatedSlew(vertex, corner, min_max, rf, slew);
}

// Remove all delay and slew annotations.
void
remove_delay_slew_annotations()
{
  cmdGraph();
  Sta::sta()->removeDelaySlewAnnotations();
}

CheckErrorSeq &
check_timing_cmd(bool no_input_delay,
		 bool no_output_delay,
		 bool reg_multiple_clks,
		 bool reg_no_clks,
		 bool unconstrained_endpoints,
		 bool loops,
		 bool generated_clks)
{
  cmdLinkedNetwork();
  return Sta::sta()->checkTiming(no_input_delay, no_output_delay,
				 reg_multiple_clks, reg_no_clks,
				 unconstrained_endpoints,
				 loops, generated_clks);
}

bool
crpr_enabled()
{
  return Sta::sta()->crprEnabled();
}

void
set_crpr_enabled(bool enabled)
{
  return Sta::sta()->setCrprEnabled(enabled);
}

const char *
crpr_mode()
{
  switch (Sta::sta()->crprMode()) {
  case CrprMode::same_transition:
    return "same_transition";
  case CrprMode::same_pin:
    return "same_pin";
  default:
    return "";
  }
}

void
set_crpr_mode(const char *mode)
{
  Sta *sta = Sta::sta();
  if (stringEq(mode, "same_pin"))
    Sta::sta()->setCrprMode(CrprMode::same_pin);
  else if (stringEq(mode, "same_transition"))
    Sta::sta()->setCrprMode(CrprMode::same_transition);
  else
    sta->report()->critical(272, "unknown common clk pessimism mode.");
}

bool
pocv_enabled()
{
  return Sta::sta()->pocvEnabled();
}

void
set_pocv_enabled(bool enabled)
{
#if !SSTA
  if (enabled)
    Sta::sta()->report()->error(204, "POCV support requires compilation with SSTA=1.");
#endif
  return Sta::sta()->setPocvEnabled(enabled);
}

float
pocv_sigma_factor()
{
  return Sta::sta()->sigmaFactor();
}

void
set_pocv_sigma_factor(float factor)
{
  Sta::sta()->setSigmaFactor(factor);
}

bool
propagate_gated_clock_enable()
{
  return Sta::sta()->propagateGatedClockEnable();
}

void
set_propagate_gated_clock_enable(bool enable)
{
  Sta::sta()->setPropagateGatedClockEnable(enable);
}

bool
preset_clr_arcs_enabled()
{
  return Sta::sta()->presetClrArcsEnabled();
}

void
set_preset_clr_arcs_enabled(bool enable)
{
  Sta::sta()->setPresetClrArcsEnabled(enable);
}

bool
cond_default_arcs_enabled()
{
  return Sta::sta()->condDefaultArcsEnabled();
}

void
set_cond_default_arcs_enabled(bool enabled)
{
  Sta::sta()->setCondDefaultArcsEnabled(enabled);
}

bool
bidirect_inst_paths_enabled()
{
  return Sta::sta()->bidirectInstPathsEnabled();
}

void
set_bidirect_inst_paths_enabled(bool enabled)
{
  Sta::sta()->setBidirectInstPathsEnabled(enabled);
}

bool
bidirect_net_paths_enabled()
{
  return Sta::sta()->bidirectNetPathsEnabled();
}

void
set_bidirect_net_paths_enabled(bool enabled)
{
  Sta::sta()->setBidirectNetPathsEnabled(enabled);
}

bool
recovery_removal_checks_enabled()
{
  return Sta::sta()->recoveryRemovalChecksEnabled();
}

void
set_recovery_removal_checks_enabled(bool enabled)
{
  Sta::sta()->setRecoveryRemovalChecksEnabled(enabled);
}

bool
gated_clk_checks_enabled()
{
  return Sta::sta()->gatedClkChecksEnabled();
}

void
set_gated_clk_checks_enabled(bool enabled)
{
  Sta::sta()->setGatedClkChecksEnabled(enabled);
}

bool
dynamic_loop_breaking()
{
  return Sta::sta()->dynamicLoopBreaking();
}

void
set_dynamic_loop_breaking(bool enable)
{
  Sta::sta()->setDynamicLoopBreaking(enable);
}

bool
use_default_arrival_clock()
{
  return Sta::sta()->useDefaultArrivalClock();
}

void
set_use_default_arrival_clock(bool enable)
{
  return Sta::sta()->setUseDefaultArrivalClock(enable);
}

bool
propagate_all_clocks()
{
  return Sta::sta()->propagateAllClocks();
}

void
set_propagate_all_clocks(bool prop)
{
  Sta::sta()->setPropagateAllClocks(prop);
}

////////////////////////////////////////////////////////////////

PathEndSeq *
find_path_ends(ExceptionFrom *from,
	       ExceptionThruSeq *thrus,
	       ExceptionTo *to,
	       bool unconstrained,
	       Corner *corner,
	       const MinMaxAll *delay_min_max,
	       int group_count,
	       int endpoint_count,
	       bool unique_pins,
	       float slack_min,
	       float slack_max,
	       bool sort_by_slack,
	       PathGroupNameSet *groups,
	       bool setup,
	       bool hold,
	       bool recovery,
	       bool removal,
	       bool clk_gating_setup,
	       bool clk_gating_hold)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  PathEndSeq *ends = sta->findPathEnds(from, thrus, to, unconstrained,
				       corner, delay_min_max,
				       group_count, endpoint_count, unique_pins,
				       slack_min, slack_max,
				       sort_by_slack,
				       groups->size() ? groups : nullptr,
				       setup, hold,
				       recovery, removal,
				       clk_gating_setup, clk_gating_hold);
  delete groups;
  return ends;
}

void
report_path_end_header()
{
  Sta::sta()->reportPathEndHeader();
}

void
report_path_end_footer()
{
  Sta::sta()->reportPathEndFooter();
}

void
report_path_end(PathEnd *end)
{
  Sta::sta()->reportPathEnd(end);
}

void
report_path_end2(PathEnd *end,
		 PathEnd *prev_end)
{
  Sta::sta()->reportPathEnd(end, prev_end);
}

void
set_report_path_format(ReportPathFormat format)
{
  Sta::sta()->setReportPathFormat(format);
}
    
void
set_report_path_field_order(StringSeq *field_names)
{
  Sta::sta()->setReportPathFieldOrder(field_names);
  delete field_names;
}

void
set_report_path_fields(bool report_input_pin,
		       bool report_net,
		       bool report_cap,
		       bool report_slew)
{
  Sta::sta()->setReportPathFields(report_input_pin,
				  report_net,
				  report_cap,
				  report_slew);
}

void
set_report_path_field_properties(const char *field_name,
				 const char *title,
				 int width,
				 bool left_justify)
{
  Sta *sta = Sta::sta();
  ReportField *field = sta->findReportPathField(field_name);
  if (field)
    field->setProperties(title, width, left_justify);
  else
    sta->report()->error(607, "unknown report path field %s", field_name);
}

void
set_report_path_field_width(const char *field_name,
			    int width)
{
  Sta *sta = Sta::sta();
  ReportField *field = sta->findReportPathField(field_name);
  if (field)
    field->setWidth(width);
  else
    sta->report()->error(608, "unknown report path field %s", field_name);
}

void
set_report_path_digits(int digits)
{
  Sta::sta()->setReportPathDigits(digits);
}

void
set_report_path_no_split(bool no_split)
{
  Sta::sta()->setReportPathNoSplit(no_split);
}

void
set_report_path_sigmas(bool report_sigmas)
{
  Sta::sta()->setReportPathSigmas(report_sigmas);
}

void
delete_path_ref(PathRef *path)
{
  delete path;
}

void
remove_constraints()
{
  Sta::sta()->removeConstraints();
}

void
report_path_cmd(PathRef *path)
{
  Sta::sta()->reportPath(path);
}

void
report_clk_skew(ClockSet *clks,
		const Corner *corner,
		const SetupHold *setup_hold,
		int digits)
{
  cmdLinkedNetwork();
  Sta::sta()->reportClkSkew(clks, corner, setup_hold, digits);
  delete clks;
}

float
worst_clk_skew_cmd(const SetupHold *setup_hold)
{
  cmdLinkedNetwork();
  return Sta::sta()->findWorstClkSkew(setup_hold);
}

TmpPinSet *
startpoints()
{
  return findStartpoints();
}

TmpPinSet *
endpoints()
{
  return findEndpoints();
}

TmpPinSet *
group_path_pins(const char *group_path_name)
{
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  if (sdc->isGroupPathName(group_path_name))
    return sta->findGroupPathPins(group_path_name);
  else
    return nullptr;
}

////////////////////////////////////////////////////////////////

MinPulseWidthCheckSeq &
min_pulse_width_violations(const Corner *corner)
{
  cmdLinkedNetwork();
  return Sta::sta()->minPulseWidthViolations(corner);
}

MinPulseWidthCheckSeq &
min_pulse_width_check_pins(PinSeq *pins,
			   const Corner *corner)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  MinPulseWidthCheckSeq &checks = sta->minPulseWidthChecks(pins, corner);
  delete pins;
  return checks;
}

MinPulseWidthCheckSeq &
min_pulse_width_checks(const Corner *corner)
{
  cmdLinkedNetwork();
  return Sta::sta()->minPulseWidthChecks(corner);
}

MinPulseWidthCheck *
min_pulse_width_check_slack(const Corner *corner)
{
  cmdLinkedNetwork();
  return Sta::sta()->minPulseWidthSlack(corner);
}

void
report_mpw_checks(MinPulseWidthCheckSeq *checks,
		  bool verbose)
{
  Sta::sta()->reportMpwChecks(checks, verbose);
}

void
report_mpw_check(MinPulseWidthCheck *check,
		 bool verbose)
{
  Sta::sta()->reportMpwCheck(check, verbose);
}

////////////////////////////////////////////////////////////////

MinPeriodCheckSeq &
min_period_violations()
{
  cmdLinkedNetwork();
  return Sta::sta()->minPeriodViolations();
}

MinPeriodCheck *
min_period_check_slack()
{
  cmdLinkedNetwork();
  return Sta::sta()->minPeriodSlack();
}

void
report_min_period_checks(MinPeriodCheckSeq *checks,
			 bool verbose)
{
  Sta::sta()->reportChecks(checks, verbose);
}

void
report_min_period_check(MinPeriodCheck *check,
			bool verbose)
{
  Sta::sta()->reportCheck(check, verbose);
}

////////////////////////////////////////////////////////////////

MaxSkewCheckSeq &
max_skew_violations()
{
  cmdLinkedNetwork();
  return Sta::sta()->maxSkewViolations();
}

MaxSkewCheck *
max_skew_check_slack()
{
  cmdLinkedNetwork();
  return Sta::sta()->maxSkewSlack();
}

void
report_max_skew_checks(MaxSkewCheckSeq *checks,
		       bool verbose)
{
  Sta::sta()->reportChecks(checks, verbose);
}

void
report_max_skew_check(MaxSkewCheck *check,
		      bool verbose)
{
  Sta::sta()->reportCheck(check, verbose);
}

////////////////////////////////////////////////////////////////

void
find_timing_cmd(bool full)
{
  cmdLinkedNetwork();
  Sta::sta()->updateTiming(full);
}

void
find_requireds()
{
  cmdLinkedNetwork();
  Sta::sta()->findRequireds();
}

void
find_delays()
{
  cmdLinkedNetwork();
  Sta::sta()->findDelays();
}

Slack
total_negative_slack_cmd(const MinMax *min_max)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  return sta->totalNegativeSlack(min_max);
}

Slack
total_negative_slack_corner_cmd(const Corner *corner,
				const MinMax *min_max)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  return sta->totalNegativeSlack(corner, min_max);
}

Slack
worst_slack_cmd(const MinMax *min_max)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  Slack worst_slack;
  Vertex *worst_vertex;
  sta->worstSlack(min_max, worst_slack, worst_vertex);
  return worst_slack;
}

Vertex *
worst_slack_vertex(const MinMax *min_max)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  Slack worst_slack;
  Vertex *worst_vertex;
  sta->worstSlack(min_max, worst_slack, worst_vertex);
  return worst_vertex;;
}

Slack
worst_slack_corner(const Corner *corner,
		   const MinMax *min_max)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  Slack worst_slack;
  Vertex *worst_vertex;
  sta->worstSlack(corner, min_max, worst_slack, worst_vertex);
  return worst_slack;
}

PathRef *
vertex_worst_arrival_path(Vertex *vertex,
			  const MinMax *min_max)
{
  Sta *sta = Sta::sta();
  PathRef path = sta->vertexWorstArrivalPath(vertex, min_max);
  if (!path.isNull())
    return new PathRef(path);
  else
    return nullptr;
}

PathRef *
vertex_worst_arrival_path_rf(Vertex *vertex,
			     const RiseFall *rf,
			     MinMax *min_max)
{
  Sta *sta = Sta::sta();
  PathRef path = sta->vertexWorstArrivalPath(vertex, rf, min_max);
  if (!path.isNull())
    return new PathRef(path);
  else
    return nullptr;
}

PathRef *
vertex_worst_slack_path(Vertex *vertex,
			const MinMax *min_max)
{
  Sta *sta = Sta::sta();
  PathRef path = sta->vertexWorstSlackPath(vertex, min_max);
  if (!path.isNull())
    return new PathRef(path);
  else
    return nullptr;
}

Slack
find_clk_min_period(const Clock *clk,
                    bool ignore_port_paths)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  return sta->findClkMinPeriod(clk, ignore_port_paths);
}

TmpString *
report_delay_calc_cmd(Edge *edge,
		      TimingArc *arc,
		      const Corner *corner,
		      const MinMax *min_max,
		      int digits)
{
  cmdLinkedNetwork();
  return Sta::sta()->reportDelayCalc(edge, arc, corner, min_max, digits);
}

////////////////////////////////////////////////////////////////

PinSeq *
check_slew_limits(Net *net,
                  bool violators,
                  const Corner *corner,
                  const MinMax *min_max)
{
  cmdLinkedNetwork();
  return Sta::sta()->checkSlewLimits(net, violators, corner, min_max);
}

size_t
max_slew_violation_count()
{
  cmdLinkedNetwork();
  return Sta::sta()->checkSlewLimits(nullptr, true, nullptr, MinMax::max())->size();
}

void
report_slew_limit_short_header()
{
  Sta::sta()->reportSlewLimitShortHeader();
}

void
report_slew_limit_short(Pin *pin,
			const Corner *corner,
			const MinMax *min_max)
{
  Sta::sta()->reportSlewLimitShort(pin, corner, min_max);
}

void
report_slew_limit_verbose(Pin *pin,
			  const Corner *corner,
			  const MinMax *min_max)
{
  Sta::sta()->reportSlewLimitVerbose(pin, corner, min_max);
}

////////////////////////////////////////////////////////////////

PinSeq *
check_fanout_limits(Net *net,
                    bool violators,
                    const MinMax *min_max)
{
  cmdLinkedNetwork();
  return Sta::sta()->checkFanoutLimits(net, violators, min_max);
}

size_t
max_fanout_violation_count()
{
  cmdLinkedNetwork();
  return Sta::sta()->checkFanoutLimits(nullptr, true, MinMax::max())->size();
}

void
report_fanout_limit_short_header()
{
  Sta::sta()->reportFanoutLimitShortHeader();
}

void
report_fanout_limit_short(Pin *pin,
			  const MinMax *min_max)
{
  Sta::sta()->reportFanoutLimitShort(pin, min_max);
}

void
report_fanout_limit_verbose(Pin *pin,
			    const MinMax *min_max)
{
  Sta::sta()->reportFanoutLimitVerbose(pin, min_max);
}

////////////////////////////////////////////////////////////////

PinSeq *
check_capacitance_limits(Net *net,
                         bool violators,
                         const Corner *corner,
                         const MinMax *min_max)
{
  cmdLinkedNetwork();
  return Sta::sta()->checkCapacitanceLimits(net, violators, corner, min_max);
}

size_t
max_capacitance_violation_count()
{
  cmdLinkedNetwork();
  return Sta::sta()->checkCapacitanceLimits(nullptr, true,nullptr,MinMax::max())->size();
}

void
report_capacitance_limit_short_header()
{
  Sta::sta()->reportCapacitanceLimitShortHeader();
}

void
report_capacitance_limit_short(Pin *pin,
			       const Corner *corner,
			       const MinMax *min_max)
{
  Sta::sta()->reportCapacitanceLimitShort(pin, corner, min_max);
}

void
report_capacitance_limit_verbose(Pin *pin,
				 const Corner *corner,
				 const MinMax *min_max)
{
  Sta::sta()->reportCapacitanceLimitVerbose(pin, corner, min_max);
}

////////////////////////////////////////////////////////////////

TmpFloatSeq *
design_power(const Corner *corner)
{
  cmdLinkedNetwork();
  PowerResult total, sequential, combinational, macro, pad;
  Sta::sta()->power(corner, total, sequential, combinational, macro, pad);
  FloatSeq *floats = new FloatSeq;
  pushPowerResultFloats(total, floats);
  pushPowerResultFloats(sequential, floats);
  pushPowerResultFloats(combinational, floats);
  pushPowerResultFloats(macro, floats);
  pushPowerResultFloats(pad, floats);
  return floats;
}

TmpFloatSeq *
instance_power(Instance *inst,
	       const Corner *corner)
{
  cmdLinkedNetwork();
  PowerResult power;
  Sta::sta()->power(inst, corner, power);
  FloatSeq *floats = new FloatSeq;
  floats->push_back(power.internal());
  floats->push_back(power.switching());
  floats->push_back(power.leakage());
  floats->push_back(power.total());
  return floats;
}

void
set_power_global_activity(float activity,
			  float duty)
{
  Sta::sta()->power()->setGlobalActivity(activity, duty);
}

void
set_power_input_activity(float activity,
			 float duty)
{
  return Sta::sta()->power()->setInputActivity(activity, duty);
}

void
set_power_input_port_activity(const Port *input_port,
			      float activity,
			      float duty)
{
  return Sta::sta()->power()->setInputPortActivity(input_port, activity, duty);
}

void
set_power_pin_activity(const Pin *pin,
		       float activity,
		       float duty)
{
  return Sta::sta()->power()->setUserActivity(pin, activity, duty,
					      PwrActivityOrigin::user);
}

////////////////////////////////////////////////////////////////

EdgeSeq *
disabled_edges_sorted()
{
  cmdLinkedNetwork();
  return Sta::sta()->disabledEdgesSorted();
}

void
write_sdc_cmd(const char *filename,
	      bool leaf,
	      bool compatible,
	      int digits,
              bool gzip,
	      bool no_timestamp)
{
  cmdLinkedNetwork();
  Sta::sta()->writeSdc(filename, leaf, compatible, digits, gzip, no_timestamp);
}

void
write_path_spice_cmd(PathRef *path,
		     const char *spice_filename,
		     const char *subckt_filename,
		     const char *lib_subckt_filename,
		     const char *model_filename,
		     const char *power_name,
		     const char *gnd_name)
{
  Sta *sta = Sta::sta();
  writePathSpice(path, spice_filename, subckt_filename,
		 lib_subckt_filename, model_filename,
		 power_name, gnd_name, sta);
}

bool
liberty_supply_exists(const char *supply_name)
{
  auto network = Sta::sta()->network();
  auto lib = network->defaultLibertyLibrary();
  return lib && lib->supplyExists(supply_name);
}

float
unit_scale(const char *unit_name)
{
  Unit *unit = Sta::sta()->units()->find(unit_name);
  if (unit)
    return unit->scale();
  else
    return 1.0F;
}

bool
fuzzy_equal(float value1,
	    float value2)
{
  return fuzzyEqual(value1, value2);
}

char
pin_sim_logic_value(const Pin *pin)
{
  return logicValueString(Sta::sta()->simLogicValue(pin));
}

char
pin_case_logic_value(const Pin *pin)
{
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  LogicValue value = LogicValue::unknown;
  bool exists;
  sdc->caseLogicValue(pin, value, exists);
  return logicValueString(value);
}

char
pin_logic_value(const Pin *pin)
{
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  LogicValue value = LogicValue::unknown;
  bool exists;
  sdc->logicValue(pin, value, exists);
  return logicValueString(value);
}

SlowDrvrIterator *
slow_driver_iterator()
{
  return Sta::sta()->slowDrvrIterator();
}

bool
timing_arc_disabled(Edge *edge,
		    TimingArc *arc)
{
  Graph *graph = Sta::sta()->graph();
  return !searchThru(edge, arc, graph);
}

ClockGroups *
make_clock_groups(const char *name,
		  bool logically_exclusive,
		  bool physically_exclusive,
		  bool asynchronous,
		  bool allow_paths,
		  const char *comment)
{
  return Sta::sta()->makeClockGroups(name, logically_exclusive,
				     physically_exclusive, asynchronous,
				     allow_paths, comment);
}

void
clock_groups_make_group(ClockGroups *clk_groups,
			ClockSet *clks)
{
  Sta::sta()->makeClockGroup(clk_groups, clks);
}

void
unset_clock_groups_logically_exclusive(const char *name)
{
  Sta::sta()->removeClockGroupsLogicallyExclusive(name);
}

void
unset_clock_groups_physically_exclusive(const char *name)
{
  Sta::sta()->removeClockGroupsPhysicallyExclusive(name);
}

void
unset_clock_groups_asynchronous(const char *name)
{
  Sta::sta()->removeClockGroupsAsynchronous(name);
}

// Debugging function.
bool
same_clk_group(Clock *clk1,
	       Clock *clk2)
{
  Sta *sta = Sta::sta();
  Sdc *sdc = sta->sdc();
  return sdc->sameClockGroupExplicit(clk1, clk2);
}

void
set_clock_sense_cmd(PinSet *pins,
		    ClockSet *clks,
		    bool positive,
		    bool negative,
		    bool stop_propagation)
{
  Sta *sta = Sta::sta();
  if (positive)
    sta->setClockSense(pins, clks, ClockSense::positive);
  else if (negative)
    sta->setClockSense(pins, clks, ClockSense::negative);
  else if (stop_propagation)
    sta->setClockSense(pins, clks, ClockSense::stop);
  else
    sta->report()->critical(273, "unknown clock sense");
}

bool
timing_role_is_check(TimingRole *role)
{
  return role->isTimingCheck();
}

////////////////////////////////////////////////////////////////

TmpPinSet *
find_fanin_pins(PinSeq *to,
		bool flat,
		bool startpoints_only,
		int inst_levels,
		int pin_levels,
		bool thru_disabled,
		bool thru_constants)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  PinSet *fanin = sta->findFaninPins(to, flat, startpoints_only,
				     inst_levels, pin_levels,
				     thru_disabled, thru_constants);
  delete to;
  return fanin;
}

TmpInstanceSet *
find_fanin_insts(PinSeq *to,
		 bool flat,
		 bool startpoints_only,
		 int inst_levels,
		 int pin_levels,
		 bool thru_disabled,
		 bool thru_constants)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  InstanceSet *fanin = sta->findFaninInstances(to, flat, startpoints_only,
					       inst_levels, pin_levels,
					       thru_disabled, thru_constants);
  delete to;
  return fanin;
}

TmpPinSet *
find_fanout_pins(PinSeq *from,
		 bool flat,
		 bool endpoints_only,
		 int inst_levels,
		 int pin_levels,
		 bool thru_disabled,
		 bool thru_constants)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  PinSet *fanout = sta->findFanoutPins(from, flat, endpoints_only,
				       inst_levels, pin_levels,
				       thru_disabled, thru_constants);
  delete from;
  return fanout;
}

TmpInstanceSet *
find_fanout_insts(PinSeq *from,
		  bool flat,
		  bool endpoints_only,
		  int inst_levels,
		  int pin_levels,
		  bool thru_disabled,
		  bool thru_constants)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  InstanceSet *fanout = sta->findFanoutInstances(from, flat, endpoints_only,
						 inst_levels, pin_levels,
						 thru_disabled, thru_constants);
  delete from;
  return fanout;
}

TmpPinSet *
net_load_pins(Net *net)
{
  Network *network = cmdLinkedNetwork();
  PinSet *pins = new PinSet;
  NetConnectedPinIterator *pin_iter = network->connectedPinIterator(net);
  while (pin_iter->hasNext()) {
    Pin *pin = pin_iter->next();
    if (network->isLoad(pin))
      pins->insert(pin);
  }
  delete pin_iter;
  return pins;
}

TmpPinSet *
net_driver_pins(Net *net)
{
  Network *network = cmdLinkedNetwork();
  PinSet *pins = new PinSet;
  NetConnectedPinIterator *pin_iter = network->connectedPinIterator(net);
  while (pin_iter->hasNext()) {
    Pin *pin = pin_iter->next();
    if (network->isDriver(pin))
      pins->insert(pin);
  }
  delete pin_iter;
  return pins;
}

////////////////////////////////////////////////////////////////

void
report_loops()
{
  Sta *sta = Sta::sta();
  Network *network = cmdLinkedNetwork();
  Graph *graph = cmdGraph();
  Report *report = sta->report();
  GraphLoopSeq *loops = sta->graphLoops();
  GraphLoopSeq::Iterator loop_iter(loops);
  while (loop_iter.hasNext()) {
    GraphLoop *loop = loop_iter.next();
    loop->report(report, network, graph);
    report->reportLineString("");
  }
}

// Includes top instance.
int
network_instance_count()
{
  Network *network = cmdNetwork();
  return network->instanceCount();
}

int
network_pin_count()
{
  Network *network = cmdNetwork();
  return network->pinCount();
}

int
network_net_count()
{
  Network *network = cmdNetwork();
  return network->netCount();
}

int
network_leaf_instance_count()
{
  Network *network = cmdNetwork();
  return network->leafInstanceCount();
}

int
network_leaf_pin_count()
{
  Network *network = cmdNetwork();
  return network->leafPinCount();
}

int
graph_vertex_count()
{
  return cmdGraph()->vertexCount();
}

int
graph_edge_count()
{
  return cmdGraph()->edgeCount();
}

int
graph_arc_count()
{
  return cmdGraph()->arcCount();
}

int
tag_group_count()
{
  return Sta::sta()->tagGroupCount();
}

void
report_tag_groups()
{
  Sta::sta()->search()->reportTagGroups();
}

void
report_tag_arrivals_cmd(Vertex *vertex)
{
  Sta::sta()->search()->reportArrivals(vertex);
}

void
report_arrival_count_histogram()
{
  Sta::sta()->search()->reportArrivalCountHistogram();
}

int
tag_count()
{
  return Sta::sta()->tagCount();
}

void
report_tags()
{
  Sta::sta()->search()->reportTags();
}

void
report_clk_infos()
{
  Sta::sta()->search()->reportClkInfos();
}

int
clk_info_count()
{
  return Sta::sta()->clkInfoCount();
}

int
arrival_count()
{
  return Sta::sta()->arrivalCount();
}

int
required_count()
{
  return Sta::sta()->requiredCount();
}

int
graph_arrival_count()
{
  return Sta::sta()->graph()->arrivalCount();
}

int
graph_required_count()
{
  return Sta::sta()->graph()->requiredCount();
}

void
delete_all_memory()
{
  deleteAllMemory();
}

Tcl_Interp *
tcl_interp()
{
  return Sta::sta()->tclInterp();
}

// Initialize sta after delete_all_memory.
void
init_sta()
{
  initSta();
}

void
clear_sta()
{
  Sta::sta()->clear();
}

void
make_sta(Tcl_Interp *interp)
{
  Sta *sta = new Sta;
  Sta::setSta(sta);
  sta->makeComponents();
  sta->setTclInterp(interp);
}

void
clear_network()
{
  Sta *sta = Sta::sta();
  sta->network()->clear();
}

// Elapsed run time (in seconds).
double
elapsed_run_time()
{
  return elapsedRunTime();
}

// User run time (in seconds).
double
user_run_time()
{
  return userRunTime();
}

// User run time (in seconds).
unsigned long
cputime()
{
  return static_cast<unsigned long>(userRunTime() + .5);
}

// Peak memory usage in bytes.
unsigned long
memory_usage()
{
  return memoryUsage();
}

int
processor_count()
{
  return processorCount();
}

int
thread_count()
{
  return Sta::sta()->threadCount();
}

void
set_thread_count(int count)
{
  Sta::sta()->setThreadCount(count);
}

void
arrivals_invalid()
{
  Sta *sta = Sta::sta();
  sta->arrivalsInvalid();
}

void
delays_invalid()
{
  Sta *sta = Sta::sta();
  sta->delaysInvalid();
}

const char *
pin_location(const Pin *pin)
{
  Network *network = cmdNetwork();
  double x, y;
  bool exists;
  network->location(pin, x, y, exists);
  // return x/y as tcl list
  if (exists)
    return sta::stringPrintTmp("%f %f", x, y);
  else
    return "";
}

const char *
port_location(const Port *port)
{
  Network *network = cmdNetwork();
  const Pin *pin = network->findPin(network->topInstance(), port);
  return pin_location(pin);
}

int
endpoint_count()
{
  return Sta::sta()->endpointCount();
}



#include <float.h>


#include <math.h>


/* Getting isfinite working pre C99 across multiple platforms is non-trivial. Users can provide SWIG_isfinite on older platforms. */
#ifndef SWIG_isfinite
/* isfinite() is a macro for C99 */
# if defined(isfinite)
#  define SWIG_isfinite(X) (isfinite(X))
# elif defined(__cplusplus) && __cplusplus >= 201103L
/* Use a template so that this works whether isfinite() is std::isfinite() or
 * in the global namespace.  The reality seems to vary between compiler
 * versions.
 *
 * Make sure namespace std exists to avoid compiler warnings.
 *
 * extern "C++" is required as this fragment can end up inside an extern "C" { } block
 */
namespace std { }
extern "C++" template<typename T>
inline int SWIG_isfinite_func(T x) {
  using namespace std;
  return isfinite(x);
}
#  define SWIG_isfinite(X) (SWIG_isfinite_func(X))
# elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 2))
#  define SWIG_isfinite(X) (__builtin_isfinite(X))
# elif defined(__clang__) && defined(__has_builtin)
#  if __has_builtin(__builtin_isfinite)
#   define SWIG_isfinite(X) (__builtin_isfinite(X))
#  endif
# elif defined(_MSC_VER)
#  define SWIG_isfinite(X) (_finite(X))
# elif defined(__sun) && defined(__SVR4)
#  include <ieeefp.h>
#  define SWIG_isfinite(X) (finite(X))
# endif
#endif


/* Accept infinite as a valid float value unless we are unable to check if a value is finite */
#ifdef SWIG_isfinite
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX) && SWIG_isfinite(X))
#else
# define SWIG_Float_Overflow_Check(X) ((X < -FLT_MAX || X > FLT_MAX))
#endif


SWIGINTERN int
SWIG_AsVal_double SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, double *val)
{
  double v;
  if (Tcl_GetDoubleFromObj(0, obj, &v) == TCL_OK) {
    if (val) *val = v;
    return SWIG_OK;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_float SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, float *val)
{
  double v;
  int res = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(obj, &v);
  if (SWIG_IsOK(res)) {
    if (SWIG_Float_Overflow_Check(v)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< float >(v);
    }
  }  
  return res;
}


SWIGINTERN int
SWIG_AsCharArray(Tcl_Obj * obj, char *val, size_t size)
{ 
  char* cptr = 0; size_t csize = 0; int alloc = SWIG_OLDOBJ;
  int res = SWIG_AsCharPtrAndSize(obj, &cptr, &csize, &alloc);
  if (SWIG_IsOK(res)) {
    /* special case of single char conversion when we don't need space for NUL */
    if (size == 1 && csize == 2 && cptr && !cptr[1]) --csize;
    if (csize <= size) {
      if (val) {
	if (csize) memcpy(val, cptr, csize*sizeof(char));
	if (csize < size) memset(val + csize, 0, (size - csize)*sizeof(char));
      }
      if (alloc == SWIG_NEWOBJ) {
	delete[] cptr;
	res = SWIG_DelNewMask(res);
      }      
      return res;
    }
    if (alloc == SWIG_NEWOBJ) delete[] cptr;
  }
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_char SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, char *val)
{    
  int res = SWIG_AsCharArray(obj, val, 1);
  if (!SWIG_IsOK(res)) {
    long v;
    res = SWIG_AddCast(SWIG_AsVal_long SWIG_TCL_CALL_ARGS_2(obj, &v));
    if (SWIG_IsOK(res)) {
      if ((CHAR_MIN <= v) && (v <= CHAR_MAX)) {
	if (val) *val = static_cast< char >(v);
      } else {
	res = SWIG_OverflowError;
      }
    }
  }
  return res;
}


#include <stdio.h>
#if (defined(_MSC_VER) && (_MSC_VER < 1900)) || defined(__BORLANDC__) || defined(_WATCOM)
# ifndef snprintf
#  define snprintf _snprintf
# endif
#endif


SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_unsigned_SS_long  (unsigned long value)
{
  if (value < (unsigned long) LONG_MAX) {
    return SWIG_From_long  (static_cast< long >(value));
  } else {
    char temp[256]; 
    sprintf(temp, "%lu", value);
    return Tcl_NewStringObj(temp,-1);
  }
}


#if defined(LLONG_MAX) && !defined(SWIG_LONG_LONG_AVAILABLE)
#  define SWIG_LONG_LONG_AVAILABLE
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_long_SS_long  (long long value)
{
  if (((long long) LONG_MIN <= value) && (value <= (long long) LONG_MAX)) {
    return SWIG_From_long  (static_cast< long >(value));
  } else {    
    char temp[256]; 
    sprintf(temp, "%lld", value);
    return Tcl_NewStringObj(temp,-1);
  }
}
#endif


#ifdef SWIG_LONG_LONG_AVAILABLE
SWIGINTERNINLINE Tcl_Obj* 
SWIG_From_unsigned_SS_long_SS_long  (unsigned long long value)
{
  if (value < (unsigned long long) LONG_MAX) {
    return SWIG_From_long_SS_long  (static_cast< long long >(value));
  } else {
    char temp[256]; 
    sprintf(temp, "%llu", value);
    return Tcl_NewStringObj(temp,-1);
  }
}
#endif


SWIGINTERNINLINE Tcl_Obj *
SWIG_From_size_t  (size_t value)
{    
#ifdef SWIG_LONG_LONG_AVAILABLE
  if (sizeof(size_t) <= sizeof(unsigned long)) {
#endif
    return SWIG_From_unsigned_SS_long  (static_cast< unsigned long >(value));
#ifdef SWIG_LONG_LONG_AVAILABLE
  } else {
    /* assume sizeof(size_t) <= sizeof(unsigned long long) */
    return SWIG_From_unsigned_SS_long_SS_long  (static_cast< unsigned long long >(value));
  }
#endif
}


SWIGINTERNINLINE Tcl_Obj *
SWIG_From_char  (char c) 
{ 
  return SWIG_FromCharPtrAndSize(&c,1);
}



// OpenSTA, Static Timing Analyzer
// Copyright (c) 2022, Parallax Software, Inc.
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

using sta::Cell;
using sta::Instance;
using sta::Net;
using sta::Port;
using sta::Pin;
using sta::NetworkEdit;
using sta::cmdEditNetwork;




Instance *
make_instance_cmd(const char *name,
		  LibertyCell *cell,
		  Instance *parent)
{
  return Sta::sta()->makeInstance(name, cell, parent);
}

void
delete_instance_cmd(Instance *inst)
{
  Sta::sta()->deleteInstance(inst);
}

void
replace_cell_cmd(Instance *inst,
		 LibertyCell *to_cell)
{
  Sta::sta()->replaceCell(inst, to_cell);
}

Net *
make_net_cmd(const char *name,
	     Instance *parent)
{
  Net *net = cmdEditNetwork()->makeNet(name, parent);
  // Sta notification unnecessary.
  return net;
}

void
delete_net_cmd(Net *net)
{
  Sta::sta()->deleteNet(net);
}

void
connect_pin_cmd(Instance *inst,
		Port *port,
		Net *net)
{
  Sta::sta()->connectPin(inst, port, net);
}

void
disconnect_pin_cmd(Pin *pin)
{
  Sta::sta()->disconnectPin(pin);
}

// Notify STA of network change.
void
network_changed()
{
  Sta::sta()->networkChanged();
}




// OpenSTA, Static Timing Analyzer
// Copyright (c) 2022, Parallax Software, Inc.
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

#include "sdf/SdfReader.hh"
#include "sdf/ReportAnnotation.hh"
#include "sdf/SdfWriter.hh"
#include "Search.hh"
#include "Sta.hh"

using sta::Sta;
using sta::cmdLinkedNetwork;
using sta::AnalysisType;
using sta::MinMax;
using sta::MinMaxAllNull;
using sta::stringEq;
using sta::readSdf;
using sta::reportAnnotatedDelay;
using sta::reportAnnotatedCheck;




// If unescaped_dividers is true path names do not have to escape
// hierarchy dividers when the path name is quoted.
// For example verilog "\mod1/mod2 " can be referenced as "mod1/mod2"
// instead of the correct "mod1\/mod2".

// Return true if successful.
bool
read_sdf_file(const char *filename,
              const char *path,
              Corner *corner,
              bool unescaped_dividers,
              bool incremental_only,
              MinMaxAllNull *cond_use)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  sta->ensureGraph();
  if (stringEq(path, ""))
    path = NULL;
  bool success = readSdf(filename, path, corner, unescaped_dividers, incremental_only,
                         cond_use, sta);
  sta->search()->arrivalsInvalid();
  return success;
}

void
report_annotated_delay_cmd(bool report_cells,
			   bool report_nets,
			   bool report_in_ports,
			   bool report_out_ports,
			   unsigned max_lines,
			   bool list_annotated,
			   bool list_not_annotated,
			   bool report_constant_arcs)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  sta->ensureGraph();
  reportAnnotatedDelay(report_cells, report_nets,
		       report_in_ports, report_out_ports,
		       max_lines, list_annotated, list_not_annotated,
		       report_constant_arcs, sta);
}

void
report_annotated_check_cmd(bool report_setup,
			   bool report_hold,
			   bool report_recovery,
			   bool report_removal,
			   bool report_nochange,
			   bool report_width,
			   bool report_period,
			   bool report_max_skew,
			   unsigned max_lines,
			   bool list_annotated,
			   bool list_not_annotated,
			   bool report_constant_arcs)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  sta->ensureGraph();
  reportAnnotatedCheck(report_setup, report_hold,
		       report_recovery, report_removal,
		       report_nochange, report_width,
		       report_period,  report_max_skew,
		       max_lines, list_annotated, list_not_annotated,
		       report_constant_arcs, sta);
}

void
write_sdf_cmd(char *filename,
	      Corner *corner,
	      char divider,
	      bool include_typ,
              int digits,
	      bool gzip,
	      bool no_timestamp,
	      bool no_version)
{
  cmdLinkedNetwork();
  Sta *sta = Sta::sta();
  sta->writeSdf(filename, corner, divider, include_typ, digits, gzip,
		no_timestamp, no_version);
}



SWIGINTERN int
SWIG_AsVal_unsigned_SS_long SWIG_TCL_DECL_ARGS_2(Tcl_Obj *obj, unsigned long *val) {
  long v;
  if (Tcl_GetLongFromObj(0,obj, &v) == TCL_OK) {
    if (v >= 0) {
      if (val) *val = (unsigned long) v;
      return SWIG_OK;
    }
    /* If v is negative, then this could be a negative number, or an
       unsigned value which doesn't fit in a signed long, so try to
       get it as a string so we can distinguish these cases. */
  }
  {
    int len = 0;
    const char *nptr = Tcl_GetStringFromObj(obj, &len);
    if (nptr && len > 0) {
      char *endptr;
      unsigned long v;
      if (*nptr == '-') return SWIG_OverflowError;
      errno = 0;
      v = strtoul(nptr, &endptr,0);
      if (nptr[0] == '\0' || *endptr != '\0')
	return SWIG_TypeError;
      if (v == ULONG_MAX && errno == ERANGE) {
	errno = 0;
	return SWIG_OverflowError;
      } else {
	if (*endptr == '\0') {
	  if (val) *val = v;
	  return SWIG_OK;
	}
      }
    }
  }
  
  return SWIG_TypeError;
}


SWIGINTERN int
SWIG_AsVal_unsigned_SS_int SWIG_TCL_DECL_ARGS_2(Tcl_Obj * obj, unsigned int *val)
{
  unsigned long v;
  int res = SWIG_AsVal_unsigned_SS_long SWIG_TCL_CALL_ARGS_2(obj, &v);
  if (SWIG_IsOK(res)) {
    if ((v > UINT_MAX)) {
      return SWIG_OverflowError;
    } else {
      if (val) *val = static_cast< unsigned int >(v);
    }
  }  
  return res;
}



// OpenSTA, Static Timing Analyzer
// Copyright (c) 2022, Parallax Software, Inc.
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

#include "Sta.hh"




TmpStringSeq *
delay_calc_names()
{
  return sta::delayCalcNames();
}

bool
is_delay_calc_name(const char *alg)
{
  return sta::isDelayCalcName(alg);
}

void
set_delay_calculator_cmd(const char *alg)
{
  sta::Sta::sta()->setArcDelayCalc(alg);
}

void
set_delay_calc_incremental_tolerance(float tol)
{
  sta::Sta::sta()->setIncrementalDelayTolerance(tol);
}




// OpenSTA, Static Timing Analyzer
// Copyright (c) 2022, Parallax Software, Inc.
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

#include "Sta.hh"

using sta::Sta;
using sta::cmdLinkedNetwork;
using sta::Instance;
using sta::MinMaxAll;
using sta::ReducedParasiticType;
using sta::RiseFall;
using sta::Pin;
using sta::TmpFloatSeq;




bool
read_spef_cmd(const char *filename,
	      Instance *instance,
	      const Corner *corner,
              const MinMaxAll *min_max,
	      bool increment,
	      bool pin_cap_included,
	      bool keep_coupling_caps,
	      float coupling_cap_factor,
	      ReducedParasiticType reduce_to,
	      bool delete_after_reduce,
	      bool quiet)
{
  cmdLinkedNetwork();
  return Sta::sta()->readSpef(filename, instance, corner, min_max,
			      increment, pin_cap_included,
			      keep_coupling_caps, coupling_cap_factor,
			      reduce_to, delete_after_reduce, quiet);
}

TmpFloatSeq *
find_pi_elmore(Pin *drvr_pin,
	       RiseFall *rf,
	       MinMax *min_max)
{
  float c2, rpi, c1;
  bool exists;
  Sta::sta()->findPiElmore(drvr_pin, rf, min_max, c2, rpi, c1, exists);
  TmpFloatSeq *floats = new FloatSeq;
  if (exists) {
    floats->push_back(c2);
    floats->push_back(rpi);
    floats->push_back(c1);
  }
  return floats;
}

float
find_elmore(Pin *drvr_pin,
	    Pin *load_pin,
	    RiseFall *rf,
	    MinMax *min_max)
{
  float elmore = 0.0;
  bool exists;
  Sta::sta()->findElmore(drvr_pin, load_pin, rf, min_max, elmore, exists);
  return elmore;
}

void
set_pi_model_cmd(Pin *drvr_pin,
		 RiseFall *rf,
		 MinMaxAll *min_max,
		 float c2,
		 float rpi,
		 float c1)
{
  Sta::sta()->makePiElmore(drvr_pin, rf, min_max, c2, rpi, c1);
}

void
set_elmore_cmd(Pin *drvr_pin,
	       Pin *load_pin,
	       RiseFall *rf,
	       MinMaxAll *min_max,
	       float elmore)
{
  Sta::sta()->setElmore(drvr_pin, load_pin, rf, min_max, elmore);
}



SWIGINTERNINLINE Tcl_Obj *
SWIG_From_unsigned_SS_int  (unsigned int value)
{    
  return SWIG_From_unsigned_SS_long  (value);
}

SWIGINTERN dbNet *std_vector_Sl_dbNet_Sm__Sg__pop(std::vector< dbNet * > *self){
                if (self->size() == 0)
                    throw std::out_of_range("pop from empty vector");
                dbNet * x = self->back();
                self->pop_back();
                return x;
            }
SWIGINTERN dbNet *&std_vector_Sl_dbNet_Sm__Sg__get(std::vector< dbNet * > *self,int i){
                int size = int(self->size());
                if (i<0) i += size;
                if (i>=0 && i<size)
                    return (*self)[i];
                else
                    throw std::out_of_range("vector index out of range");
            }
SWIGINTERN void std_vector_Sl_dbNet_Sm__Sg__set(std::vector< dbNet * > *self,int i,dbNet *const &x){
                int size = int(self->size());
                if (i<0) i+= size;
                if (i>=0 && i<size)
                    (*self)[i] = x;
                else
                    throw std::out_of_range("vector index out of range");
            }


sta::Sta *
make_block_sta(odb::dbBlock *block)
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  return sta::makeBlockSta(openroad, block);
}

// For testing
void
find_logic_constants()
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  sta::dbSta *sta = openroad->getSta();
  sta->findLogicConstants();
}

void
highlight_path_cmd(PathRef *path)
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  sta::dbSta *sta = openroad->getSta();
  sta->highlight(path);
}

std::vector<odb::dbNet*>
find_all_clk_nets()
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  sta::dbSta *sta = openroad->getSta();
  auto clks = sta->findClkNets();
  return std::vector<odb::dbNet*>(clks.begin(), clks.end());
}

odb::dbInst *
sta_to_db_inst(Instance *inst)
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  sta::dbNetwork *db_network = openroad->getDbNetwork();
  return db_network->staToDb(inst);
}

odb::dbBTerm *
sta_to_db_port(Port *port)
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  sta::dbNetwork *db_network = openroad->getDbNetwork();
  Pin *pin = db_network->findPin(db_network->topInstance(), port);
  dbITerm *iterm;
  dbBTerm *bterm;
  db_network->staToDb(pin, iterm, bterm);
  return bterm;
}

odb::dbITerm *
sta_to_db_pin(Pin *pin)
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  sta::dbNetwork *db_network = openroad->getDbNetwork();
  dbITerm *iterm;
  dbBTerm *bterm;
  db_network->staToDb(pin, iterm, bterm);
  return iterm;
}

odb::dbNet *
sta_to_db_net(Net *net)
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  sta::dbNetwork *db_network = openroad->getDbNetwork();
  return db_network->staToDb(net);
}

odb::dbMaster *
sta_to_db_master(LibertyCell *cell)
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  sta::dbNetwork *db_network = openroad->getDbNetwork();
  return db_network->staToDb(cell);
}

void
db_network_defined()
{
  ord::OpenRoad *openroad = ord::getOpenRoad();
  sta::dbNetwork *db_network = openroad->getDbNetwork();
  odb::dbDatabase *db = openroad->getDb();
  odb::dbChip *chip = db->getChip();
  odb::dbBlock *block = chip->getBlock();
  db_network->readDefAfter(block);
}


#ifdef __cplusplus
extern "C" {
#endif
SWIGINTERN int
_wrap_Library_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Library *arg1 = (Library *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Library_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Library, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Library_name" "', argument " "1"" of type '" "Library *""'"); 
  }
  arg1 = reinterpret_cast< Library * >(argp1);
  {
    try {
      result = (char *)Library_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Library_find_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Library *arg1 = (Library *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Library_find_cell self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Library, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Library_find_cell" "', argument " "1"" of type '" "Library *""'"); 
  }
  arg1 = reinterpret_cast< Library * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Library_find_cell" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Cell *)Library_find_cell(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Library_find_cells_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Library *arg1 = (Library *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  TmpCellSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Library_find_cells_matching self pattern regexp nocase ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Library, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Library_find_cells_matching" "', argument " "1"" of type '" "Library *""'"); 
  }
  arg1 = reinterpret_cast< Library * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Library_find_cells_matching" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Library_find_cells_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Library_find_cells_matching" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (TmpCellSeq *)Library_find_cells_matching(arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    CellSeq *cells = result;
    CellSeq::Iterator cell_iter(cells);
    while (cell_iter.hasNext()) {
      Cell *cell = cell_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(cell, SWIGTYPE_p_Cell, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
    delete cells;
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


static swig_method swig_Library_methods[] = {
    {"name", _wrap_Library_name}, 
    {"find_cell", _wrap_Library_find_cell}, 
    {"find_cells_matching", _wrap_Library_find_cells_matching}, 
    {0,0}
};
static swig_attribute swig_Library_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Library_bases[] = {0};
static const char * swig_Library_base_names[] = {0};
static swig_class _wrap_class_Library = { "Library", &SWIGTYPE_p_Library,0,0, swig_Library_methods, swig_Library_attributes, swig_Library_bases,swig_Library_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibraryIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibraryIterator *arg1 = (LibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibraryIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibraryIterator_has_next" "', argument " "1"" of type '" "LibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibraryIterator * >(argp1);
  {
    try {
      result = (bool)LibraryIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibraryIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibraryIterator *arg1 = (LibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Library *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibraryIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibraryIterator_next" "', argument " "1"" of type '" "LibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibraryIterator * >(argp1);
  {
    try {
      result = (Library *)LibraryIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Library, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibraryIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibraryIterator *arg1 = (LibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibraryIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibraryIterator_finish" "', argument " "1"" of type '" "LibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibraryIterator * >(argp1);
  {
    try {
      LibraryIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibraryIterator_methods[] = {
    {"has_next", _wrap_LibraryIterator_has_next}, 
    {"next", _wrap_LibraryIterator_next}, 
    {"finish", _wrap_LibraryIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LibraryIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibraryIterator_bases[] = {0};
static const char * swig_LibraryIterator_base_names[] = {0};
static swig_class _wrap_class_LibraryIterator = { "LibraryIterator", &SWIGTYPE_p_LibraryIterator,0,0, swig_LibraryIterator_methods, swig_LibraryIterator_attributes, swig_LibraryIterator_bases,swig_LibraryIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Cell_library(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Library *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Cell_library self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_library" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    try {
      result = (Library *)Cell_library(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Library, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_liberty_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Cell_liberty_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_liberty_cell" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    try {
      result = (LibertyCell *)Cell_liberty_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_is_leaf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Cell_is_leaf self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_is_leaf" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    try {
      result = (bool)Cell_is_leaf(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_port_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  CellPortIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Cell_port_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_port_iterator" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    try {
      result = (CellPortIterator *)Cell_port_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_CellPortIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_find_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Port *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Cell_find_port self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_find_port" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Cell_find_port" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Port *)Cell_find_port(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Port, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Cell_find_ports_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  TmpPortSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Cell_find_ports_matching self pattern regexp nocase ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Cell_find_ports_matching" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Cell_find_ports_matching" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Cell_find_ports_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "Cell_find_ports_matching" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (TmpPortSeq *)Cell_find_ports_matching(arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    TmpPortSeq *ports = result;
    TmpPortSeq::Iterator port_iter(ports);
    while (port_iter.hasNext()) {
      Port *port = port_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(port, SWIGTYPE_p_Port, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete ports;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


static swig_method swig_Cell_methods[] = {
    {"library", _wrap_Cell_library}, 
    {"liberty_cell", _wrap_Cell_liberty_cell}, 
    {"is_leaf", _wrap_Cell_is_leaf}, 
    {"port_iterator", _wrap_Cell_port_iterator}, 
    {"find_port", _wrap_Cell_find_port}, 
    {"find_ports_matching", _wrap_Cell_find_ports_matching}, 
    {0,0}
};
static swig_attribute swig_Cell_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Cell_bases[] = {0};
static const char * swig_Cell_base_names[] = {0};
static swig_class _wrap_class_Cell = { "Cell", &SWIGTYPE_p_Cell,0,0, swig_Cell_methods, swig_Cell_attributes, swig_Cell_bases,swig_Cell_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_CellPortIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  CellPortIterator *arg1 = (CellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::CellPortIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_CellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CellPortIterator_has_next" "', argument " "1"" of type '" "CellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< CellPortIterator * >(argp1);
  {
    try {
      result = (bool)CellPortIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_CellPortIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  CellPortIterator *arg1 = (CellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Port *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::CellPortIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_CellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CellPortIterator_next" "', argument " "1"" of type '" "CellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< CellPortIterator * >(argp1);
  {
    try {
      result = (Port *)CellPortIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Port, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_CellPortIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  CellPortIterator *arg1 = (CellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::CellPortIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_CellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "CellPortIterator_finish" "', argument " "1"" of type '" "CellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< CellPortIterator * >(argp1);
  {
    try {
      CellPortIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_CellPortIterator_methods[] = {
    {"has_next", _wrap_CellPortIterator_has_next}, 
    {"next", _wrap_CellPortIterator_next}, 
    {"finish", _wrap_CellPortIterator_finish}, 
    {0,0}
};
static swig_attribute swig_CellPortIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_CellPortIterator_bases[] = {0};
static const char * swig_CellPortIterator_base_names[] = {0};
static swig_class _wrap_class_CellPortIterator = { "CellPortIterator", &SWIGTYPE_p_CellPortIterator,0,0, swig_CellPortIterator_methods, swig_CellPortIterator_attributes, swig_CellPortIterator_bases,swig_CellPortIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyCellPortIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCellPortIterator *arg1 = (LibertyCellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCellPortIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCellPortIterator_has_next" "', argument " "1"" of type '" "LibertyCellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCellPortIterator * >(argp1);
  {
    try {
      result = (bool)LibertyCellPortIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCellPortIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCellPortIterator *arg1 = (LibertyCellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCellPortIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCellPortIterator_next" "', argument " "1"" of type '" "LibertyCellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCellPortIterator * >(argp1);
  {
    try {
      result = (LibertyPort *)LibertyCellPortIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCellPortIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCellPortIterator *arg1 = (LibertyCellPortIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCellPortIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCellPortIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCellPortIterator_finish" "', argument " "1"" of type '" "LibertyCellPortIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCellPortIterator * >(argp1);
  {
    try {
      LibertyCellPortIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyCellPortIterator_methods[] = {
    {"has_next", _wrap_LibertyCellPortIterator_has_next}, 
    {"next", _wrap_LibertyCellPortIterator_next}, 
    {"finish", _wrap_LibertyCellPortIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LibertyCellPortIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyCellPortIterator_bases[] = {0};
static const char * swig_LibertyCellPortIterator_base_names[] = {0};
static swig_class _wrap_class_LibertyCellPortIterator = { "LibertyCellPortIterator", &SWIGTYPE_p_LibertyCellPortIterator,0,0, swig_LibertyCellPortIterator_methods, swig_LibertyCellPortIterator_attributes, swig_LibertyCellPortIterator_bases,swig_LibertyCellPortIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Port_bus_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_bus_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_bus_name" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (char *)Port_bus_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Port_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_cell" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (Cell *)Port_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Port_liberty_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_liberty_port self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_liberty_port" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (LibertyPort *)Port_liberty_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Port_is_bus(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_is_bus self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_is_bus" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (bool)Port_is_bus(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Port_member_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PortMemberIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Port_member_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Port_member_iterator" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (PortMemberIterator *)Port_member_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_PortMemberIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Port_methods[] = {
    {"bus_name", _wrap_Port_bus_name}, 
    {"cell", _wrap_Port_cell}, 
    {"liberty_port", _wrap_Port_liberty_port}, 
    {"is_bus", _wrap_Port_is_bus}, 
    {"member_iterator", _wrap_Port_member_iterator}, 
    {0,0}
};
static swig_attribute swig_Port_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Port_bases[] = {0};
static const char * swig_Port_base_names[] = {0};
static swig_class _wrap_class_Port = { "Port", &SWIGTYPE_p_Port,0,0, swig_Port_methods, swig_Port_attributes, swig_Port_bases,swig_Port_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_PortMemberIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PortMemberIterator *arg1 = (PortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PortMemberIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortMemberIterator_has_next" "', argument " "1"" of type '" "PortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< PortMemberIterator * >(argp1);
  {
    try {
      result = (bool)PortMemberIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PortMemberIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PortMemberIterator *arg1 = (PortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Port *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PortMemberIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortMemberIterator_next" "', argument " "1"" of type '" "PortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< PortMemberIterator * >(argp1);
  {
    try {
      result = (Port *)PortMemberIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Port, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PortMemberIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PortMemberIterator *arg1 = (PortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PortMemberIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PortMemberIterator_finish" "', argument " "1"" of type '" "PortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< PortMemberIterator * >(argp1);
  {
    try {
      PortMemberIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_PortMemberIterator_methods[] = {
    {"has_next", _wrap_PortMemberIterator_has_next}, 
    {"next", _wrap_PortMemberIterator_next}, 
    {"finish", _wrap_PortMemberIterator_finish}, 
    {0,0}
};
static swig_attribute swig_PortMemberIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PortMemberIterator_bases[] = {0};
static const char * swig_PortMemberIterator_base_names[] = {0};
static swig_class _wrap_class_PortMemberIterator = { "PortMemberIterator", &SWIGTYPE_p_PortMemberIterator,0,0, swig_PortMemberIterator_methods, swig_PortMemberIterator_attributes, swig_PortMemberIterator_bases,swig_PortMemberIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyLibrary_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibrary_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_name" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  {
    try {
      result = (char *)LibertyLibrary_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_liberty_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  LibertyCell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyLibrary_find_liberty_cell self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_liberty_cell" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_liberty_cell" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (LibertyCell *)LibertyLibrary_find_liberty_cell(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCell, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_liberty_cells_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  TmpLibertyCellSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::LibertyLibrary_find_liberty_cells_matching self pattern regexp nocase ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_liberty_cells_matching" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_liberty_cells_matching" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "LibertyLibrary_find_liberty_cells_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "LibertyLibrary_find_liberty_cells_matching" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (TmpLibertyCellSeq *)LibertyLibrary_find_liberty_cells_matching(arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    LibertyCellSeq *cells = result;
    LibertyCellSeq::Iterator cell_iter(cells);
    while (cell_iter.hasNext()) {
      LibertyCell *cell = cell_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(cell, SWIGTYPE_p_LibertyCell,
        false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
    delete cells;
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_wireload(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Wireload *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyLibrary_find_wireload self model_name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_wireload" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_wireload" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Wireload *)LibertyLibrary_find_wireload(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Wireload, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_wireload_selection(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  WireloadSelection *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyLibrary_find_wireload_selection self selection_name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_wireload_selection" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_wireload_selection" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (WireloadSelection *)LibertyLibrary_find_wireload_selection(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_WireloadSelection, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_find_operating_conditions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  OperatingConditions *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyLibrary_find_operating_conditions self op_cond_name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_find_operating_conditions" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyLibrary_find_operating_conditions" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (OperatingConditions *)LibertyLibrary_find_operating_conditions(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_OperatingConditions, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibrary_default_operating_conditions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  OperatingConditions *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibrary_default_operating_conditions self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibrary_default_operating_conditions" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  {
    try {
      result = (OperatingConditions *)LibertyLibrary_default_operating_conditions(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_OperatingConditions, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyLibrary_methods[] = {
    {"name", _wrap_LibertyLibrary_name}, 
    {"find_liberty_cell", _wrap_LibertyLibrary_find_liberty_cell}, 
    {"find_liberty_cells_matching", _wrap_LibertyLibrary_find_liberty_cells_matching}, 
    {"find_wireload", _wrap_LibertyLibrary_find_wireload}, 
    {"find_wireload_selection", _wrap_LibertyLibrary_find_wireload_selection}, 
    {"find_operating_conditions", _wrap_LibertyLibrary_find_operating_conditions}, 
    {"default_operating_conditions", _wrap_LibertyLibrary_default_operating_conditions}, 
    {0,0}
};
static swig_attribute swig_LibertyLibrary_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyLibrary_bases[] = {0};
static const char * swig_LibertyLibrary_base_names[] = {0};
static swig_class _wrap_class_LibertyLibrary = { "LibertyLibrary", &SWIGTYPE_p_LibertyLibrary,0,0, swig_LibertyLibrary_methods, swig_LibertyLibrary_attributes, swig_LibertyLibrary_bases,swig_LibertyLibrary_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyLibraryIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibraryIterator *arg1 = (LibertyLibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibraryIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibraryIterator_has_next" "', argument " "1"" of type '" "LibertyLibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibraryIterator * >(argp1);
  {
    try {
      result = (bool)LibertyLibraryIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibraryIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibraryIterator *arg1 = (LibertyLibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyLibrary *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibraryIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibraryIterator_next" "', argument " "1"" of type '" "LibertyLibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibraryIterator * >(argp1);
  {
    try {
      result = (LibertyLibrary *)LibertyLibraryIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_LibertyLibrary,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyLibraryIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibraryIterator *arg1 = (LibertyLibraryIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyLibraryIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibraryIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyLibraryIterator_finish" "', argument " "1"" of type '" "LibertyLibraryIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibraryIterator * >(argp1);
  {
    try {
      LibertyLibraryIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyLibraryIterator_methods[] = {
    {"has_next", _wrap_LibertyLibraryIterator_has_next}, 
    {"next", _wrap_LibertyLibraryIterator_next}, 
    {"finish", _wrap_LibertyLibraryIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LibertyLibraryIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyLibraryIterator_bases[] = {0};
static const char * swig_LibertyLibraryIterator_base_names[] = {0};
static swig_class _wrap_class_LibertyLibraryIterator = { "LibertyLibraryIterator", &SWIGTYPE_p_LibertyLibraryIterator,0,0, swig_LibertyLibraryIterator_methods, swig_LibertyLibraryIterator_attributes, swig_LibertyLibraryIterator_bases,swig_LibertyLibraryIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyCell_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_name" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (char *)LibertyCell_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_is_leaf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_is_leaf self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_is_leaf" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (bool)LibertyCell_is_leaf(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_is_buffer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_is_buffer self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_is_buffer" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (bool)LibertyCell_is_buffer(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_is_inverter(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_is_inverter self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_is_inverter" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (bool)LibertyCell_is_inverter(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_liberty_library(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyLibrary *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_liberty_library self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_liberty_library" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (LibertyLibrary *)LibertyCell_liberty_library(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_LibertyLibrary,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_cell" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (Cell *)LibertyCell_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_find_liberty_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::LibertyCell_find_liberty_port self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_find_liberty_port" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyCell_find_liberty_port" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (LibertyPort *)LibertyCell_find_liberty_port(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_find_liberty_ports_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  char *arg2 = (char *) 0 ;
  bool arg3 ;
  bool arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  TmpLibertyPortSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::LibertyCell_find_liberty_ports_matching self pattern regexp nocase ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_find_liberty_ports_matching" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyCell_find_liberty_ports_matching" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "LibertyCell_find_liberty_ports_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "LibertyCell_find_liberty_ports_matching" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (TmpLibertyPortSeq *)LibertyCell_find_liberty_ports_matching(arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    TmpLibertyPortSeq *ports = result;
    TmpLibertyPortSeq::Iterator port_iter(ports);
    while (port_iter.hasNext()) {
      LibertyPort *port = port_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(port, SWIGTYPE_p_LibertyPort,
        false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete ports;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_liberty_port_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCellPortIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_liberty_port_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_liberty_port_iterator" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (LibertyCellPortIterator *)LibertyCell_liberty_port_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCellPortIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCell_timing_arc_set_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCellTimingArcSetIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCell_timing_arc_set_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCell_timing_arc_set_iterator" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (LibertyCellTimingArcSetIterator *)LibertyCell_timing_arc_set_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj=SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCellTimingArcSetIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyCell_methods[] = {
    {"name", _wrap_LibertyCell_name}, 
    {"is_leaf", _wrap_LibertyCell_is_leaf}, 
    {"is_buffer", _wrap_LibertyCell_is_buffer}, 
    {"is_inverter", _wrap_LibertyCell_is_inverter}, 
    {"liberty_library", _wrap_LibertyCell_liberty_library}, 
    {"cell", _wrap_LibertyCell_cell}, 
    {"find_liberty_port", _wrap_LibertyCell_find_liberty_port}, 
    {"find_liberty_ports_matching", _wrap_LibertyCell_find_liberty_ports_matching}, 
    {"liberty_port_iterator", _wrap_LibertyCell_liberty_port_iterator}, 
    {"timing_arc_set_iterator", _wrap_LibertyCell_timing_arc_set_iterator}, 
    {0,0}
};
static swig_attribute swig_LibertyCell_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyCell_bases[] = {0};
static const char * swig_LibertyCell_base_names[] = {0};
static swig_class _wrap_class_LibertyCell = { "LibertyCell", &SWIGTYPE_p_LibertyCell,0,0, swig_LibertyCell_methods, swig_LibertyCell_attributes, swig_LibertyCell_bases,swig_LibertyCell_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyPort_bus_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_bus_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_bus_name" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (char *)LibertyPort_bus_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_cell" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (Cell *)LibertyPort_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_is_bus(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_is_bus self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_is_bus" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (bool)LibertyPort_is_bus(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_member_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPortMemberIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_member_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_member_iterator" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (LibertyPortMemberIterator *)LibertyPort_member_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result,
      SWIGTYPE_p_LibertyPortMemberIterator,
      false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_function(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_function self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_function" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (char *)LibertyPort_function(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_tristate_enable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPort_tristate_enable self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_tristate_enable" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (char *)LibertyPort_tristate_enable(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPort_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::LibertyPort_capacitance self corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPort_capacitance" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "LibertyPort_capacitance" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)LibertyPort_capacitance(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyPort_methods[] = {
    {"bus_name", _wrap_LibertyPort_bus_name}, 
    {"cell", _wrap_LibertyPort_cell}, 
    {"is_bus", _wrap_LibertyPort_is_bus}, 
    {"member_iterator", _wrap_LibertyPort_member_iterator}, 
    {"function", _wrap_LibertyPort_function}, 
    {"tristate_enable", _wrap_LibertyPort_tristate_enable}, 
    {"capacitance", _wrap_LibertyPort_capacitance}, 
    {0,0}
};
static swig_attribute swig_LibertyPort_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyPort_bases[] = {0};
static const char * swig_LibertyPort_base_names[] = {0};
static swig_class _wrap_class_LibertyPort = { "LibertyPort", &SWIGTYPE_p_LibertyPort,0,0, swig_LibertyPort_methods, swig_LibertyPort_attributes, swig_LibertyPort_bases,swig_LibertyPort_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyPortMemberIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPortMemberIterator *arg1 = (LibertyPortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPortMemberIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPortMemberIterator_has_next" "', argument " "1"" of type '" "LibertyPortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPortMemberIterator * >(argp1);
  {
    try {
      result = (bool)LibertyPortMemberIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPortMemberIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPortMemberIterator *arg1 = (LibertyPortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPortMemberIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPortMemberIterator_next" "', argument " "1"" of type '" "LibertyPortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPortMemberIterator * >(argp1);
  {
    try {
      result = (LibertyPort *)LibertyPortMemberIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyPortMemberIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPortMemberIterator *arg1 = (LibertyPortMemberIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyPortMemberIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPortMemberIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyPortMemberIterator_finish" "', argument " "1"" of type '" "LibertyPortMemberIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPortMemberIterator * >(argp1);
  {
    try {
      LibertyPortMemberIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyPortMemberIterator_methods[] = {
    {"has_next", _wrap_LibertyPortMemberIterator_has_next}, 
    {"next", _wrap_LibertyPortMemberIterator_next}, 
    {"finish", _wrap_LibertyPortMemberIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LibertyPortMemberIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyPortMemberIterator_bases[] = {0};
static const char * swig_LibertyPortMemberIterator_base_names[] = {0};
static swig_class _wrap_class_LibertyPortMemberIterator = { "LibertyPortMemberIterator", &SWIGTYPE_p_LibertyPortMemberIterator,0,0, swig_LibertyPortMemberIterator_methods, swig_LibertyPortMemberIterator_attributes, swig_LibertyPortMemberIterator_bases,swig_LibertyPortMemberIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_TimingArcSet_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_from self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_from" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (LibertyPort *)TimingArcSet_from(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSet_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_to self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_to" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (LibertyPort *)TimingArcSet_to(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSet_role(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingRole *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_role self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_role" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (TimingRole *)TimingArcSet_role(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSet_sdf_cond(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_sdf_cond self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_sdf_cond" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (char *)TimingArcSet_sdf_cond(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSet_full_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSet_full_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSet_full_name" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      result = (char *)TimingArcSet_full_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_TimingArcSet_methods[] = {
    {"from", _wrap_TimingArcSet_from}, 
    {"to", _wrap_TimingArcSet_to}, 
    {"role", _wrap_TimingArcSet_role}, 
    {"sdf_cond", _wrap_TimingArcSet_sdf_cond}, 
    {"full_name", _wrap_TimingArcSet_full_name}, 
    {0,0}
};
static swig_attribute swig_TimingArcSet_attributes[] = {
    {0,0,0}
};
static swig_class *swig_TimingArcSet_bases[] = {0};
static const char * swig_TimingArcSet_base_names[] = {0};
static swig_class _wrap_class_TimingArcSet = { "TimingArcSet", &SWIGTYPE_p_TimingArcSet,0,0, swig_TimingArcSet_methods, swig_TimingArcSet_attributes, swig_TimingArcSet_bases,swig_TimingArcSet_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LibertyCellTimingArcSetIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCellTimingArcSetIterator *arg1 = (LibertyCellTimingArcSetIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCellTimingArcSetIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCellTimingArcSetIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCellTimingArcSetIterator_has_next" "', argument " "1"" of type '" "LibertyCellTimingArcSetIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCellTimingArcSetIterator * >(argp1);
  {
    try {
      result = (bool)LibertyCellTimingArcSetIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCellTimingArcSetIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCellTimingArcSetIterator *arg1 = (LibertyCellTimingArcSetIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingArcSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCellTimingArcSetIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCellTimingArcSetIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCellTimingArcSetIterator_next" "', argument " "1"" of type '" "LibertyCellTimingArcSetIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCellTimingArcSetIterator * >(argp1);
  {
    try {
      result = (TimingArcSet *)LibertyCellTimingArcSetIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_TimingArcSet,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LibertyCellTimingArcSetIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCellTimingArcSetIterator *arg1 = (LibertyCellTimingArcSetIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LibertyCellTimingArcSetIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCellTimingArcSetIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LibertyCellTimingArcSetIterator_finish" "', argument " "1"" of type '" "LibertyCellTimingArcSetIterator *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCellTimingArcSetIterator * >(argp1);
  {
    try {
      LibertyCellTimingArcSetIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LibertyCellTimingArcSetIterator_methods[] = {
    {"has_next", _wrap_LibertyCellTimingArcSetIterator_has_next}, 
    {"next", _wrap_LibertyCellTimingArcSetIterator_next}, 
    {"finish", _wrap_LibertyCellTimingArcSetIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LibertyCellTimingArcSetIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LibertyCellTimingArcSetIterator_bases[] = {0};
static const char * swig_LibertyCellTimingArcSetIterator_base_names[] = {0};
static swig_class _wrap_class_LibertyCellTimingArcSetIterator = { "LibertyCellTimingArcSetIterator", &SWIGTYPE_p_LibertyCellTimingArcSetIterator,0,0, swig_LibertyCellTimingArcSetIterator_methods, swig_LibertyCellTimingArcSetIterator_attributes, swig_LibertyCellTimingArcSetIterator_bases,swig_LibertyCellTimingArcSetIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_TimingArcSetArcIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSetArcIterator *arg1 = (TimingArcSetArcIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSetArcIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSetArcIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSetArcIterator_has_next" "', argument " "1"" of type '" "TimingArcSetArcIterator *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSetArcIterator * >(argp1);
  {
    try {
      result = (bool)TimingArcSetArcIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSetArcIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSetArcIterator *arg1 = (TimingArcSetArcIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingArc *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSetArcIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSetArcIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSetArcIterator_next" "', argument " "1"" of type '" "TimingArcSetArcIterator *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSetArcIterator * >(argp1);
  {
    try {
      result = (TimingArc *)TimingArcSetArcIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_TimingArc, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArcSetArcIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSetArcIterator *arg1 = (TimingArcSetArcIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArcSetArcIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSetArcIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArcSetArcIterator_finish" "', argument " "1"" of type '" "TimingArcSetArcIterator *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSetArcIterator * >(argp1);
  {
    try {
      TimingArcSetArcIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_TimingArcSetArcIterator_methods[] = {
    {"has_next", _wrap_TimingArcSetArcIterator_has_next}, 
    {"next", _wrap_TimingArcSetArcIterator_next}, 
    {"finish", _wrap_TimingArcSetArcIterator_finish}, 
    {0,0}
};
static swig_attribute swig_TimingArcSetArcIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_TimingArcSetArcIterator_bases[] = {0};
static const char * swig_TimingArcSetArcIterator_base_names[] = {0};
static swig_class _wrap_class_TimingArcSetArcIterator = { "TimingArcSetArcIterator", &SWIGTYPE_p_TimingArcSetArcIterator,0,0, swig_TimingArcSetArcIterator_methods, swig_TimingArcSetArcIterator_attributes, swig_TimingArcSetArcIterator_bases,swig_TimingArcSetArcIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_TimingArc_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_from self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_from" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (LibertyPort *)TimingArc_from(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_to self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_to" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (LibertyPort *)TimingArc_to(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_from_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Transition *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_from_edge self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_from_edge" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (Transition *)TimingArc_from_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Transition *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_from_edge_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_from_edge_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_from_edge_name" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (char *)TimingArc_from_edge_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_to_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Transition *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_to_edge self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_to_edge" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (Transition *)TimingArc_to_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Transition *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_to_edge_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_to_edge_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_to_edge_name" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (char *)TimingArc_to_edge_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_TimingArc_role(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArc *arg1 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingRole *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::TimingArc_role self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "TimingArc_role" "', argument " "1"" of type '" "TimingArc *""'"); 
  }
  arg1 = reinterpret_cast< TimingArc * >(argp1);
  {
    try {
      result = (TimingRole *)TimingArc_role(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_TimingArc_methods[] = {
    {"from", _wrap_TimingArc_from}, 
    {"to", _wrap_TimingArc_to}, 
    {"from_edge", _wrap_TimingArc_from_edge}, 
    {"from_edge_name", _wrap_TimingArc_from_edge_name}, 
    {"to_edge", _wrap_TimingArc_to_edge}, 
    {"to_edge_name", _wrap_TimingArc_to_edge_name}, 
    {"role", _wrap_TimingArc_role}, 
    {0,0}
};
static swig_attribute swig_TimingArc_attributes[] = {
    {0,0,0}
};
static swig_class *swig_TimingArc_bases[] = {0};
static const char * swig_TimingArc_base_names[] = {0};
static swig_class _wrap_class_TimingArc = { "TimingArc", &SWIGTYPE_p_TimingArc,0,0, swig_TimingArc_methods, swig_TimingArc_attributes, swig_TimingArc_bases,swig_TimingArc_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_Wireload_methods[] = {
    {0,0}
};
static swig_attribute swig_Wireload_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Wireload_bases[] = {0};
static const char * swig_Wireload_base_names[] = {0};
static swig_class _wrap_class_Wireload = { "Wireload", &SWIGTYPE_p_Wireload,0,0, swig_Wireload_methods, swig_Wireload_attributes, swig_Wireload_bases,swig_Wireload_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_WireloadSelection_methods[] = {
    {0,0}
};
static swig_attribute swig_WireloadSelection_attributes[] = {
    {0,0,0}
};
static swig_class *swig_WireloadSelection_bases[] = {0};
static const char * swig_WireloadSelection_base_names[] = {0};
static swig_class _wrap_class_WireloadSelection = { "WireloadSelection", &SWIGTYPE_p_WireloadSelection,0,0, swig_WireloadSelection_methods, swig_WireloadSelection_attributes, swig_WireloadSelection_bases,swig_WireloadSelection_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_Transition_methods[] = {
    {0,0}
};
static swig_attribute swig_Transition_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Transition_bases[] = {0};
static const char * swig_Transition_base_names[] = {0};
static swig_class _wrap_class_Transition = { "Transition", &SWIGTYPE_p_Transition,0,0, swig_Transition_methods, swig_Transition_attributes, swig_Transition_bases,swig_Transition_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Instance_parent(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_parent self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_parent" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (Instance *)Instance_parent(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Cell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_cell" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (Cell *)Instance_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Cell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_liberty_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_liberty_cell self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_liberty_cell" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (LibertyCell *)Instance_liberty_cell(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCell, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_is_leaf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_is_leaf self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_is_leaf" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (bool)Instance_is_leaf(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_child_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  InstanceChildIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_child_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_child_iterator" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (InstanceChildIterator *)Instance_child_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_InstanceChildIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_pin_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  InstancePinIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_pin_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_pin_iterator" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (InstancePinIterator *)Instance_pin_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_InstancePinIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_net_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  InstanceNetIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Instance_net_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_net_iterator" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (InstanceNetIterator *)Instance_net_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_InstanceNetIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Instance_find_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Instance_find_pin self name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Instance_find_pin" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Instance_find_pin" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (Pin *)Instance_find_pin(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


static swig_method swig_Instance_methods[] = {
    {"parent", _wrap_Instance_parent}, 
    {"cell", _wrap_Instance_cell}, 
    {"liberty_cell", _wrap_Instance_liberty_cell}, 
    {"is_leaf", _wrap_Instance_is_leaf}, 
    {"child_iterator", _wrap_Instance_child_iterator}, 
    {"pin_iterator", _wrap_Instance_pin_iterator}, 
    {"net_iterator", _wrap_Instance_net_iterator}, 
    {"find_pin", _wrap_Instance_find_pin}, 
    {0,0}
};
static swig_attribute swig_Instance_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Instance_bases[] = {0};
static const char * swig_Instance_base_names[] = {0};
static swig_class _wrap_class_Instance = { "Instance", &SWIGTYPE_p_Instance,0,0, swig_Instance_methods, swig_Instance_attributes, swig_Instance_bases,swig_Instance_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Pin_port_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_port_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_port_name" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char *)Pin_port_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_instance self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_instance" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Instance *)Pin_instance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_net self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_net" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Net *)Pin_net(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Port *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_port self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_port" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Port *)Pin_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Port, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_term(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Term *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_term self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_term" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Term *)Pin_term(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Term,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_liberty_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyPort *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_liberty_port self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_liberty_port" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (LibertyPort *)Pin_liberty_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyPort, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_driver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_driver self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_driver" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_driver(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_load(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_load self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_load" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_load(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_leaf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_leaf self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_leaf" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_leaf(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_hierarchical(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_hierarchical self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_hierarchical" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_hierarchical(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_is_top_level_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_is_top_level_port self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_is_top_level_port" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)Pin_is_top_level_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_connected_pin_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PinConnectedPinIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_connected_pin_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_connected_pin_iterator" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (PinConnectedPinIterator *)Pin_connected_pin_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj=SWIG_NewInstanceObj(result, SWIGTYPE_p_PinConnectedPinIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_vertices(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex **result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Pin_vertices self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_vertices" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (Vertex **)Pin_vertices(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    int i = 0;
    Tcl_ResetResult(interp);
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    while (result[i]) {
      Tcl_Obj *obj = SWIG_NewInstanceObj(result[i], SWIGTYPE_p_Vertex,false);
      Tcl_ListObjAppendElement(interp, list, obj);
      i++;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Pin_capacitance self rf corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_capacitance" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pin_capacitance" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Pin_capacitance(arg1,(RiseFall const *)arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_pin_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Pin_pin_capacitance self rf corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_pin_capacitance" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pin_pin_capacitance" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Pin_pin_capacitance(arg1,(RiseFall const *)arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Pin_wire_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Pin_wire_capacitance self rf corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Pin_wire_capacitance" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Pin_wire_capacitance" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Pin_wire_capacitance(arg1,(RiseFall const *)arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Pin_methods[] = {
    {"port_name", _wrap_Pin_port_name}, 
    {"instance", _wrap_Pin_instance}, 
    {"net", _wrap_Pin_net}, 
    {"port", _wrap_Pin_port}, 
    {"term", _wrap_Pin_term}, 
    {"liberty_port", _wrap_Pin_liberty_port}, 
    {"is_driver", _wrap_Pin_is_driver}, 
    {"is_load", _wrap_Pin_is_load}, 
    {"is_leaf", _wrap_Pin_is_leaf}, 
    {"is_hierarchical", _wrap_Pin_is_hierarchical}, 
    {"is_top_level_port", _wrap_Pin_is_top_level_port}, 
    {"connected_pin_iterator", _wrap_Pin_connected_pin_iterator}, 
    {"vertices", _wrap_Pin_vertices}, 
    {"capacitance", _wrap_Pin_capacitance}, 
    {"pin_capacitance", _wrap_Pin_pin_capacitance}, 
    {"wire_capacitance", _wrap_Pin_wire_capacitance}, 
    {0,0}
};
static swig_attribute swig_Pin_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Pin_bases[] = {0};
static const char * swig_Pin_base_names[] = {0};
static swig_class _wrap_class_Pin = { "Pin", &SWIGTYPE_p_Pin,0,0, swig_Pin_methods, swig_Pin_attributes, swig_Pin_bases,swig_Pin_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Term_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Term *arg1 = (Term *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Term_net self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Term, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Term_net" "', argument " "1"" of type '" "Term *""'"); 
  }
  arg1 = reinterpret_cast< Term * >(argp1);
  {
    try {
      result = (Net *)Term_net(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Term_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Term *arg1 = (Term *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Term_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Term, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Term_pin" "', argument " "1"" of type '" "Term *""'"); 
  }
  arg1 = reinterpret_cast< Term * >(argp1);
  {
    try {
      result = (Pin *)Term_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Term_methods[] = {
    {"net", _wrap_Term_net}, 
    {"pin", _wrap_Term_pin}, 
    {0,0}
};
static swig_attribute swig_Term_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Term_bases[] = {0};
static const char * swig_Term_base_names[] = {0};
static swig_class _wrap_class_Term = { "Term", &SWIGTYPE_p_Term,0,0, swig_Term_methods, swig_Term_attributes, swig_Term_bases,swig_Term_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_InstanceChildIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  InstanceChildIterator *arg1 = (InstanceChildIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceChildIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceChildIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceChildIterator_has_next" "', argument " "1"" of type '" "InstanceChildIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceChildIterator * >(argp1);
  {
    try {
      result = (bool)InstanceChildIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstanceChildIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  InstanceChildIterator *arg1 = (InstanceChildIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceChildIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceChildIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceChildIterator_next" "', argument " "1"" of type '" "InstanceChildIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceChildIterator * >(argp1);
  {
    try {
      result = (Instance *)InstanceChildIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstanceChildIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  InstanceChildIterator *arg1 = (InstanceChildIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceChildIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceChildIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceChildIterator_finish" "', argument " "1"" of type '" "InstanceChildIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceChildIterator * >(argp1);
  {
    try {
      InstanceChildIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_InstanceChildIterator_methods[] = {
    {"has_next", _wrap_InstanceChildIterator_has_next}, 
    {"next", _wrap_InstanceChildIterator_next}, 
    {"finish", _wrap_InstanceChildIterator_finish}, 
    {0,0}
};
static swig_attribute swig_InstanceChildIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_InstanceChildIterator_bases[] = {0};
static const char * swig_InstanceChildIterator_base_names[] = {0};
static swig_class _wrap_class_InstanceChildIterator = { "InstanceChildIterator", &SWIGTYPE_p_InstanceChildIterator,0,0, swig_InstanceChildIterator_methods, swig_InstanceChildIterator_attributes, swig_InstanceChildIterator_bases,swig_InstanceChildIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_InstancePinIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  InstancePinIterator *arg1 = (InstancePinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstancePinIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstancePinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstancePinIterator_has_next" "', argument " "1"" of type '" "InstancePinIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstancePinIterator * >(argp1);
  {
    try {
      result = (bool)InstancePinIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstancePinIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  InstancePinIterator *arg1 = (InstancePinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstancePinIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstancePinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstancePinIterator_next" "', argument " "1"" of type '" "InstancePinIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstancePinIterator * >(argp1);
  {
    try {
      result = (Pin *)InstancePinIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstancePinIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  InstancePinIterator *arg1 = (InstancePinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstancePinIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstancePinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstancePinIterator_finish" "', argument " "1"" of type '" "InstancePinIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstancePinIterator * >(argp1);
  {
    try {
      InstancePinIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_InstancePinIterator_methods[] = {
    {"has_next", _wrap_InstancePinIterator_has_next}, 
    {"next", _wrap_InstancePinIterator_next}, 
    {"finish", _wrap_InstancePinIterator_finish}, 
    {0,0}
};
static swig_attribute swig_InstancePinIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_InstancePinIterator_bases[] = {0};
static const char * swig_InstancePinIterator_base_names[] = {0};
static swig_class _wrap_class_InstancePinIterator = { "InstancePinIterator", &SWIGTYPE_p_InstancePinIterator,0,0, swig_InstancePinIterator_methods, swig_InstancePinIterator_attributes, swig_InstancePinIterator_bases,swig_InstancePinIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_InstanceNetIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  InstanceNetIterator *arg1 = (InstanceNetIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceNetIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceNetIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceNetIterator_has_next" "', argument " "1"" of type '" "InstanceNetIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceNetIterator * >(argp1);
  {
    try {
      result = (bool)InstanceNetIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstanceNetIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  InstanceNetIterator *arg1 = (InstanceNetIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceNetIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceNetIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceNetIterator_next" "', argument " "1"" of type '" "InstanceNetIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceNetIterator * >(argp1);
  {
    try {
      result = (Net *)InstanceNetIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_InstanceNetIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  InstanceNetIterator *arg1 = (InstanceNetIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::InstanceNetIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_InstanceNetIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "InstanceNetIterator_finish" "', argument " "1"" of type '" "InstanceNetIterator *""'"); 
  }
  arg1 = reinterpret_cast< InstanceNetIterator * >(argp1);
  {
    try {
      InstanceNetIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_InstanceNetIterator_methods[] = {
    {"has_next", _wrap_InstanceNetIterator_has_next}, 
    {"next", _wrap_InstanceNetIterator_next}, 
    {"finish", _wrap_InstanceNetIterator_finish}, 
    {0,0}
};
static swig_attribute swig_InstanceNetIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_InstanceNetIterator_bases[] = {0};
static const char * swig_InstanceNetIterator_base_names[] = {0};
static swig_class _wrap_class_InstanceNetIterator = { "InstanceNetIterator", &SWIGTYPE_p_InstanceNetIterator,0,0, swig_InstanceNetIterator_methods, swig_InstanceNetIterator_attributes, swig_InstanceNetIterator_bases,swig_InstanceNetIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_LeafInstanceIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LeafInstanceIterator *arg1 = (LeafInstanceIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LeafInstanceIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LeafInstanceIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LeafInstanceIterator_has_next" "', argument " "1"" of type '" "LeafInstanceIterator *""'"); 
  }
  arg1 = reinterpret_cast< LeafInstanceIterator * >(argp1);
  {
    try {
      result = (bool)LeafInstanceIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LeafInstanceIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LeafInstanceIterator *arg1 = (LeafInstanceIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LeafInstanceIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LeafInstanceIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LeafInstanceIterator_next" "', argument " "1"" of type '" "LeafInstanceIterator *""'"); 
  }
  arg1 = reinterpret_cast< LeafInstanceIterator * >(argp1);
  {
    try {
      result = (Instance *)LeafInstanceIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_LeafInstanceIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LeafInstanceIterator *arg1 = (LeafInstanceIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::LeafInstanceIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LeafInstanceIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "LeafInstanceIterator_finish" "', argument " "1"" of type '" "LeafInstanceIterator *""'"); 
  }
  arg1 = reinterpret_cast< LeafInstanceIterator * >(argp1);
  {
    try {
      LeafInstanceIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_LeafInstanceIterator_methods[] = {
    {"has_next", _wrap_LeafInstanceIterator_has_next}, 
    {"next", _wrap_LeafInstanceIterator_next}, 
    {"finish", _wrap_LeafInstanceIterator_finish}, 
    {0,0}
};
static swig_attribute swig_LeafInstanceIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_LeafInstanceIterator_bases[] = {0};
static const char * swig_LeafInstanceIterator_base_names[] = {0};
static swig_class _wrap_class_LeafInstanceIterator = { "LeafInstanceIterator", &SWIGTYPE_p_LeafInstanceIterator,0,0, swig_LeafInstanceIterator_methods, swig_LeafInstanceIterator_attributes, swig_LeafInstanceIterator_bases,swig_LeafInstanceIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Net_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_instance self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_instance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (Instance *)Net_instance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_highest_connected_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_highest_connected_net self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_highest_connected_net" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (Net *)Net_highest_connected_net(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_pin_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  NetPinIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_pin_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_pin_iterator" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (NetPinIterator *)Net_pin_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_NetPinIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_term_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  NetTermIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_term_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_term_iterator" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (NetTermIterator *)Net_term_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_NetTermIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_connected_pin_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  NetConnectedPinIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_connected_pin_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_connected_pin_iterator" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (NetConnectedPinIterator *)Net_connected_pin_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj=SWIG_NewInstanceObj(result, SWIGTYPE_p_NetConnectedPinIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_is_power(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_is_power self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_is_power" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (bool)Net_is_power(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_is_ground(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_is_ground self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_is_ground" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (bool)Net_is_ground(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Net_capacitance self corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_capacitance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Net_capacitance" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Net_capacitance(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_pin_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Net_pin_capacitance self corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_pin_capacitance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Net_pin_capacitance" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Net_pin_capacitance(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_wire_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Net_wire_capacitance self corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_wire_capacitance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Net_wire_capacitance" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Net_wire_capacitance(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Net_ports(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TmpPortSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Net_ports self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Net_ports" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (TmpPortSeq *)Net_ports(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    TmpPortSeq *ports = result;
    TmpPortSeq::Iterator port_iter(ports);
    while (port_iter.hasNext()) {
      Port *port = port_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(port, SWIGTYPE_p_Port, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete ports;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Net_methods[] = {
    {"instance", _wrap_Net_instance}, 
    {"highest_connected_net", _wrap_Net_highest_connected_net}, 
    {"pin_iterator", _wrap_Net_pin_iterator}, 
    {"term_iterator", _wrap_Net_term_iterator}, 
    {"connected_pin_iterator", _wrap_Net_connected_pin_iterator}, 
    {"is_power", _wrap_Net_is_power}, 
    {"is_ground", _wrap_Net_is_ground}, 
    {"capacitance", _wrap_Net_capacitance}, 
    {"pin_capacitance", _wrap_Net_pin_capacitance}, 
    {"wire_capacitance", _wrap_Net_wire_capacitance}, 
    {"ports", _wrap_Net_ports}, 
    {0,0}
};
static swig_attribute swig_Net_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Net_bases[] = {0};
static const char * swig_Net_base_names[] = {0};
static swig_class _wrap_class_Net = { "Net", &SWIGTYPE_p_Net,0,0, swig_Net_methods, swig_Net_attributes, swig_Net_bases,swig_Net_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_NetPinIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  NetPinIterator *arg1 = (NetPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetPinIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetPinIterator_has_next" "', argument " "1"" of type '" "NetPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetPinIterator * >(argp1);
  {
    try {
      result = (bool)NetPinIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetPinIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  NetPinIterator *arg1 = (NetPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetPinIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetPinIterator_next" "', argument " "1"" of type '" "NetPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetPinIterator * >(argp1);
  {
    try {
      result = (Pin *)NetPinIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetPinIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  NetPinIterator *arg1 = (NetPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetPinIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetPinIterator_finish" "', argument " "1"" of type '" "NetPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetPinIterator * >(argp1);
  {
    try {
      NetPinIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_NetPinIterator_methods[] = {
    {"has_next", _wrap_NetPinIterator_has_next}, 
    {"next", _wrap_NetPinIterator_next}, 
    {"finish", _wrap_NetPinIterator_finish}, 
    {0,0}
};
static swig_attribute swig_NetPinIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_NetPinIterator_bases[] = {0};
static const char * swig_NetPinIterator_base_names[] = {0};
static swig_class _wrap_class_NetPinIterator = { "NetPinIterator", &SWIGTYPE_p_NetPinIterator,0,0, swig_NetPinIterator_methods, swig_NetPinIterator_attributes, swig_NetPinIterator_bases,swig_NetPinIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_NetTermIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  NetTermIterator *arg1 = (NetTermIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetTermIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetTermIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetTermIterator_has_next" "', argument " "1"" of type '" "NetTermIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetTermIterator * >(argp1);
  {
    try {
      result = (bool)NetTermIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetTermIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  NetTermIterator *arg1 = (NetTermIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Term *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetTermIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetTermIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetTermIterator_next" "', argument " "1"" of type '" "NetTermIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetTermIterator * >(argp1);
  {
    try {
      result = (Term *)NetTermIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Term,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetTermIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  NetTermIterator *arg1 = (NetTermIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetTermIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetTermIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetTermIterator_finish" "', argument " "1"" of type '" "NetTermIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetTermIterator * >(argp1);
  {
    try {
      NetTermIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_NetTermIterator_methods[] = {
    {"has_next", _wrap_NetTermIterator_has_next}, 
    {"next", _wrap_NetTermIterator_next}, 
    {"finish", _wrap_NetTermIterator_finish}, 
    {0,0}
};
static swig_attribute swig_NetTermIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_NetTermIterator_bases[] = {0};
static const char * swig_NetTermIterator_base_names[] = {0};
static swig_class _wrap_class_NetTermIterator = { "NetTermIterator", &SWIGTYPE_p_NetTermIterator,0,0, swig_NetTermIterator_methods, swig_NetTermIterator_attributes, swig_NetTermIterator_bases,swig_NetTermIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_NetConnectedPinIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  NetConnectedPinIterator *arg1 = (NetConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetConnectedPinIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetConnectedPinIterator_has_next" "', argument " "1"" of type '" "NetConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetConnectedPinIterator * >(argp1);
  {
    try {
      result = (bool)NetConnectedPinIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetConnectedPinIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  NetConnectedPinIterator *arg1 = (NetConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetConnectedPinIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetConnectedPinIterator_next" "', argument " "1"" of type '" "NetConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetConnectedPinIterator * >(argp1);
  {
    try {
      result = (Pin *)NetConnectedPinIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_NetConnectedPinIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  NetConnectedPinIterator *arg1 = (NetConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::NetConnectedPinIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_NetConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "NetConnectedPinIterator_finish" "', argument " "1"" of type '" "NetConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< NetConnectedPinIterator * >(argp1);
  {
    try {
      NetConnectedPinIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_NetConnectedPinIterator_methods[] = {
    {"has_next", _wrap_NetConnectedPinIterator_has_next}, 
    {"next", _wrap_NetConnectedPinIterator_next}, 
    {"finish", _wrap_NetConnectedPinIterator_finish}, 
    {0,0}
};
static swig_attribute swig_NetConnectedPinIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_NetConnectedPinIterator_bases[] = {0};
static const char * swig_NetConnectedPinIterator_base_names[] = {0};
static swig_class _wrap_class_NetConnectedPinIterator = { "NetConnectedPinIterator", &SWIGTYPE_p_NetConnectedPinIterator,0,0, swig_NetConnectedPinIterator_methods, swig_NetConnectedPinIterator_attributes, swig_NetConnectedPinIterator_bases,swig_NetConnectedPinIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_PinConnectedPinIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinConnectedPinIterator *arg1 = (PinConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PinConnectedPinIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PinConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PinConnectedPinIterator_has_next" "', argument " "1"" of type '" "PinConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< PinConnectedPinIterator * >(argp1);
  {
    try {
      result = (bool)PinConnectedPinIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PinConnectedPinIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinConnectedPinIterator *arg1 = (PinConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PinConnectedPinIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PinConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PinConnectedPinIterator_next" "', argument " "1"" of type '" "PinConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< PinConnectedPinIterator * >(argp1);
  {
    try {
      result = (Pin *)PinConnectedPinIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PinConnectedPinIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinConnectedPinIterator *arg1 = (PinConnectedPinIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PinConnectedPinIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PinConnectedPinIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PinConnectedPinIterator_finish" "', argument " "1"" of type '" "PinConnectedPinIterator *""'"); 
  }
  arg1 = reinterpret_cast< PinConnectedPinIterator * >(argp1);
  {
    try {
      PinConnectedPinIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_PinConnectedPinIterator_methods[] = {
    {"has_next", _wrap_PinConnectedPinIterator_has_next}, 
    {"next", _wrap_PinConnectedPinIterator_next}, 
    {"finish", _wrap_PinConnectedPinIterator_finish}, 
    {0,0}
};
static swig_attribute swig_PinConnectedPinIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PinConnectedPinIterator_bases[] = {0};
static const char * swig_PinConnectedPinIterator_base_names[] = {0};
static swig_class _wrap_class_PinConnectedPinIterator = { "PinConnectedPinIterator", &SWIGTYPE_p_PinConnectedPinIterator,0,0, swig_PinConnectedPinIterator_methods, swig_PinConnectedPinIterator_attributes, swig_PinConnectedPinIterator_bases,swig_PinConnectedPinIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Clock_period(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_period self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_period" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (float)Clock_period(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_waveform(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  FloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_waveform self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_waveform" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (FloatSeq *)Clock_waveform(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (unsigned i = 0; i < floats->size(); i++) {
        Tcl_Obj *obj = Tcl_NewDoubleObj((*floats)[i]);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Clock_time self rf ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_time" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    try {
      result = (float)Clock_time(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_is_generated(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_is_generated self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_is_generated" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (bool)Clock_is_generated(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_waveform_valid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_waveform_valid self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_waveform_valid" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (bool)Clock_waveform_valid(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_is_virtual(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_is_virtual self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_is_virtual" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (bool)Clock_is_virtual(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_is_propagated(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_is_propagated self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_is_propagated" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (bool)Clock_is_propagated(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_sources(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Clock_sources self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_sources" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      result = (PinSet *) &Clock_sources(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    const PinSet *pins = result;
    if (pins) {
      PinSet::ConstIterator pin_iter(pins);
      while (pin_iter.hasNext()) {
        Pin *pin = pin_iter.next();
        Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Clock_slew(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Clock_slew self rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Clock_slew" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Clock_slew(arg1,(RiseFall const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Clock_methods[] = {
    {"period", _wrap_Clock_period}, 
    {"waveform", _wrap_Clock_waveform}, 
    {"time", _wrap_Clock_time}, 
    {"is_generated", _wrap_Clock_is_generated}, 
    {"waveform_valid", _wrap_Clock_waveform_valid}, 
    {"is_virtual", _wrap_Clock_is_virtual}, 
    {"is_propagated", _wrap_Clock_is_propagated}, 
    {"sources", _wrap_Clock_sources}, 
    {"slew", _wrap_Clock_slew}, 
    {0,0}
};
static swig_attribute swig_Clock_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Clock_bases[] = {0};
static const char * swig_Clock_base_names[] = {0};
static swig_class _wrap_class_Clock = { "Clock", &SWIGTYPE_p_Clock,0,0, swig_Clock_methods, swig_Clock_attributes, swig_Clock_bases,swig_Clock_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_ClockIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockIterator *arg1 = (ClockIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::ClockIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClockIterator_has_next" "', argument " "1"" of type '" "ClockIterator *""'"); 
  }
  arg1 = reinterpret_cast< ClockIterator * >(argp1);
  {
    try {
      result = (bool)ClockIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_ClockIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockIterator *arg1 = (ClockIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Clock *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::ClockIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClockIterator_next" "', argument " "1"" of type '" "ClockIterator *""'"); 
  }
  arg1 = reinterpret_cast< ClockIterator * >(argp1);
  {
    try {
      result = (Clock *)ClockIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Clock, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_ClockIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockIterator *arg1 = (ClockIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::ClockIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClockIterator_finish" "', argument " "1"" of type '" "ClockIterator *""'"); 
  }
  arg1 = reinterpret_cast< ClockIterator * >(argp1);
  {
    try {
      ClockIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_ClockIterator_methods[] = {
    {"has_next", _wrap_ClockIterator_has_next}, 
    {"next", _wrap_ClockIterator_next}, 
    {"finish", _wrap_ClockIterator_finish}, 
    {0,0}
};
static swig_attribute swig_ClockIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_ClockIterator_bases[] = {0};
static const char * swig_ClockIterator_base_names[] = {0};
static swig_class _wrap_class_ClockIterator = { "ClockIterator", &SWIGTYPE_p_ClockIterator,0,0, swig_ClockIterator_methods, swig_ClockIterator_attributes, swig_ClockIterator_bases,swig_ClockIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_ClockEdge_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockEdge *arg1 = (ClockEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Clock *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::ClockEdge_clock self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClockEdge_clock" "', argument " "1"" of type '" "ClockEdge *""'"); 
  }
  arg1 = reinterpret_cast< ClockEdge * >(argp1);
  {
    try {
      result = (Clock *)ClockEdge_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Clock, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_ClockEdge_transition(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockEdge *arg1 = (ClockEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RiseFall *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::ClockEdge_transition self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClockEdge_transition" "', argument " "1"" of type '" "ClockEdge *""'"); 
  }
  arg1 = reinterpret_cast< ClockEdge * >(argp1);
  {
    try {
      result = (RiseFall *)ClockEdge_transition(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    const RiseFall *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_ClockEdge_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockEdge *arg1 = (ClockEdge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::ClockEdge_time self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockEdge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "ClockEdge_time" "', argument " "1"" of type '" "ClockEdge *""'"); 
  }
  arg1 = reinterpret_cast< ClockEdge * >(argp1);
  {
    try {
      result = (float)ClockEdge_time(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_ClockEdge_methods[] = {
    {"clock", _wrap_ClockEdge_clock}, 
    {"transition", _wrap_ClockEdge_transition}, 
    {"time", _wrap_ClockEdge_time}, 
    {0,0}
};
static swig_attribute swig_ClockEdge_attributes[] = {
    {0,0,0}
};
static swig_class *swig_ClockEdge_bases[] = {0};
static const char * swig_ClockEdge_base_names[] = {0};
static swig_class _wrap_class_ClockEdge = { "ClockEdge", &SWIGTYPE_p_ClockEdge,0,0, swig_ClockEdge_methods, swig_ClockEdge_attributes, swig_ClockEdge_bases,swig_ClockEdge_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Vertex_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_pin" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (Pin *)Vertex_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_is_bidirect_driver(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_is_bidirect_driver self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_is_bidirect_driver" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (bool)Vertex_is_bidirect_driver(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_level(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_level self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_level" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (int)Vertex_level(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_tag_group_index(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_tag_group_index self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_tag_group_index" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (int)Vertex_tag_group_index(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slew(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slew result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Vertex_slew self rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slew" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = Vertex_slew(arg1,(RiseFall const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slew_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Slew result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Vertex_slew_corner self rf corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slew_corner" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_slew_corner" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = Vertex_slew_corner(arg1,(RiseFall const *)arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_out_edge_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VertexOutEdgeIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_out_edge_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_out_edge_iterator" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (VertexOutEdgeIterator *)Vertex_out_edge_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_VertexOutEdgeIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_in_edge_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VertexInEdgeIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_in_edge_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_in_edge_iterator" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (VertexInEdgeIterator *)Vertex_in_edge_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_VertexInEdgeIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_arrivals_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  TmpFloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Vertex_arrivals_clk self rf clk clk_rf ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_arrivals_clk" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_arrivals_clk" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    try {
      result = (TmpFloatSeq *)Vertex_arrivals_clk(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (unsigned i = 0; i < floats->size(); i++) {
        Tcl_Obj *obj = Tcl_NewDoubleObj((*floats)[i]);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
      delete floats;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_arrivals_clk_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  TmpStringSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::Vertex_arrivals_clk_delays self rf clk clk_rf digits ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_arrivals_clk_delays" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_arrivals_clk_delays" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Vertex_arrivals_clk_delays" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = (TmpStringSeq *)Vertex_arrivals_clk_delays(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq *strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    StringSeq::Iterator str_iter(strs);
    while (str_iter.hasNext()) {
      const char *str = str_iter.next();
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
    delete strs;
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_requireds_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  TmpFloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Vertex_requireds_clk self rf clk clk_rf ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_requireds_clk" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_requireds_clk" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    try {
      result = (TmpFloatSeq *)Vertex_requireds_clk(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (unsigned i = 0; i < floats->size(); i++) {
        Tcl_Obj *obj = Tcl_NewDoubleObj((*floats)[i]);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
      delete floats;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_requireds_clk_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  TmpStringSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::Vertex_requireds_clk_delays self rf clk clk_rf digits ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_requireds_clk_delays" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_requireds_clk_delays" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Vertex_requireds_clk_delays" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = (TmpStringSeq *)Vertex_requireds_clk_delays(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq *strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    StringSeq::Iterator str_iter(strs);
    while (str_iter.hasNext()) {
      const char *str = str_iter.next();
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
    delete strs;
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Vertex_slack self min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slack" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = Vertex_slack(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slacks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TmpFloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Vertex_slacks self rf ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slacks" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    try {
      result = (TmpFloatSeq *)Vertex_slacks(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (unsigned i = 0; i < floats->size(); i++) {
        Tcl_Obj *obj = Tcl_NewDoubleObj((*floats)[i]);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
      delete floats;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slacks_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  TmpFloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Vertex_slacks_clk self rf clk clk_rf ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slacks_clk" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_slacks_clk" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    try {
      result = (TmpFloatSeq *)Vertex_slacks_clk(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (unsigned i = 0; i < floats->size(); i++) {
        Tcl_Obj *obj = Tcl_NewDoubleObj((*floats)[i]);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
      delete floats;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_slacks_clk_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  TmpStringSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::Vertex_slacks_clk_delays self rf clk clk_rf digits ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_slacks_clk_delays" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Vertex_slacks_clk_delays" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "Vertex_slacks_clk_delays" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = (TmpStringSeq *)Vertex_slacks_clk_delays(arg1,(RiseFall const *)arg2,arg3,(RiseFall const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq *strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    StringSeq::Iterator str_iter(strs);
    while (str_iter.hasNext()) {
      const char *str = str_iter.next();
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
    delete strs;
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_path_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  VertexPathIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Vertex_path_iterator self rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_path_iterator" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (VertexPathIterator *)Vertex_path_iterator(arg1,(RiseFall const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_VertexPathIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_has_downstream_clk_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_has_downstream_clk_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_has_downstream_clk_pin" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (bool)Vertex_has_downstream_clk_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_is_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_is_clock self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_is_clock" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (bool)Vertex_is_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Vertex_is_disabled_constraint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Vertex_is_disabled_constraint self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Vertex_is_disabled_constraint" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      result = (bool)Vertex_is_disabled_constraint(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Vertex_methods[] = {
    {"pin", _wrap_Vertex_pin}, 
    {"is_bidirect_driver", _wrap_Vertex_is_bidirect_driver}, 
    {"level", _wrap_Vertex_level}, 
    {"tag_group_index", _wrap_Vertex_tag_group_index}, 
    {"slew", _wrap_Vertex_slew}, 
    {"slew_corner", _wrap_Vertex_slew_corner}, 
    {"out_edge_iterator", _wrap_Vertex_out_edge_iterator}, 
    {"in_edge_iterator", _wrap_Vertex_in_edge_iterator}, 
    {"arrivals_clk", _wrap_Vertex_arrivals_clk}, 
    {"arrivals_clk_delays", _wrap_Vertex_arrivals_clk_delays}, 
    {"requireds_clk", _wrap_Vertex_requireds_clk}, 
    {"requireds_clk_delays", _wrap_Vertex_requireds_clk_delays}, 
    {"slack", _wrap_Vertex_slack}, 
    {"slacks", _wrap_Vertex_slacks}, 
    {"slacks_clk", _wrap_Vertex_slacks_clk}, 
    {"slacks_clk_delays", _wrap_Vertex_slacks_clk_delays}, 
    {"path_iterator", _wrap_Vertex_path_iterator}, 
    {"has_downstream_clk_pin", _wrap_Vertex_has_downstream_clk_pin}, 
    {"is_clock", _wrap_Vertex_is_clock}, 
    {"is_disabled_constraint", _wrap_Vertex_is_disabled_constraint}, 
    {0,0}
};
static swig_attribute swig_Vertex_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Vertex_bases[] = {0};
static const char * swig_Vertex_base_names[] = {0};
static swig_class _wrap_class_Vertex = { "Vertex", &SWIGTYPE_p_Vertex,0,0, swig_Vertex_methods, swig_Vertex_attributes, swig_Vertex_bases,swig_Vertex_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Edge_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_from self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_from" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (Vertex *)Edge_from(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_to self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_to" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (Vertex *)Edge_to(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_from_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_from_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_from_pin" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (Pin *)Edge_from_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_to_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_to_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_to_pin" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (Pin *)Edge_to_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_role(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingRole *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_role self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_role" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (TimingRole *)Edge_role(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_sense(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_sense self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_sense" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_sense(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_timing_arc_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingArcSetArcIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_timing_arc_iterator self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_timing_arc_iterator" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (TimingArcSetArcIterator *)Edge_timing_arc_iterator(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj=SWIG_NewInstanceObj(result, SWIGTYPE_p_TimingArcSetArcIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_loop(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_loop self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_loop" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_loop(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_constraint(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_constraint self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_constraint" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_constraint(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_constant(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_constant self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_constant" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_constant(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_cond_default(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_cond_default self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_cond_default" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_cond_default(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_disabled_constant_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_disabled_constant_pins self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_disabled_constant_pins" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (TmpPinSet *)Edge_disabled_constant_pins(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_bidirect_inst_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_bidirect_inst_path self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_bidirect_inst_path" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_bidirect_inst_path(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_bidirect_net_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_bidirect_net_path self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_bidirect_net_path" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_bidirect_net_path(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_is_disabled_preset_clear(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_is_disabled_preset_clear self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_is_disabled_preset_clear" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (bool)Edge_is_disabled_preset_clear(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_sim_timing_sense(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_sim_timing_sense self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_sim_timing_sense" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_sim_timing_sense(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_arc_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  TmpFloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::Edge_arc_delays self arc ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_arc_delays" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Edge_arc_delays" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  {
    try {
      result = (TmpFloatSeq *)Edge_arc_delays(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (unsigned i = 0; i < floats->size(); i++) {
        Tcl_Obj *obj = Tcl_NewDoubleObj((*floats)[i]);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
      delete floats;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_arc_delay_strings(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  TmpStringSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::Edge_arc_delay_strings self arc digits ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_arc_delay_strings" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Edge_arc_delay_strings" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "Edge_arc_delay_strings" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      result = (TmpStringSeq *)Edge_arc_delay_strings(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq *strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    StringSeq::Iterator str_iter(strs);
    while (str_iter.hasNext()) {
      const char *str = str_iter.next();
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
    delete strs;
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_delay_annotated(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Edge_delay_annotated self arc corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_delay_annotated" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Edge_delay_annotated" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Edge_delay_annotated" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (bool)Edge_delay_annotated(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_arc_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::Edge_arc_delay self arc corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_arc_delay" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "Edge_arc_delay" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "Edge_arc_delay" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)Edge_arc_delay(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_cond(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_cond self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_cond" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_cond(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_mode_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_mode_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_mode_name" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_mode_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_mode_value(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_mode_value self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_mode_value" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_mode_value(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_Edge_latch_d_to_q_en(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Edge_latch_d_to_q_en self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Edge_latch_d_to_q_en" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      result = (char *)Edge_latch_d_to_q_en(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Edge_methods[] = {
    {"from", _wrap_Edge_from}, 
    {"to", _wrap_Edge_to}, 
    {"from_pin", _wrap_Edge_from_pin}, 
    {"to_pin", _wrap_Edge_to_pin}, 
    {"role", _wrap_Edge_role}, 
    {"sense", _wrap_Edge_sense}, 
    {"timing_arc_iterator", _wrap_Edge_timing_arc_iterator}, 
    {"is_disabled_loop", _wrap_Edge_is_disabled_loop}, 
    {"is_disabled_constraint", _wrap_Edge_is_disabled_constraint}, 
    {"is_disabled_constant", _wrap_Edge_is_disabled_constant}, 
    {"is_disabled_cond_default", _wrap_Edge_is_disabled_cond_default}, 
    {"disabled_constant_pins", _wrap_Edge_disabled_constant_pins}, 
    {"is_disabled_bidirect_inst_path", _wrap_Edge_is_disabled_bidirect_inst_path}, 
    {"is_disabled_bidirect_net_path", _wrap_Edge_is_disabled_bidirect_net_path}, 
    {"is_disabled_preset_clear", _wrap_Edge_is_disabled_preset_clear}, 
    {"sim_timing_sense", _wrap_Edge_sim_timing_sense}, 
    {"arc_delays", _wrap_Edge_arc_delays}, 
    {"arc_delay_strings", _wrap_Edge_arc_delay_strings}, 
    {"delay_annotated", _wrap_Edge_delay_annotated}, 
    {"arc_delay", _wrap_Edge_arc_delay}, 
    {"cond", _wrap_Edge_cond}, 
    {"mode_name", _wrap_Edge_mode_name}, 
    {"mode_value", _wrap_Edge_mode_value}, 
    {"latch_d_to_q_en", _wrap_Edge_latch_d_to_q_en}, 
    {0,0}
};
static swig_attribute swig_Edge_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Edge_bases[] = {0};
static const char * swig_Edge_base_names[] = {0};
static swig_class _wrap_class_Edge = { "Edge", &SWIGTYPE_p_Edge,0,0, swig_Edge_methods, swig_Edge_attributes, swig_Edge_bases,swig_Edge_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_VertexIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexIterator *arg1 = (VertexIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexIterator_has_next" "', argument " "1"" of type '" "VertexIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexIterator * >(argp1);
  {
    try {
      result = (bool)VertexIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexIterator *arg1 = (VertexIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexIterator_next" "', argument " "1"" of type '" "VertexIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexIterator * >(argp1);
  {
    try {
      result = (Vertex *)VertexIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexIterator *arg1 = (VertexIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexIterator_finish" "', argument " "1"" of type '" "VertexIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexIterator * >(argp1);
  {
    try {
      VertexIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_VertexIterator_methods[] = {
    {"has_next", _wrap_VertexIterator_has_next}, 
    {"next", _wrap_VertexIterator_next}, 
    {"finish", _wrap_VertexIterator_finish}, 
    {0,0}
};
static swig_attribute swig_VertexIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_VertexIterator_bases[] = {0};
static const char * swig_VertexIterator_base_names[] = {0};
static swig_class _wrap_class_VertexIterator = { "VertexIterator", &SWIGTYPE_p_VertexIterator,0,0, swig_VertexIterator_methods, swig_VertexIterator_attributes, swig_VertexIterator_bases,swig_VertexIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_VertexInEdgeIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexInEdgeIterator *arg1 = (VertexInEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexInEdgeIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexInEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexInEdgeIterator_has_next" "', argument " "1"" of type '" "VertexInEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexInEdgeIterator * >(argp1);
  {
    try {
      result = (bool)VertexInEdgeIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexInEdgeIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexInEdgeIterator *arg1 = (VertexInEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Edge *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexInEdgeIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexInEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexInEdgeIterator_next" "', argument " "1"" of type '" "VertexInEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexInEdgeIterator * >(argp1);
  {
    try {
      result = (Edge *)VertexInEdgeIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Edge, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexInEdgeIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexInEdgeIterator *arg1 = (VertexInEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexInEdgeIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexInEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexInEdgeIterator_finish" "', argument " "1"" of type '" "VertexInEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexInEdgeIterator * >(argp1);
  {
    try {
      VertexInEdgeIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_VertexInEdgeIterator_methods[] = {
    {"has_next", _wrap_VertexInEdgeIterator_has_next}, 
    {"next", _wrap_VertexInEdgeIterator_next}, 
    {"finish", _wrap_VertexInEdgeIterator_finish}, 
    {0,0}
};
static swig_attribute swig_VertexInEdgeIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_VertexInEdgeIterator_bases[] = {0};
static const char * swig_VertexInEdgeIterator_base_names[] = {0};
static swig_class _wrap_class_VertexInEdgeIterator = { "VertexInEdgeIterator", &SWIGTYPE_p_VertexInEdgeIterator,0,0, swig_VertexInEdgeIterator_methods, swig_VertexInEdgeIterator_attributes, swig_VertexInEdgeIterator_bases,swig_VertexInEdgeIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_VertexOutEdgeIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexOutEdgeIterator *arg1 = (VertexOutEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexOutEdgeIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexOutEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexOutEdgeIterator_has_next" "', argument " "1"" of type '" "VertexOutEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexOutEdgeIterator * >(argp1);
  {
    try {
      result = (bool)VertexOutEdgeIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexOutEdgeIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexOutEdgeIterator *arg1 = (VertexOutEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Edge *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexOutEdgeIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexOutEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexOutEdgeIterator_next" "', argument " "1"" of type '" "VertexOutEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexOutEdgeIterator * >(argp1);
  {
    try {
      result = (Edge *)VertexOutEdgeIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Edge, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexOutEdgeIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexOutEdgeIterator *arg1 = (VertexOutEdgeIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexOutEdgeIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexOutEdgeIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexOutEdgeIterator_finish" "', argument " "1"" of type '" "VertexOutEdgeIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexOutEdgeIterator * >(argp1);
  {
    try {
      VertexOutEdgeIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_VertexOutEdgeIterator_methods[] = {
    {"has_next", _wrap_VertexOutEdgeIterator_has_next}, 
    {"next", _wrap_VertexOutEdgeIterator_next}, 
    {"finish", _wrap_VertexOutEdgeIterator_finish}, 
    {0,0}
};
static swig_attribute swig_VertexOutEdgeIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_VertexOutEdgeIterator_bases[] = {0};
static const char * swig_VertexOutEdgeIterator_base_names[] = {0};
static swig_class _wrap_class_VertexOutEdgeIterator = { "VertexOutEdgeIterator", &SWIGTYPE_p_VertexOutEdgeIterator,0,0, swig_VertexOutEdgeIterator_methods, swig_VertexOutEdgeIterator_attributes, swig_VertexOutEdgeIterator_bases,swig_VertexOutEdgeIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_PathRef_arrival(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_arrival self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_arrival" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (float)PathRef_arrival(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_required(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_required self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_required" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (float)PathRef_required(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_slack self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_slack" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (float)PathRef_slack(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_pin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_pin" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (Pin *)PathRef_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_tag(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_tag self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_tag" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (char *)PathRef_tag(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathRef_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TmpPinSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathRef_pins self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathRef_pins" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      result = (TmpPinSeq *)PathRef_pins(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSeq *pins = result;
    PinSeq::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_PathRef_methods[] = {
    {"arrival", _wrap_PathRef_arrival}, 
    {"required", _wrap_PathRef_required}, 
    {"slack", _wrap_PathRef_slack}, 
    {"pin", _wrap_PathRef_pin}, 
    {"tag", _wrap_PathRef_tag}, 
    {"pins", _wrap_PathRef_pins}, 
    {0,0}
};
static swig_attribute swig_PathRef_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PathRef_bases[] = {0};
static const char * swig_PathRef_base_names[] = {0};
static swig_class _wrap_class_PathRef = { "PathRef", &SWIGTYPE_p_PathRef,0,0, swig_PathRef_methods, swig_PathRef_attributes, swig_PathRef_bases,swig_PathRef_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_PathEnd_is_unconstrained(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_unconstrained self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_unconstrained" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_unconstrained(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_check self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_check" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_check(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_latch_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_latch_check self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_latch_check" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_latch_check(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_data_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_data_check self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_data_check" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_data_check(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_output_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_output_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_output_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_output_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_path_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_path_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_path_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_path_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_is_gated_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_is_gated_clock self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_is_gated_clock" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_is_gated_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_vertex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_vertex self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_vertex" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (Vertex *)PathEnd_vertex(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_path self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_path" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (PathRef *)PathEnd_path(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_end_transition(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RiseFall *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_end_transition self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_end_transition" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (RiseFall *)PathEnd_end_transition(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    const RiseFall *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_slack self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_slack" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_slack(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_margin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ArcDelay result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_margin self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_margin" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_margin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_data_required_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Required result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_data_required_time self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_data_required_time" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_data_required_time(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_data_arrival_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_data_arrival_time self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_data_arrival_time" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_data_arrival_time(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_check_role(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TimingRole *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_check_role self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_check_role" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (TimingRole *)PathEnd_check_role(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_min_max(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinMax *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_min_max self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_min_max" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (MinMax *)PathEnd_min_max(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetResult(interp, const_cast<char*>(result->asString()), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_source_clk_offset(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_source_clk_offset self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_source_clk_offset" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_source_clk_offset(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_source_clk_latency(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_source_clk_latency self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_source_clk_latency" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_source_clk_latency(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_source_clk_insertion_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_source_clk_insertion_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_source_clk_insertion_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_source_clk_insertion_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Clock *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (Clock *)PathEnd_target_clk(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Clock, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  ClockEdge *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_edge self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_edge" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (ClockEdge *)PathEnd_target_clk_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result,SWIGTYPE_p_ClockEdge, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Path *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_path self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_path" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (Path *)PathEnd_target_clk_path(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Path,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_time self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_time" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_target_clk_time(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_offset(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_offset self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_offset" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_target_clk_offset(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_mcp_adjustment(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_mcp_adjustment self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_mcp_adjustment" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_target_clk_mcp_adjustment(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_target_clk_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_insertion_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_insertion_delay self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_insertion_delay" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_target_clk_insertion_delay(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_uncertainty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_uncertainty self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_uncertainty" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_target_clk_uncertainty(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_inter_clk_uncertainty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_inter_clk_uncertainty self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_inter_clk_uncertainty" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (float)PathEnd_inter_clk_uncertainty(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_arrival(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Arrival result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_arrival self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_arrival" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_target_clk_arrival(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_path_delay_margin_is_external(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_path_delay_margin_is_external self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_path_delay_margin_is_external" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (bool)PathEnd_path_delay_margin_is_external(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_common_clk_pessimism(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Crpr result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_common_clk_pessimism self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_common_clk_pessimism" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = PathEnd_common_clk_pessimism(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_NewInstanceObj((new Crpr(static_cast< const Crpr& >(result))), SWIGTYPE_p_Crpr, SWIG_POINTER_OWN | 0 ));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_PathEnd_target_clk_end_trans(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  RiseFall *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::PathEnd_target_clk_end_trans self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "PathEnd_target_clk_end_trans" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      result = (RiseFall *)PathEnd_target_clk_end_trans(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    const RiseFall *tr = result;
    const char *str = "";
    if (tr)
    str = tr->asString();
    Tcl_SetResult(interp, const_cast<char*>(str), TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_PathEnd_methods[] = {
    {"is_unconstrained", _wrap_PathEnd_is_unconstrained}, 
    {"is_check", _wrap_PathEnd_is_check}, 
    {"is_latch_check", _wrap_PathEnd_is_latch_check}, 
    {"is_data_check", _wrap_PathEnd_is_data_check}, 
    {"is_output_delay", _wrap_PathEnd_is_output_delay}, 
    {"is_path_delay", _wrap_PathEnd_is_path_delay}, 
    {"is_gated_clock", _wrap_PathEnd_is_gated_clock}, 
    {"vertex", _wrap_PathEnd_vertex}, 
    {"path", _wrap_PathEnd_path}, 
    {"end_transition", _wrap_PathEnd_end_transition}, 
    {"slack", _wrap_PathEnd_slack}, 
    {"margin", _wrap_PathEnd_margin}, 
    {"data_required_time", _wrap_PathEnd_data_required_time}, 
    {"data_arrival_time", _wrap_PathEnd_data_arrival_time}, 
    {"check_role", _wrap_PathEnd_check_role}, 
    {"min_max", _wrap_PathEnd_min_max}, 
    {"source_clk_offset", _wrap_PathEnd_source_clk_offset}, 
    {"source_clk_latency", _wrap_PathEnd_source_clk_latency}, 
    {"source_clk_insertion_delay", _wrap_PathEnd_source_clk_insertion_delay}, 
    {"target_clk", _wrap_PathEnd_target_clk}, 
    {"target_clk_edge", _wrap_PathEnd_target_clk_edge}, 
    {"target_clk_path", _wrap_PathEnd_target_clk_path}, 
    {"target_clk_time", _wrap_PathEnd_target_clk_time}, 
    {"target_clk_offset", _wrap_PathEnd_target_clk_offset}, 
    {"target_clk_mcp_adjustment", _wrap_PathEnd_target_clk_mcp_adjustment}, 
    {"target_clk_delay", _wrap_PathEnd_target_clk_delay}, 
    {"target_clk_insertion_delay", _wrap_PathEnd_target_clk_insertion_delay}, 
    {"target_clk_uncertainty", _wrap_PathEnd_target_clk_uncertainty}, 
    {"inter_clk_uncertainty", _wrap_PathEnd_inter_clk_uncertainty}, 
    {"target_clk_arrival", _wrap_PathEnd_target_clk_arrival}, 
    {"path_delay_margin_is_external", _wrap_PathEnd_path_delay_margin_is_external}, 
    {"common_clk_pessimism", _wrap_PathEnd_common_clk_pessimism}, 
    {"target_clk_end_trans", _wrap_PathEnd_target_clk_end_trans}, 
    {0,0}
};
static swig_attribute swig_PathEnd_attributes[] = {
    {0,0,0}
};
static swig_class *swig_PathEnd_bases[] = {0};
static const char * swig_PathEnd_base_names[] = {0};
static swig_class _wrap_class_PathEnd = { "PathEnd", &SWIGTYPE_p_PathEnd,0,0, swig_PathEnd_methods, swig_PathEnd_attributes, swig_PathEnd_bases,swig_PathEnd_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_MinPulseWidthCheck_methods[] = {
    {0,0}
};
static swig_attribute swig_MinPulseWidthCheck_attributes[] = {
    {0,0,0}
};
static swig_class *swig_MinPulseWidthCheck_bases[] = {0};
static const char * swig_MinPulseWidthCheck_base_names[] = {0};
static swig_class _wrap_class_MinPulseWidthCheck = { "MinPulseWidthCheck", &SWIGTYPE_p_MinPulseWidthCheck,0,0, swig_MinPulseWidthCheck_methods, swig_MinPulseWidthCheck_attributes, swig_MinPulseWidthCheck_bases,swig_MinPulseWidthCheck_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_MinPulseWidthCheckSeq_methods[] = {
    {0,0}
};
static swig_attribute swig_MinPulseWidthCheckSeq_attributes[] = {
    {0,0,0}
};
static swig_class *swig_MinPulseWidthCheckSeq_bases[] = {0};
static const char * swig_MinPulseWidthCheckSeq_base_names[] = {0};
static swig_class _wrap_class_MinPulseWidthCheckSeq = { "MinPulseWidthCheckSeq", &SWIGTYPE_p_MinPulseWidthCheckSeq,0,0, swig_MinPulseWidthCheckSeq_methods, swig_MinPulseWidthCheckSeq_attributes, swig_MinPulseWidthCheckSeq_bases,swig_MinPulseWidthCheckSeq_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_MinPulseWidthCheckSeqIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinPulseWidthCheckSeqIterator *arg1 = (MinPulseWidthCheckSeqIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::MinPulseWidthCheckSeqIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheckSeqIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MinPulseWidthCheckSeqIterator_has_next" "', argument " "1"" of type '" "MinPulseWidthCheckSeqIterator *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheckSeqIterator * >(argp1);
  {
    try {
      result = (bool)MinPulseWidthCheckSeqIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_MinPulseWidthCheckSeqIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinPulseWidthCheckSeqIterator *arg1 = (MinPulseWidthCheckSeqIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinPulseWidthCheck *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::MinPulseWidthCheckSeqIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheckSeqIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MinPulseWidthCheckSeqIterator_next" "', argument " "1"" of type '" "MinPulseWidthCheckSeqIterator *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheckSeqIterator * >(argp1);
  {
    try {
      result = (MinPulseWidthCheck *)MinPulseWidthCheckSeqIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheck, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_MinPulseWidthCheckSeqIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinPulseWidthCheckSeqIterator *arg1 = (MinPulseWidthCheckSeqIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::MinPulseWidthCheckSeqIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheckSeqIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "MinPulseWidthCheckSeqIterator_finish" "', argument " "1"" of type '" "MinPulseWidthCheckSeqIterator *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheckSeqIterator * >(argp1);
  {
    try {
      MinPulseWidthCheckSeqIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_MinPulseWidthCheckSeqIterator_methods[] = {
    {"has_next", _wrap_MinPulseWidthCheckSeqIterator_has_next}, 
    {"next", _wrap_MinPulseWidthCheckSeqIterator_next}, 
    {"finish", _wrap_MinPulseWidthCheckSeqIterator_finish}, 
    {0,0}
};
static swig_attribute swig_MinPulseWidthCheckSeqIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_MinPulseWidthCheckSeqIterator_bases[] = {0};
static const char * swig_MinPulseWidthCheckSeqIterator_base_names[] = {0};
static swig_class _wrap_class_MinPulseWidthCheckSeqIterator = { "MinPulseWidthCheckSeqIterator", &SWIGTYPE_p_MinPulseWidthCheckSeqIterator,0,0, swig_MinPulseWidthCheckSeqIterator_methods, swig_MinPulseWidthCheckSeqIterator_attributes, swig_MinPulseWidthCheckSeqIterator_bases,swig_MinPulseWidthCheckSeqIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_VertexPathIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexPathIterator *arg1 = (VertexPathIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexPathIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexPathIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexPathIterator_has_next" "', argument " "1"" of type '" "VertexPathIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexPathIterator * >(argp1);
  {
    try {
      result = (bool)VertexPathIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexPathIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexPathIterator *arg1 = (VertexPathIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexPathIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexPathIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexPathIterator_next" "', argument " "1"" of type '" "VertexPathIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexPathIterator * >(argp1);
  {
    try {
      result = (PathRef *)VertexPathIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_VertexPathIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexPathIterator *arg1 = (VertexPathIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::VertexPathIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_VertexPathIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "VertexPathIterator_finish" "', argument " "1"" of type '" "VertexPathIterator *""'"); 
  }
  arg1 = reinterpret_cast< VertexPathIterator * >(argp1);
  {
    try {
      VertexPathIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_VertexPathIterator_methods[] = {
    {"has_next", _wrap_VertexPathIterator_has_next}, 
    {"next", _wrap_VertexPathIterator_next}, 
    {"finish", _wrap_VertexPathIterator_finish}, 
    {0,0}
};
static swig_attribute swig_VertexPathIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_VertexPathIterator_bases[] = {0};
static const char * swig_VertexPathIterator_base_names[] = {0};
static swig_class _wrap_class_VertexPathIterator = { "VertexPathIterator", &SWIGTYPE_p_VertexPathIterator,0,0, swig_VertexPathIterator_methods, swig_VertexPathIterator_attributes, swig_VertexPathIterator_bases,swig_VertexPathIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_SlowDrvrIterator_has_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SlowDrvrIterator *arg1 = (SlowDrvrIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::SlowDrvrIterator_has_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_SlowDrvrIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SlowDrvrIterator_has_next" "', argument " "1"" of type '" "SlowDrvrIterator *""'"); 
  }
  arg1 = reinterpret_cast< SlowDrvrIterator * >(argp1);
  {
    try {
      result = (bool)SlowDrvrIterator_has_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_SlowDrvrIterator_next(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SlowDrvrIterator *arg1 = (SlowDrvrIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::SlowDrvrIterator_next self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_SlowDrvrIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SlowDrvrIterator_next" "', argument " "1"" of type '" "SlowDrvrIterator *""'"); 
  }
  arg1 = reinterpret_cast< SlowDrvrIterator * >(argp1);
  {
    try {
      result = (Instance *)SlowDrvrIterator_next(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_SlowDrvrIterator_finish(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SlowDrvrIterator *arg1 = (SlowDrvrIterator *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::SlowDrvrIterator_finish self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_SlowDrvrIterator, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "SlowDrvrIterator_finish" "', argument " "1"" of type '" "SlowDrvrIterator *""'"); 
  }
  arg1 = reinterpret_cast< SlowDrvrIterator * >(argp1);
  {
    try {
      SlowDrvrIterator_finish(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_SlowDrvrIterator_methods[] = {
    {"has_next", _wrap_SlowDrvrIterator_has_next}, 
    {"next", _wrap_SlowDrvrIterator_next}, 
    {"finish", _wrap_SlowDrvrIterator_finish}, 
    {0,0}
};
static swig_attribute swig_SlowDrvrIterator_attributes[] = {
    {0,0,0}
};
static swig_class *swig_SlowDrvrIterator_bases[] = {0};
static const char * swig_SlowDrvrIterator_base_names[] = {0};
static swig_class _wrap_class_SlowDrvrIterator = { "SlowDrvrIterator", &SWIGTYPE_p_SlowDrvrIterator,0,0, swig_SlowDrvrIterator_methods, swig_SlowDrvrIterator_attributes, swig_SlowDrvrIterator_bases,swig_SlowDrvrIterator_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_ExceptionFrom_methods[] = {
    {0,0}
};
static swig_attribute swig_ExceptionFrom_attributes[] = {
    {0,0,0}
};
static swig_class *swig_ExceptionFrom_bases[] = {0};
static const char * swig_ExceptionFrom_base_names[] = {0};
static swig_class _wrap_class_ExceptionFrom = { "ExceptionFrom", &SWIGTYPE_p_ExceptionFrom,0,0, swig_ExceptionFrom_methods, swig_ExceptionFrom_attributes, swig_ExceptionFrom_bases,swig_ExceptionFrom_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_ExceptionThru_methods[] = {
    {0,0}
};
static swig_attribute swig_ExceptionThru_attributes[] = {
    {0,0,0}
};
static swig_class *swig_ExceptionThru_bases[] = {0};
static const char * swig_ExceptionThru_base_names[] = {0};
static swig_class _wrap_class_ExceptionThru = { "ExceptionThru", &SWIGTYPE_p_ExceptionThru,0,0, swig_ExceptionThru_methods, swig_ExceptionThru_attributes, swig_ExceptionThru_bases,swig_ExceptionThru_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
static swig_method swig_ExceptionTo_methods[] = {
    {0,0}
};
static swig_attribute swig_ExceptionTo_attributes[] = {
    {0,0,0}
};
static swig_class *swig_ExceptionTo_bases[] = {0};
static const char * swig_ExceptionTo_base_names[] = {0};
static swig_class _wrap_class_ExceptionTo = { "ExceptionTo", &SWIGTYPE_p_ExceptionTo,0,0, swig_ExceptionTo_methods, swig_ExceptionTo_attributes, swig_ExceptionTo_bases,swig_ExceptionTo_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_OperatingConditions_process(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  OperatingConditions *arg1 = (OperatingConditions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::OperatingConditions_process self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OperatingConditions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OperatingConditions_process" "', argument " "1"" of type '" "OperatingConditions *""'"); 
  }
  arg1 = reinterpret_cast< OperatingConditions * >(argp1);
  {
    try {
      result = (float)OperatingConditions_process(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_OperatingConditions_voltage(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  OperatingConditions *arg1 = (OperatingConditions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::OperatingConditions_voltage self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OperatingConditions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OperatingConditions_voltage" "', argument " "1"" of type '" "OperatingConditions *""'"); 
  }
  arg1 = reinterpret_cast< OperatingConditions * >(argp1);
  {
    try {
      result = (float)OperatingConditions_voltage(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_OperatingConditions_temperature(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  OperatingConditions *arg1 = (OperatingConditions *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::OperatingConditions_temperature self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OperatingConditions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "OperatingConditions_temperature" "', argument " "1"" of type '" "OperatingConditions *""'"); 
  }
  arg1 = reinterpret_cast< OperatingConditions * >(argp1);
  {
    try {
      result = (float)OperatingConditions_temperature(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_OperatingConditions_methods[] = {
    {"process", _wrap_OperatingConditions_process}, 
    {"voltage", _wrap_OperatingConditions_voltage}, 
    {"temperature", _wrap_OperatingConditions_temperature}, 
    {0,0}
};
static swig_attribute swig_OperatingConditions_attributes[] = {
    {0,0,0}
};
static swig_class *swig_OperatingConditions_bases[] = {0};
static const char * swig_OperatingConditions_base_names[] = {0};
static swig_class _wrap_class_OperatingConditions = { "OperatingConditions", &SWIGTYPE_p_OperatingConditions,0,0, swig_OperatingConditions_methods, swig_OperatingConditions_attributes, swig_OperatingConditions_bases,swig_OperatingConditions_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_Corner_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::Corner_name self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "Corner_name" "', argument " "1"" of type '" "Corner *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = (char *)Corner_name(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


static swig_method swig_Corner_methods[] = {
    {"name", _wrap_Corner_name}, 
    {0,0}
};
static swig_attribute swig_Corner_attributes[] = {
    {0,0,0}
};
static swig_class *swig_Corner_bases[] = {0};
static const char * swig_Corner_base_names[] = {0};
static swig_class _wrap_class_Corner = { "Corner", &SWIGTYPE_p_Corner,0,0, swig_Corner_methods, swig_Corner_attributes, swig_Corner_bases,swig_Corner_base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN const char *_wrap_float_inf_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2, int flags) {
  Tcl_Obj *value = 0;
  
  value = SWIG_From_float(static_cast< float >(float_inf));
  if (value) {
    Tcl_SetVar2(interp,name1,name2,Tcl_GetStringFromObj(value,NULL), flags);
    Tcl_DecrRefCount(value);
  }
  return NULL;
}


SWIGINTERN const char *_wrap_float_inf_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2 SWIGUNUSED, int flags) {
  Tcl_Obj *value = 0;
  Tcl_Obj *name1o = 0;
  
  name1o = Tcl_NewStringObj(name1,-1);
  value = Tcl_ObjGetVar2(interp, name1o, 0, flags);
  Tcl_DecrRefCount(name1o);
  if (!value) SWIG_fail;
  {
    float val;
    int res = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(value, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""float_inf""' of type '""float""'");
    }
    float_inf = static_cast< float >(val);
  }
  return NULL;
fail:
  return "float_inf";
}


SWIGINTERN const char *_wrap_group_count_max_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2, int flags) {
  Tcl_Obj *value = 0;
  
  value = SWIG_From_int(static_cast< int >(group_count_max));
  if (value) {
    Tcl_SetVar2(interp,name1,name2,Tcl_GetStringFromObj(value,NULL), flags);
    Tcl_DecrRefCount(value);
  }
  return NULL;
}


SWIGINTERN const char *_wrap_group_count_max_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, char *name1, char *name2 SWIGUNUSED, int flags) {
  Tcl_Obj *value = 0;
  Tcl_Obj *name1o = 0;
  
  name1o = Tcl_NewStringObj(name1,-1);
  value = Tcl_ObjGetVar2(interp, name1o, 0, flags);
  Tcl_DecrRefCount(name1o);
  if (!value) SWIG_fail;
  {
    int val;
    int res = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(value, &val);
    if (!SWIG_IsOK(res)) {
      SWIG_exception_fail(SWIG_ArgError(res), "in variable '""group_count_max""' of type '""int""'");
    }
    group_count_max = static_cast< int >(val);
  }
  return NULL;
fail:
  return "group_count_max";
}


SWIGINTERN int
_wrap_version(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::version ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)version(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_git_sha1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::git_sha1 ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)git_sha1(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_error(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_error id msg ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_error" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_error" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      report_error(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_file_error(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::report_file_error id filename line msg ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_file_error" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_file_error" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_file_error" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "report_file_error" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  {
    try {
      report_file_error(arg1,(char const *)arg2,arg3,(char const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_warn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_warn id msg ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_warn" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_warn" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      report_warn(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_file_warn(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int arg1 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  char *arg4 = (char *) 0 ;
  int val1 ;
  int ecode1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::report_file_warn id filename line msg ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_file_warn" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_file_warn" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_file_warn" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "report_file_warn" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  {
    try {
      report_file_warn(arg1,(char const *)arg2,arg3,(char const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_line(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::report_line msg ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_line" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      report_line((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_fflush(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::fflush ") == TCL_ERROR) SWIG_fail;
  {
    try {
      fflush(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_file_begin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::redirect_file_begin filename ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "redirect_file_begin" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      redirect_file_begin((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_file_append_begin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::redirect_file_append_begin filename ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "redirect_file_append_begin" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      redirect_file_append_begin((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_file_end(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::redirect_file_end ") == TCL_ERROR) SWIG_fail;
  {
    try {
      redirect_file_end(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_string_begin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::redirect_string_begin ") == TCL_ERROR) SWIG_fail;
  {
    try {
      redirect_string_begin(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_redirect_string_end(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::redirect_string_end ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)redirect_string_end(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_log_begin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::log_begin_cmd filename ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "log_begin_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      log_begin_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_log_end(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::log_end ") == TCL_ERROR) SWIG_fail;
  {
    try {
      log_end(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_debug(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_debug what level ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_debug" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_debug" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      set_debug((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_object(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_object obj ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_object" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)is_object((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_object_type(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::object_type obj ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "object_type" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (char *)object_type((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_object_list(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::is_object_list list type ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_object_list" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "is_object_list" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (bool)is_object_list((char const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_rise_fall_short_names(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_rise_fall_short_names rise_short_name fall_short_name ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_rise_fall_short_names" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_rise_fall_short_names" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      set_rise_fall_short_names((char const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_rise_short_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::rise_short_name ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)rise_short_name(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_fall_short_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::fall_short_name ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)fall_short_name(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_is_constrained(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_is_constrained pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_is_constrained" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)pin_is_constrained(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_instance_is_constrained(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::instance_is_constrained inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "instance_is_constrained" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (bool)instance_is_constrained(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_net_is_constrained(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::net_is_constrained net ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "net_is_constrained" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (bool)net_is_constrained(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clk_thru_tristate_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::clk_thru_tristate_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)clk_thru_tristate_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clk_thru_tristate_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_clk_thru_tristate_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_clk_thru_tristate_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_clk_thru_tristate_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_is_linked(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_is_linked ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)network_is_linked(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_path_divider(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char arg1 ;
  char val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_path_divider divider ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_char SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_path_divider" "', argument " "1"" of type '" "char""'");
  } 
  arg1 = static_cast< char >(val1);
  {
    try {
      set_path_divider(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_current_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_current_instance inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_current_instance" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      set_current_instance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_read_liberty_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  bool arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::read_liberty_cmd filename corner min_max infer_latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read_liberty_cmd" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "read_liberty_cmd" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "read_liberty_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (bool)read_liberty_cmd(arg1,arg2,(MinMaxAll const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_min_library_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_min_library_cmd min_filename max_filename ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_min_library_cmd" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_min_library_cmd" "', argument " "2"" of type '" "char *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = (bool)set_min_library_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_library(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Library *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_library name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_library" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Library *)find_library((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Library, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_library_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibraryIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::library_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (LibraryIterator *)library_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibraryIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_liberty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  LibertyLibrary *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_liberty name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_liberty" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (LibertyLibrary *)find_liberty((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_LibertyLibrary,0));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_library_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibraryIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::liberty_library_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (LibertyLibraryIterator *)liberty_library_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyLibraryIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_liberty_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  LibertyCell *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_liberty_cell name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_liberty_cell" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (LibertyCell *)find_liberty_cell((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LibertyCell, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_cells_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  TmpCellSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_cells_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_cells_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_cells_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_cells_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (TmpCellSeq *)find_cells_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    CellSeq *cells = result;
    CellSeq::Iterator cell_iter(cells);
    while (cell_iter.hasNext()) {
      Cell *cell = cell_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(cell, SWIGTYPE_p_Cell, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
    delete cells;
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_library_buffers(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCellSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_library_buffers library ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_library_buffers" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  {
    try {
      result = (LibertyCellSeq *)find_library_buffers(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    LibertyCellSeq *cells = result;
    LibertyCellSeq::Iterator cell_iter(cells);
    while (cell_iter.hasNext()) {
      LibertyCell *cell = cell_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(cell, SWIGTYPE_p_LibertyCell,
        false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_equiv_cells(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::make_equiv_cells lib ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_equiv_cells" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  {
    try {
      make_equiv_cells(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_equiv_cells(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  LibertyCellSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_equiv_cells cell ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_equiv_cells" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (LibertyCellSeq *)find_equiv_cells(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    LibertyCellSeq *cells = result;
    LibertyCellSeq::Iterator cell_iter(cells);
    while (cell_iter.hasNext()) {
      LibertyCell *cell = cell_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(cell, SWIGTYPE_p_LibertyCell,
        false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_equiv_cells(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::equiv_cells cell1 cell2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equiv_cells" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equiv_cells" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  {
    try {
      result = (bool)equiv_cells(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_equiv_cell_ports(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::equiv_cell_ports cell1 cell2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equiv_cell_ports" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equiv_cell_ports" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  {
    try {
      result = (bool)equiv_cell_ports(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_equiv_cell_timing_arcs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::equiv_cell_timing_arcs cell1 cell2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "equiv_cell_timing_arcs" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "equiv_cell_timing_arcs" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  {
    try {
      result = (bool)equiv_cell_timing_arcs(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_namespace_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_cmd_namespace_cmd namespc ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_namespace_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_cmd_namespace_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_link_design_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::link_design_cmd top_cell_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "link_design_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)link_design_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_link_make_black_boxes(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::link_make_black_boxes ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)link_make_black_boxes(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_link_make_black_boxes(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_link_make_black_boxes make ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_link_make_black_boxes" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_link_make_black_boxes(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_top_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::top_instance ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Instance *)top_instance(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_port_direction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::liberty_port_direction port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_port_direction" "', argument " "1"" of type '" "LibertyPort const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      result = (char *)liberty_port_direction((LibertyPort const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_direction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::port_direction port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_direction" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (char *)port_direction((Port const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_direction(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_direction pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_direction" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char *)pin_direction((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_ports_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  TmpPortSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_ports_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_ports_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_ports_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_ports_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (TmpPortSeq *)find_ports_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    TmpPortSeq *ports = result;
    TmpPortSeq::Iterator port_iter(ports);
    while (port_iter.hasNext()) {
      Port *port = port_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(port, SWIGTYPE_p_Port, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete ports;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_port_pins_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  TmpPinSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_port_pins_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_port_pins_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_port_pins_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_port_pins_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (TmpPinSeq *)find_port_pins_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSeq *pins = result;
    PinSeq::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Pin *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_pin path_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_pin" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Pin *)find_pin((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Pin, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_pins_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  TmpPinSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_pins_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_pins_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_pins_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_pins_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (TmpPinSeq *)find_pins_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSeq *pins = result;
    PinSeq::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_pins_hier_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  TmpPinSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_pins_hier_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_pins_hier_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_pins_hier_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_pins_hier_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (TmpPinSeq *)find_pins_hier_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSeq *pins = result;
    PinSeq::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_instance path_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_instance" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Instance *)find_instance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_leaf_instances(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TmpInstanceSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_leaf_instances ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (TmpInstanceSeq *)network_leaf_instances(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    TmpInstanceSeq *insts = result;
    TmpInstanceSeq::Iterator inst_iter(insts);
    while (inst_iter.hasNext()) {
      Instance *inst = inst_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(inst, SWIGTYPE_p_Instance,false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete insts;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_instances_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  TmpInstanceSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_instances_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_instances_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_instances_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_instances_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (TmpInstanceSeq *)find_instances_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    TmpInstanceSeq *insts = result;
    TmpInstanceSeq::Iterator inst_iter(insts);
    while (inst_iter.hasNext()) {
      Instance *inst = inst_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(inst, SWIGTYPE_p_Instance,false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete insts;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_instances_hier_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  TmpInstanceSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_instances_hier_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_instances_hier_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_instances_hier_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_instances_hier_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (TmpInstanceSeq *)find_instances_hier_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    TmpInstanceSeq *insts = result;
    TmpInstanceSeq::Iterator inst_iter(insts);
    while (inst_iter.hasNext()) {
      Instance *inst = inst_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(inst, SWIGTYPE_p_Instance,false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete insts;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_instances(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  TmpInstanceSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_instances clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSet<Clock*>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_instances" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_instances" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (TmpInstanceSet *)find_register_instances(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    InstanceSet *insts = result;
    InstanceSet::Iterator inst_iter(insts);
    while (inst_iter.hasNext()) {
      Instance *inst = inst_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(inst, SWIGTYPE_p_Instance,false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete insts;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_data_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_data_pins clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSet<Clock*>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_data_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_data_pins" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (TmpPinSet *)find_register_data_pins(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_clk_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_clk_pins clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSet<Clock*>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_clk_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_clk_pins" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (TmpPinSet *)find_register_clk_pins(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_async_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_async_pins clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSet<Clock*>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_async_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_async_pins" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (TmpPinSet *)find_register_async_pins(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_register_output_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_register_output_pins clks clk_tr edge_triggered latches ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSet<Clock*>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_register_output_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_register_output_pins" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      result = (TmpPinSet *)find_register_output_pins(arg1,(RiseFallBoth const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_net path_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_net" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Net *)find_net(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_nets_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  NetSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_nets_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_nets_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_nets_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_nets_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (NetSeq *)find_nets_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    NetSeq *nets = result;
    NetSeq::Iterator net_iter(nets);
    while (net_iter.hasNext()) {
      Net *net = net_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(net, SWIGTYPE_p_Net, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete nets;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_nets_hier_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  NetSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_nets_hier_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_nets_hier_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_nets_hier_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_nets_hier_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (NetSeq *)find_nets_hier_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    NetSeq *nets = result;
    NetSeq::Iterator net_iter(nets);
    while (net_iter.hasNext()) {
      Net *net = net_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(net, SWIGTYPE_p_Net, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete nets;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_ports(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  PortSeq *arg4 = (PortSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  TmpPortSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_ports property op pattern ports ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_ports" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_ports" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_ports" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeq<Port*>(objv[4], SWIGTYPE_p_Port, interp);
  }
  {
    try {
      result = (TmpPortSeq *)filter_ports((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    TmpPortSeq *ports = result;
    TmpPortSeq::Iterator port_iter(ports);
    while (port_iter.hasNext()) {
      Port *port = port_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(port, SWIGTYPE_p_Port, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete ports;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_insts(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  InstanceSeq *arg4 = (InstanceSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  TmpInstanceSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_insts property op pattern insts ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_insts" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_insts" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_insts" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeq<Instance*>(objv[4], SWIGTYPE_p_Instance, interp);
  }
  {
    try {
      result = (TmpInstanceSeq *)filter_insts((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    TmpInstanceSeq *insts = result;
    TmpInstanceSeq::Iterator inst_iter(insts);
    while (inst_iter.hasNext()) {
      Instance *inst = inst_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(inst, SWIGTYPE_p_Instance,false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete insts;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  PinSeq *arg4 = (PinSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  PinSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_pins property op pattern pins ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_pins" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_pins" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_pins" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeq<Pin*>(objv[4], SWIGTYPE_p_Pin, interp);
  }
  {
    try {
      result = (PinSeq *)filter_pins((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSeq *pins = result;
    PinSeq::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::pin_property pin property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_property" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "pin_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = pin_property((Pin const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_instance_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::instance_property inst property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "instance_property" "', argument " "1"" of type '" "Instance const *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "instance_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = instance_property((Instance const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_net_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::net_property net property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "net_property" "', argument " "1"" of type '" "Net const *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "net_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = net_property((Net const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::port_property port property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_property" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "port_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = port_property((Port const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_cell_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::liberty_cell_property cell property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_cell_property" "', argument " "1"" of type '" "LibertyCell const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "liberty_cell_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = liberty_cell_property((LibertyCell const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_cell_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::cell_property cell property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "cell_property" "', argument " "1"" of type '" "Cell const *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "cell_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = cell_property((Cell const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_port_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::liberty_port_property port property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_port_property" "', argument " "1"" of type '" "LibertyPort const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "liberty_port_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = liberty_port_property((LibertyPort const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_library_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Library *arg1 = (Library *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::library_property lib property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Library, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "library_property" "', argument " "1"" of type '" "Library const *""'"); 
  }
  arg1 = reinterpret_cast< Library * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "library_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = library_property((Library const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_library_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::liberty_library_property lib property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_library_property" "', argument " "1"" of type '" "LibertyLibrary const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "liberty_library_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = liberty_library_property((LibertyLibrary const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_edge_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::edge_property edge property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "edge_property" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "edge_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = edge_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clock_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::clock_property clk property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clock_property" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "clock_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = clock_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_path_end_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::path_end_property end property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "path_end_property" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "path_end_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = path_end_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_path_ref_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::path_ref_property path property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "path_ref_property" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "path_ref_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = path_ref_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_timing_arc_set_property(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  char *arg2 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  PropertyValue result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::timing_arc_set_property arc_set property ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "timing_arc_set_property" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "timing_arc_set_property" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      result = timing_arc_set_property(arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    PropertyValue value = result;
    switch (value.type()) {
    case PropertyValue::Type::type_none:
      Tcl_SetResult(interp, const_cast<char*>(""), TCL_STATIC);
      break;
    case PropertyValue::Type::type_string:
      Tcl_SetResult(interp, const_cast<char*>(value.stringValue()), TCL_VOLATILE);
      break;
      case PropertyValue::Type::type_float: {
        char *float_string = stringPrint("%.6e", value.floatValue());
        Tcl_SetResult(interp, float_string, TCL_VOLATILE);
        stringDelete(float_string);
      }
      break;
      case PropertyValue::Type::type_bool: {
        const char *bool_string = value.boolValue() ? "1" : "0";
        Tcl_SetResult(interp, const_cast<char*>(bool_string), TCL_STATIC);
      }
      break;
      case PropertyValue::Type::type_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.library(),
          SWIGTYPE_p_Library, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.cell(),
          SWIGTYPE_p_Cell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.port(),
          SWIGTYPE_p_Port, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_library: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyLibrary(),
          SWIGTYPE_p_LibertyLibrary, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_cell: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyCell(),
          SWIGTYPE_p_LibertyCell, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_liberty_port: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.libertyPort(),
          SWIGTYPE_p_LibertyPort, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_instance: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.instance(),
          SWIGTYPE_p_Instance, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pin: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.pin(), SWIGTYPE_p_Pin, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_pins: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PinSeq *pins = value.pins();
        PinSeq::Iterator pin_iter(pins);
        while (pin_iter.hasNext()) {
          Pin *pin = pin_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_net: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.net(),
          SWIGTYPE_p_Net, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clk: {
        Tcl_Obj *obj = SWIG_NewInstanceObj(value.clock(),
          SWIGTYPE_p_Clock, false);
        Tcl_SetObjResult(interp, obj);
      }
      break;
      case PropertyValue::Type::type_clks: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        ClockSeq *clks = value.clocks();
        ClockSeq::Iterator clk_iter(clks);
        while (clk_iter.hasNext()) {
          Clock *clk = clk_iter.next();
          Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_path_refs: {
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        PathRefSeq *paths = value.pathRefs();
        PathRefSeq::Iterator path_iter(paths);
        while (path_iter.hasNext()) {
          PathRef &path = path_iter.next();
          PathRef *copy = new PathRef(path);
          Tcl_Obj *obj = SWIG_NewInstanceObj(copy, SWIGTYPE_p_PathRef, false);
          Tcl_ListObjAppendElement(interp, list, obj);
        }
        Tcl_SetObjResult(interp, list);
      }
      break;
      case PropertyValue::Type::type_pwr_activity: {
        PwrActivity activity = value.pwrActivity();
        Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
        Tcl_Obj *obj;
        const char *str;
        
        str = stringPrintTmp("%.5e", activity.activity());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = stringPrintTmp("%.3f", activity.duty());
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        str = activity.originName();
        obj = Tcl_NewStringObj(str, strlen(str));
        Tcl_ListObjAppendElement(interp, list, obj);
        
        Tcl_SetObjResult(interp, list);
      }
      break;
    }
  }
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_leaf_instance_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LeafInstanceIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::leaf_instance_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (LeafInstanceIterator *)leaf_instance_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_LeafInstanceIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_define_corners_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  StringSet *arg1 = (StringSet *) 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::define_corners_cmd corner_names ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetConstChar(objv[1], interp);
  }
  {
    try {
      define_corners_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_cmd_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corner *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::cmd_corner ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Corner *)cmd_corner(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Corner, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_cmd_corner corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_corner" "', argument " "1"" of type '" "Corner *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      set_cmd_corner(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Corner *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_corner corner_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_corner" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Corner *)find_corner((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Corner, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_corners(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corners *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::corners ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Corners *)corners(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    Corners *corners = result;
    for (Corner *corner : *corners) {
      Tcl_Obj *obj = SWIG_NewInstanceObj(corner, SWIGTYPE_p_Corner, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_multi_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::multi_corner ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)multi_corner(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_analysis_type_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_analysis_type_cmd analysis_type ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_analysis_type_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_analysis_type_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_operating_conditions(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  OperatingConditions *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::operating_conditions min_max ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (OperatingConditions *)operating_conditions((MinMax const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_OperatingConditions, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_operating_conditions_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  OperatingConditions *arg1 = (OperatingConditions *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_operating_conditions_cmd op_cond min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_OperatingConditions, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_operating_conditions_cmd" "', argument " "1"" of type '" "OperatingConditions *""'"); 
  }
  arg1 = reinterpret_cast< OperatingConditions * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_operating_conditions_cmd(arg1,(MinMaxAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_filter_timing_arcs(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  EdgeSeq *arg4 = (EdgeSeq *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  EdgeSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::filter_timing_arcs property op pattern edges ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "filter_timing_arcs" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "filter_timing_arcs" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "filter_timing_arcs" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  {
    arg4 = tclListSeq<Edge*>(objv[4], SWIGTYPE_p_Edge, interp);
  }
  {
    try {
      result = (EdgeSeq *)filter_timing_arcs((char const *)arg1,(char const *)arg2,(char const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    EdgeSeq *edges = result;
    EdgeSeq::Iterator edge_iter(edges);
    while (edge_iter.hasNext()) {
      Edge *edge = edge_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(edge, SWIGTYPE_p_Edge, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete edges;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_operating_condition_analysis_type(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::operating_condition_analysis_type ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)operating_condition_analysis_type(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_instance_pvt(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  float arg3 ;
  float arg4 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_instance_pvt inst min_max process voltage temperature ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_instance_pvt" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_instance_pvt" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_instance_pvt" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_instance_pvt" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_instance_pvt(arg1,(MinMaxAll const *)arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_ext_pin_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::port_ext_pin_cap port min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_ext_pin_cap" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)port_ext_pin_cap(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_pin_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_port_pin_cap port rf min_max cap ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_pin_cap" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_port_pin_cap" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      set_port_pin_cap(arg1,(RiseFallBoth const *)arg2,(MinMaxAll const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_ext_wire_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::port_ext_wire_cap port min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_ext_wire_cap" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)port_ext_wire_cap(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_wire_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  bool arg2 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_port_wire_cap port subtract_pin_cap rf min_max cap ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_wire_cap" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_port_wire_cap" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_port_wire_cap" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_port_wire_cap(arg1,arg2,(RiseFallBoth const *)arg3,(MinMaxAll const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_ext_fanout_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  int arg2 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_port_ext_fanout_cmd port fanout min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_ext_fanout_cmd" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_port_ext_fanout_cmd" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_port_ext_fanout_cmd(arg1,arg2,(MinMaxAll const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_ext_fanout(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::port_ext_fanout port min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_ext_fanout" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)port_ext_fanout(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_net_wire_cap(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  bool arg2 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_net_wire_cap net subtract_pin_cap corner min_max cap ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_net_wire_cap" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_net_wire_cap" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_net_wire_cap" "', argument " "3"" of type '" "Corner *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_net_wire_cap" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_net_wire_cap(arg1,arg2,arg3,(MinMaxAll const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_wire_load_mode_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_wire_load_mode_cmd mode_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_wire_load_mode_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_wire_load_mode_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_net_resistance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_net_resistance net min_max res ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_net_resistance" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_net_resistance" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_net_resistance(arg1,(MinMaxAll const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_wire_load_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Wireload *arg1 = (Wireload *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_wire_load_cmd wireload min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Wireload, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_wire_load_cmd" "', argument " "1"" of type '" "Wireload *""'"); 
  }
  arg1 = reinterpret_cast< Wireload * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_wire_load_cmd(arg1,(MinMaxAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_wire_load_selection_group_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  WireloadSelection *arg1 = (WireloadSelection *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_wire_load_selection_group_cmd selection min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_WireloadSelection, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_wire_load_selection_group_cmd" "', argument " "1"" of type '" "WireloadSelection *""'"); 
  }
  arg1 = reinterpret_cast< WireloadSelection * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_wire_load_selection_group_cmd(arg1,(MinMaxAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  PinSet *arg2 = (PinSet *) 0 ;
  bool arg3 ;
  float arg4 ;
  FloatSeq *arg5 = (FloatSeq *) 0 ;
  char *arg6 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::make_clock name pins add_to_pins period waveform comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_clock" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    arg2 = tclListSetPin(objv[2], interp);
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "make_clock" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "make_clock" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    int argc;
    Tcl_Obj **argv;
    FloatSeq *floats = nullptr;
    
    if (Tcl_ListObjGetElements(interp, objv[5], &argc, &argv) == TCL_OK) {
      if (argc)
      floats = new FloatSeq;
      for (int i = 0; i < argc; i++) {
        char *arg = Tcl_GetString(argv[i]);
        double value;
        if (Tcl_GetDouble(interp, arg, &value) == TCL_OK)
        floats->push_back(static_cast<float>(value));
        else {
          delete floats;
          tclArgError(interp, "%s is not a floating point number.", arg);
          return TCL_ERROR;
        }
      }
    }
    arg5 = floats;
  }
  res6 = SWIG_AsCharPtrAndSize(objv[6], &buf6, NULL, &alloc6);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "make_clock" "', argument " "6"" of type '" "char *""'");
  }
  arg6 = reinterpret_cast< char * >(buf6);
  {
    try {
      make_clock((char const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_generated_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  PinSet *arg2 = (PinSet *) 0 ;
  bool arg3 ;
  Pin *arg4 = (Pin *) 0 ;
  Clock *arg5 = (Clock *) 0 ;
  Pin *arg6 = (Pin *) 0 ;
  Pin *arg7 = (Pin *) 0 ;
  int arg8 ;
  int arg9 ;
  float arg10 ;
  bool arg11 ;
  bool arg12 ;
  IntSeq *arg13 = (IntSeq *) 0 ;
  FloatSeq *arg14 = (FloatSeq *) 0 ;
  char *arg15 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  void *argp6 = 0 ;
  int res6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  int val9 ;
  int ecode9 = 0 ;
  float val10 ;
  int ecode10 = 0 ;
  bool val11 ;
  int ecode11 = 0 ;
  bool val12 ;
  int ecode12 = 0 ;
  int res15 ;
  char *buf15 = 0 ;
  int alloc15 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooooooooooo:sta::make_generated_clock name pins add_to_pins src_pin master_clk pll_out pll_fdbk divide_by multiply_by duty_cycle invert combinational edges edge_shifts comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_generated_clock" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    arg2 = tclListSetPin(objv[2], interp);
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "make_generated_clock" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "make_generated_clock" "', argument " "4"" of type '" "Pin *""'"); 
  }
  arg4 = reinterpret_cast< Pin * >(argp4);
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "make_generated_clock" "', argument " "5"" of type '" "Clock *""'"); 
  }
  arg5 = reinterpret_cast< Clock * >(argp5);
  res6 = SWIG_ConvertPtr(objv[6], &argp6,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "make_generated_clock" "', argument " "6"" of type '" "Pin *""'"); 
  }
  arg6 = reinterpret_cast< Pin * >(argp6);
  res7 = SWIG_ConvertPtr(objv[7], &argp7,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "make_generated_clock" "', argument " "7"" of type '" "Pin *""'"); 
  }
  arg7 = reinterpret_cast< Pin * >(argp7);
  ecode8 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "make_generated_clock" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = static_cast< int >(val8);
  ecode9 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "make_generated_clock" "', argument " "9"" of type '" "int""'");
  } 
  arg9 = static_cast< int >(val9);
  ecode10 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "make_generated_clock" "', argument " "10"" of type '" "float""'");
  } 
  arg10 = static_cast< float >(val10);
  ecode11 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[11], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "make_generated_clock" "', argument " "11"" of type '" "bool""'");
  } 
  arg11 = static_cast< bool >(val11);
  ecode12 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[12], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "make_generated_clock" "', argument " "12"" of type '" "bool""'");
  } 
  arg12 = static_cast< bool >(val12);
  {
    int argc;
    Tcl_Obj **argv;
    IntSeq *ints = nullptr;
    
    if (Tcl_ListObjGetElements(interp, objv[13], &argc, &argv) == TCL_OK) {
      if (argc)
      ints = new IntSeq;
      for (int i = 0; i < argc; i++) {
        char *arg = Tcl_GetString(argv[i]);
        int value;
        if (Tcl_GetInt(interp, arg, &value) == TCL_OK)
        ints->push_back(value);
        else {
          delete ints;
          tclArgError(interp, "%s is not an integer.", arg);
          return TCL_ERROR;
        }
      }
    }
    arg13 = ints;
  }
  {
    int argc;
    Tcl_Obj **argv;
    FloatSeq *floats = nullptr;
    
    if (Tcl_ListObjGetElements(interp, objv[14], &argc, &argv) == TCL_OK) {
      if (argc)
      floats = new FloatSeq;
      for (int i = 0; i < argc; i++) {
        char *arg = Tcl_GetString(argv[i]);
        double value;
        if (Tcl_GetDouble(interp, arg, &value) == TCL_OK)
        floats->push_back(static_cast<float>(value));
        else {
          delete floats;
          tclArgError(interp, "%s is not a floating point number.", arg);
          return TCL_ERROR;
        }
      }
    }
    arg14 = floats;
  }
  res15 = SWIG_AsCharPtrAndSize(objv[15], &buf15, NULL, &alloc15);
  if (!SWIG_IsOK(res15)) {
    SWIG_exception_fail(SWIG_ArgError(res15), "in method '" "make_generated_clock" "', argument " "15"" of type '" "char *""'");
  }
  arg15 = reinterpret_cast< char * >(buf15);
  {
    try {
      make_generated_clock((char const *)arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc15 == SWIG_NEWOBJ) delete[] buf15;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc15 == SWIG_NEWOBJ) delete[] buf15;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_remove_clock_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::remove_clock_cmd clk ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "remove_clock_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      remove_clock_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_propagated_clock_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_propagated_clock_cmd clk ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_propagated_clock_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      set_propagated_clock_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_propagated_clock_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_propagated_clock_pin_cmd pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_propagated_clock_pin_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      set_propagated_clock_pin_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_propagated_clock_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_propagated_clock_cmd clk ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_propagated_clock_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      unset_propagated_clock_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_propagated_clock_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_propagated_clock_pin_cmd pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_propagated_clock_pin_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      unset_propagated_clock_pin_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_slew_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_clock_slew_cmd clk rf min_max slew ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_slew_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_slew_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      set_clock_slew_cmd(arg1,(RiseFallBoth const *)arg2,(MinMaxAll const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_slew_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_clock_slew_cmd clk ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_slew_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    try {
      unset_clock_slew_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_latency_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_clock_latency_cmd clk pin rf min_max delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_latency_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_clock_latency_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_clock_latency_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_clock_latency_cmd(arg1,arg2,(RiseFallBoth const *)arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_insertion_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  EarlyLateAll *arg5 = (EarlyLateAll *) 0 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_clock_insertion_cmd clk pin rf min_max early_late delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_insertion_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_clock_insertion_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    EarlyLateAll *early_late = EarlyLateAll::find(arg);
    if (early_late)
    arg5 = early_late;
    else {
      tclArgError(interp, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_clock_insertion_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_clock_insertion_cmd(arg1,arg2,(RiseFallBoth const *)arg3,(MinMaxAll const *)arg4,(EarlyLateAll const *)arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_latency_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::unset_clock_latency_cmd clk pin ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_latency_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "unset_clock_latency_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    try {
      unset_clock_latency_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_insertion_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::unset_clock_insertion_cmd clk pin ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_insertion_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "unset_clock_insertion_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    try {
      unset_clock_insertion_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_uncertainty_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  SetupHoldAll *arg2 = (SetupHoldAll *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_clock_uncertainty_clk clk setup_hold uncertainty ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_uncertainty_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg2 = SetupHoldAll::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg2 = SetupHoldAll::max();
    else if (stringEqual(arg, "setup_hold")
      || stringEqual(arg, "min_max"))
    arg2 = SetupHoldAll::all();
    else {
      tclArgError(interp, "%s not setup, hold, setup_hold, min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_clock_uncertainty_clk" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_clock_uncertainty_clk(arg1,(SetupHoldAll const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_uncertainty_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  SetupHoldAll *arg2 = (SetupHoldAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::unset_clock_uncertainty_clk clk setup_hold ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_uncertainty_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg2 = SetupHoldAll::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg2 = SetupHoldAll::max();
    else if (stringEqual(arg, "setup_hold")
      || stringEqual(arg, "min_max"))
    arg2 = SetupHoldAll::all();
    else {
      tclArgError(interp, "%s not setup, hold, setup_hold, min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_clock_uncertainty_clk(arg1,(SetupHoldAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_uncertainty_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_clock_uncertainty_pin pin min_max uncertainty ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_uncertainty_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_clock_uncertainty_pin" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_clock_uncertainty_pin(arg1,(MinMaxAll const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_uncertainty_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMaxAll *arg2 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::unset_clock_uncertainty_pin pin min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_uncertainty_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_clock_uncertainty_pin(arg1,(MinMaxAll const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_inter_clock_uncertainty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg5 = (MinMaxAll *) 0 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_inter_clock_uncertainty from_clk from_tr to_clk to_tr min_max uncertainty ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_inter_clock_uncertainty" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_inter_clock_uncertainty" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg5 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_inter_clock_uncertainty" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_inter_clock_uncertainty(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFallBoth const *)arg4,(MinMaxAll const *)arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_inter_clock_uncertainty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg5 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::unset_inter_clock_uncertainty from_clk from_tr to_clk to_tr min_max ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_inter_clock_uncertainty" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_inter_clock_uncertainty" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg5 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_inter_clock_uncertainty(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFallBoth const *)arg4,(MinMaxAll const *)arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_gating_check_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  RiseFallBoth *arg1 = (RiseFallBoth *) 0 ;
  SetupHold *arg2 = (SetupHold *) 0 ;
  float arg3 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_clock_gating_check_cmd rf setup_hold margin ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[1], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg1 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg2 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg2 = MinMax::max();
    else {
      tclArgError(interp, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_clock_gating_check_cmd" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_clock_gating_check_cmd((RiseFallBoth const *)arg1,(SetupHold const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_gating_check_clk_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  SetupHold *arg3 = (SetupHold *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_clock_gating_check_clk_cmd clk rf setup_hold margin ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_gating_check_clk_cmd" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg3 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg3 = MinMax::max();
    else {
      tclArgError(interp, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_gating_check_clk_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      set_clock_gating_check_clk_cmd(arg1,(RiseFallBoth const *)arg2,(SetupHold const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_gating_check_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  SetupHold *arg3 = (SetupHold *) 0 ;
  float arg4 ;
  LogicValue arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_clock_gating_check_pin_cmd pin rf setup_hold margin active_value ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_gating_check_pin_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg3 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg3 = MinMax::max();
    else {
      tclArgError(interp, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_gating_check_pin_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[5], &length);
    if (stringEq(arg, "0") || stringEq(arg, "zero"))
    arg5 = LogicValue::zero;
    else if (stringEq(arg, "1") || stringEq(arg, "one"))
    arg5 = LogicValue::one;
    else if (stringEq(arg, "X"))
    arg5 = LogicValue::unknown;
    else if (stringEq(arg, "rise") || stringEq(arg, "rising"))
    arg5 = LogicValue::rise;
    else if (stringEq(arg, "fall") || stringEq(arg, "falling"))
    arg5 = LogicValue::fall;
    else {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown logic value."),
        TCL_STATIC);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_clock_gating_check_pin_cmd(arg1,(RiseFallBoth const *)arg2,(SetupHold const *)arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_gating_check_instance_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  SetupHold *arg3 = (SetupHold *) 0 ;
  float arg4 ;
  LogicValue arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_clock_gating_check_instance_cmd inst rf setup_hold margin active_value ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_clock_gating_check_instance_cmd" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg3 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg3 = MinMax::max();
    else {
      tclArgError(interp, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_gating_check_instance_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[5], &length);
    if (stringEq(arg, "0") || stringEq(arg, "zero"))
    arg5 = LogicValue::zero;
    else if (stringEq(arg, "1") || stringEq(arg, "one"))
    arg5 = LogicValue::one;
    else if (stringEq(arg, "X"))
    arg5 = LogicValue::unknown;
    else if (stringEq(arg, "rise") || stringEq(arg, "rising"))
    arg5 = LogicValue::rise;
    else if (stringEq(arg, "fall") || stringEq(arg, "falling"))
    arg5 = LogicValue::fall;
    else {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown logic value."),
        TCL_STATIC);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_clock_gating_check_instance_cmd(arg1,(RiseFallBoth const *)arg2,(SetupHold const *)arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_data_check_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Pin *arg3 = (Pin *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  Clock *arg5 = (Clock *) 0 ;
  SetupHoldAll *arg6 = (SetupHoldAll *) 0 ;
  float arg7 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  float val7 ;
  int ecode7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::set_data_check_cmd from from_rf to to_rf clk setup_hold margin ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_data_check_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_data_check_cmd" "', argument " "3"" of type '" "Pin *""'"); 
  }
  arg3 = reinterpret_cast< Pin * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "set_data_check_cmd" "', argument " "5"" of type '" "Clock *""'"); 
  }
  arg5 = reinterpret_cast< Clock * >(argp5);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[6], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg6 = SetupHoldAll::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg6 = SetupHoldAll::max();
    else if (stringEqual(arg, "setup_hold")
      || stringEqual(arg, "min_max"))
    arg6 = SetupHoldAll::all();
    else {
      tclArgError(interp, "%s not setup, hold, setup_hold, min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode7 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "set_data_check_cmd" "', argument " "7"" of type '" "float""'");
  } 
  arg7 = static_cast< float >(val7);
  {
    try {
      set_data_check_cmd(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFallBoth const *)arg4,arg5,(SetupHoldAll const *)arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_data_check_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Pin *arg3 = (Pin *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  Clock *arg5 = (Clock *) 0 ;
  SetupHoldAll *arg6 = (SetupHoldAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::unset_data_check_cmd from from_tr to to_tr clk setup_hold ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_data_check_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_data_check_cmd" "', argument " "3"" of type '" "Pin *""'"); 
  }
  arg3 = reinterpret_cast< Pin * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "unset_data_check_cmd" "', argument " "5"" of type '" "Clock *""'"); 
  }
  arg5 = reinterpret_cast< Clock * >(argp5);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[6], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg6 = SetupHoldAll::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg6 = SetupHoldAll::max();
    else if (stringEqual(arg, "setup_hold")
      || stringEqual(arg, "min_max"))
    arg6 = SetupHoldAll::all();
    else {
      tclArgError(interp, "%s not setup, hold, setup_hold, min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_data_check_cmd(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFallBoth const *)arg4,arg5,(SetupHoldAll const *)arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_input_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  Pin *arg5 = (Pin *) 0 ;
  bool arg6 ;
  bool arg7 ;
  MinMaxAll *arg8 = (MinMaxAll *) 0 ;
  bool arg9 ;
  float arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  float val10 ;
  int ecode10 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooooo:sta::set_input_delay_cmd pin rf clk clk_rf ref_pin source_latency_included network_latency_included min_max add delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_input_delay_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_input_delay_cmd" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "set_input_delay_cmd" "', argument " "5"" of type '" "Pin *""'"); 
  }
  arg5 = reinterpret_cast< Pin * >(argp5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_input_delay_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "set_input_delay_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[8], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg8 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode9 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "set_input_delay_cmd" "', argument " "9"" of type '" "bool""'");
  } 
  arg9 = static_cast< bool >(val9);
  ecode10 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "set_input_delay_cmd" "', argument " "10"" of type '" "float""'");
  } 
  arg10 = static_cast< float >(val10);
  {
    try {
      set_input_delay_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_input_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  MinMaxAll *arg5 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::unset_input_delay_cmd pin rf clk clk_rf min_max ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_input_delay_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_input_delay_cmd" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg5 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_input_delay_cmd(arg1,arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_output_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  Pin *arg5 = (Pin *) 0 ;
  bool arg6 ;
  bool arg7 ;
  MinMaxAll *arg8 = (MinMaxAll *) 0 ;
  bool arg9 ;
  float arg10 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  float val10 ;
  int ecode10 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooooo:sta::set_output_delay_cmd pin rf clk clk_rf ref_pin source_latency_included network_latency_included min_max add delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_output_delay_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_output_delay_cmd" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "set_output_delay_cmd" "', argument " "5"" of type '" "Pin *""'"); 
  }
  arg5 = reinterpret_cast< Pin * >(argp5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_output_delay_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "set_output_delay_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[8], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg8 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode9 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "set_output_delay_cmd" "', argument " "9"" of type '" "bool""'");
  } 
  arg9 = static_cast< bool >(val9);
  ecode10 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "set_output_delay_cmd" "', argument " "10"" of type '" "float""'");
  } 
  arg10 = static_cast< float >(val10);
  {
    try {
      set_output_delay_cmd(arg1,(RiseFallBoth const *)arg2,arg3,(RiseFall const *)arg4,arg5,arg6,arg7,(MinMaxAll const *)arg8,arg9,arg10); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_output_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  Clock *arg3 = (Clock *) 0 ;
  RiseFall *arg4 = (RiseFall *) 0 ;
  MinMaxAll *arg5 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::unset_output_delay_cmd pin rf clk clk_rf min_max ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_output_delay_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_output_delay_cmd" "', argument " "3"" of type '" "Clock *""'"); 
  }
  arg3 = reinterpret_cast< Clock * >(argp3);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg5 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      unset_output_delay_cmd(arg1,arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyPort *arg2 = (LibertyPort *) 0 ;
  LibertyPort *arg3 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::disable_cell cell from to ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_cell" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "disable_cell" "', argument " "2"" of type '" "LibertyPort *""'"); 
  }
  arg2 = reinterpret_cast< LibertyPort * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "disable_cell" "', argument " "3"" of type '" "LibertyPort *""'"); 
  }
  arg3 = reinterpret_cast< LibertyPort * >(argp3);
  {
    try {
      disable_cell(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  LibertyPort *arg2 = (LibertyPort *) 0 ;
  LibertyPort *arg3 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::unset_disable_cell cell from to ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_cell" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "unset_disable_cell" "', argument " "2"" of type '" "LibertyPort *""'"); 
  }
  arg2 = reinterpret_cast< LibertyPort * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_disable_cell" "', argument " "3"" of type '" "LibertyPort *""'"); 
  }
  arg3 = reinterpret_cast< LibertyPort * >(argp3);
  {
    try {
      unset_disable_cell(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_lib_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_lib_port port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_lib_port" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      disable_lib_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_lib_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyPort *arg1 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_lib_port port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_lib_port" "', argument " "1"" of type '" "LibertyPort *""'"); 
  }
  arg1 = reinterpret_cast< LibertyPort * >(argp1);
  {
    try {
      unset_disable_lib_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_port port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_port" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      disable_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_port port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_port" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      unset_disable_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  LibertyPort *arg2 = (LibertyPort *) 0 ;
  LibertyPort *arg3 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::disable_instance instance from to ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_instance" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "disable_instance" "', argument " "2"" of type '" "LibertyPort *""'"); 
  }
  arg2 = reinterpret_cast< LibertyPort * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "disable_instance" "', argument " "3"" of type '" "LibertyPort *""'"); 
  }
  arg3 = reinterpret_cast< LibertyPort * >(argp3);
  {
    try {
      disable_instance(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_instance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  LibertyPort *arg2 = (LibertyPort *) 0 ;
  LibertyPort *arg3 = (LibertyPort *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::unset_disable_instance instance from to ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_instance" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "unset_disable_instance" "', argument " "2"" of type '" "LibertyPort *""'"); 
  }
  arg2 = reinterpret_cast< LibertyPort * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "unset_disable_instance" "', argument " "3"" of type '" "LibertyPort *""'"); 
  }
  arg3 = reinterpret_cast< LibertyPort * >(argp3);
  {
    try {
      unset_disable_instance(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_pin pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      disable_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_pin pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      unset_disable_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_edge edge ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_edge" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      disable_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_edge(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_edge edge ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_edge" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  {
    try {
      unset_disable_edge(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_timing_arc_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_timing_arc_set arc_set ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_timing_arc_set" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      disable_timing_arc_set(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_timing_arc_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingArcSet *arg1 = (TimingArcSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_timing_arc_set arc_set ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_TimingArcSet, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_timing_arc_set" "', argument " "1"" of type '" "TimingArcSet *""'"); 
  }
  arg1 = reinterpret_cast< TimingArcSet * >(argp1);
  {
    try {
      unset_disable_timing_arc_set(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_clock_gating_check_inst(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_clock_gating_check_inst inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_clock_gating_check_inst" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      disable_clock_gating_check_inst(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disable_clock_gating_check_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disable_clock_gating_check_pin pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disable_clock_gating_check_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      disable_clock_gating_check_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_clock_gating_check_inst(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_clock_gating_check_inst inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_clock_gating_check_inst" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      unset_disable_clock_gating_check_inst(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_disable_clock_gating_check_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_disable_clock_gating_check_pin pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_disable_clock_gating_check_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      unset_disable_clock_gating_check_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_false_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  char *arg5 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::make_false_path from thrus to min_max comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_false_path" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeq<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_false_path" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  res5 = SWIG_AsCharPtrAndSize(objv[5], &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "make_false_path" "', argument " "5"" of type '" "char const *""'");
  }
  arg5 = reinterpret_cast< char * >(buf5);
  {
    try {
      make_false_path(arg1,arg2,arg3,(MinMaxAll const *)arg4,(char const *)arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return TCL_OK;
fail:
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_multicycle_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  bool arg5 ;
  int arg6 ;
  char *arg7 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  int val6 ;
  int ecode6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::make_multicycle_path from thrus to min_max use_end_clk path_multiplier comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_multicycle_path" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeq<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_multicycle_path" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "make_multicycle_path" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "make_multicycle_path" "', argument " "6"" of type '" "int""'");
  } 
  arg6 = static_cast< int >(val6);
  res7 = SWIG_AsCharPtrAndSize(objv[7], &buf7, NULL, &alloc7);
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "make_multicycle_path" "', argument " "7"" of type '" "char const *""'");
  }
  arg7 = reinterpret_cast< char * >(buf7);
  {
    try {
      make_multicycle_path(arg1,arg2,arg3,(MinMaxAll const *)arg4,arg5,arg6,(char const *)arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_OK;
fail:
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_path_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  bool arg5 ;
  float arg6 ;
  char *arg7 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::make_path_delay from thrus to min_max ignore_clk_latency delay comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_path_delay" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeq<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_path_delay" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "make_path_delay" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "make_path_delay" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  res7 = SWIG_AsCharPtrAndSize(objv[7], &buf7, NULL, &alloc7);
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "make_path_delay" "', argument " "7"" of type '" "char const *""'");
  }
  arg7 = reinterpret_cast< char * >(buf7);
  {
    try {
      make_path_delay(arg1,arg2,arg3,(MinMax const *)arg4,arg5,arg6,(char const *)arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_OK;
fail:
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_reset_path_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::reset_path_cmd from thrus to min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "reset_path_cmd" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeq<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "reset_path_cmd" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      reset_path_cmd(arg1,arg2,arg3,(MinMaxAll const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_group_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  ExceptionFrom *arg3 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg4 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg5 = (ExceptionTo *) 0 ;
  char *arg6 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::make_group_path name is_default from thrus to comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_group_path" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "make_group_path" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_group_path" "', argument " "3"" of type '" "ExceptionFrom *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionFrom * >(argp3);
  {
    arg4 = tclListSeq<ExceptionThru*>(objv[4], SWIGTYPE_p_ExceptionThru, interp);
  }
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "make_group_path" "', argument " "5"" of type '" "ExceptionTo *""'"); 
  }
  arg5 = reinterpret_cast< ExceptionTo * >(argp5);
  res6 = SWIG_AsCharPtrAndSize(objv[6], &buf6, NULL, &alloc6);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "make_group_path" "', argument " "6"" of type '" "char const *""'");
  }
  arg6 = reinterpret_cast< char * >(buf6);
  {
    try {
      make_group_path((char const *)arg1,arg2,arg3,arg4,arg5,(char const *)arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_path_group_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_path_group_name name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_path_group_name" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)is_path_group_name((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_exception_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinSet *arg1 = (PinSet *) 0 ;
  ClockSet *arg2 = (ClockSet *) 0 ;
  InstanceSet *arg3 = (InstanceSet *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  ExceptionFrom *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::make_exception_from from_pins from_clks from_insts from_tr ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetPin(objv[1], interp);
  }
  {
    arg2 = tclListSet<Clock*>(objv[2], SWIGTYPE_p_Clock, interp);
  }
  {
    arg3 = tclListSet<Instance*>(objv[3], SWIGTYPE_p_Instance, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    try {
      result = (ExceptionFrom *)make_exception_from(arg1,arg2,arg3,(RiseFallBoth const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_ExceptionFrom, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_exception_from(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_exception_from from ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_exception_from" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    try {
      delete_exception_from(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_exception_from_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::check_exception_from_pins from file line ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_exception_from_pins" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "check_exception_from_pins" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "check_exception_from_pins" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      check_exception_from_pins(arg1,(char const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_exception_thru(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinSet *arg1 = (PinSet *) 0 ;
  NetSet *arg2 = (NetSet *) 0 ;
  InstanceSet *arg3 = (InstanceSet *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  ExceptionThru *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::make_exception_thru pins nets insts rf ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetPin(objv[1], interp);
  }
  {
    arg2 = tclListSet<Net*>(objv[2], SWIGTYPE_p_Net, interp);
  }
  {
    arg3 = tclListSet<Instance*>(objv[3], SWIGTYPE_p_Instance, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    try {
      result = (ExceptionThru *)make_exception_thru(arg1,arg2,arg3,(RiseFallBoth const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_ExceptionThru, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_exception_thru(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionThru *arg1 = (ExceptionThru *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_exception_thru thru ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionThru, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_exception_thru" "', argument " "1"" of type '" "ExceptionThru *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionThru * >(argp1);
  {
    try {
      delete_exception_thru(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_exception_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinSet *arg1 = (PinSet *) 0 ;
  ClockSet *arg2 = (ClockSet *) 0 ;
  InstanceSet *arg3 = (InstanceSet *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  RiseFallBoth *arg5 = (RiseFallBoth *) 0 ;
  ExceptionTo *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::make_exception_to to_pins to_clks to_insts rf end_rf ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetPin(objv[1], interp);
  }
  {
    arg2 = tclListSet<Clock*>(objv[2], SWIGTYPE_p_Clock, interp);
  }
  {
    arg3 = tclListSet<Instance*>(objv[3], SWIGTYPE_p_Instance, interp);
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[5], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg5 = tr;
  }
  {
    try {
      result = (ExceptionTo *)make_exception_to(arg1,arg2,arg3,(RiseFallBoth const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_ExceptionTo, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_exception_to(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionTo *arg1 = (ExceptionTo *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_exception_to to ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_exception_to" "', argument " "1"" of type '" "ExceptionTo *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionTo * >(argp1);
  {
    try {
      delete_exception_to(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_exception_to_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionTo *arg1 = (ExceptionTo *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::check_exception_to_pins to file line ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_exception_to_pins" "', argument " "1"" of type '" "ExceptionTo *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionTo * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "check_exception_to_pins" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "check_exception_to_pins" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  {
    try {
      check_exception_to_pins(arg1,(char const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_input_slew_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_input_slew_cmd port rf min_max slew ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_input_slew_cmd" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_input_slew_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      set_input_slew_cmd(arg1,(RiseFallBoth const *)arg2,(MinMaxAll const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_drive_cell_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyLibrary *arg1 = (LibertyLibrary *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  Port *arg3 = (Port *) 0 ;
  LibertyPort *arg4 = (LibertyPort *) 0 ;
  float arg5 ;
  float arg6 ;
  LibertyPort *arg7 = (LibertyPort *) 0 ;
  RiseFallBoth *arg8 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg9 = (MinMaxAll *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  void *argp4 = 0 ;
  int res4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  void *argp7 = 0 ;
  int res7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooooo:sta::set_drive_cell_cmd library cell port from_port from_slew_rise from_slew_fall to_port rf min_max ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyLibrary, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_drive_cell_cmd" "', argument " "1"" of type '" "LibertyLibrary *""'"); 
  }
  arg1 = reinterpret_cast< LibertyLibrary * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_drive_cell_cmd" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_drive_cell_cmd" "', argument " "3"" of type '" "Port *""'"); 
  }
  arg3 = reinterpret_cast< Port * >(argp3);
  res4 = SWIG_ConvertPtr(objv[4], &argp4,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "set_drive_cell_cmd" "', argument " "4"" of type '" "LibertyPort *""'"); 
  }
  arg4 = reinterpret_cast< LibertyPort * >(argp4);
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_drive_cell_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_drive_cell_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  res7 = SWIG_ConvertPtr(objv[7], &argp7,SWIGTYPE_p_LibertyPort, 0 |  0 );
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "set_drive_cell_cmd" "', argument " "7"" of type '" "LibertyPort *""'"); 
  }
  arg7 = reinterpret_cast< LibertyPort * >(argp7);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[8], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg8 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[9], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg9 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_drive_cell_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,(RiseFallBoth const *)arg8,(MinMaxAll const *)arg9); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_drive_resistance_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  float arg4 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_drive_resistance_cmd port rf min_max res ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_drive_resistance_cmd" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_drive_resistance_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  {
    try {
      set_drive_resistance_cmd(arg1,(RiseFallBoth const *)arg2,(MinMaxAll const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_slew_limit_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  PathClkOrData arg3 ;
  MinMax *arg4 = (MinMax *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_slew_limit_clk clk rf clk_data min_max slew ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_slew_limit_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEq(arg, "clk"))
    arg3 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg3 = PathClkOrData::data;
    else {
      tclArgError(interp, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_slew_limit_clk" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_slew_limit_clk(arg1,(RiseFallBoth const *)arg2,arg3,(MinMax const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_slew_limit_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_slew_limit_port port min_max slew ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_slew_limit_port" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_slew_limit_port" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_slew_limit_port(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_slew_limit_cell(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_slew_limit_cell cell min_max slew ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_slew_limit_cell" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_slew_limit_cell" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_slew_limit_cell(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_capacitance_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_port_capacitance_limit port min_max cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_capacitance_limit" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_port_capacitance_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_port_capacitance_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_pin_capacitance_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_pin_capacitance_limit pin min_max cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_pin_capacitance_limit" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_pin_capacitance_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_pin_capacitance_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cell_capacitance_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_cell_capacitance_limit cell min_max cap ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cell_capacitance_limit" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_cell_capacitance_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_cell_capacitance_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_latch_borrow_limit_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_latch_borrow_limit_pin pin limit ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_latch_borrow_limit_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_latch_borrow_limit_pin" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_latch_borrow_limit_pin(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_latch_borrow_limit_inst(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_latch_borrow_limit_inst inst limit ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_latch_borrow_limit_inst" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_latch_borrow_limit_inst" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_latch_borrow_limit_inst(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_latch_borrow_limit_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  float arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_latch_borrow_limit_clk clk limit ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_latch_borrow_limit_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_latch_borrow_limit_clk" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_latch_borrow_limit_clk(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_min_pulse_width_global(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  RiseFallBoth *arg1 = (RiseFallBoth *) 0 ;
  float arg2 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_min_pulse_width_global rf min_width ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[1], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg1 = tr;
  }
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_min_pulse_width_global" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_min_pulse_width_global((RiseFallBoth const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_min_pulse_width_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_min_pulse_width_pin pin rf min_width ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_min_pulse_width_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_min_pulse_width_pin" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_min_pulse_width_pin(arg1,(RiseFallBoth const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_min_pulse_width_clk(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_min_pulse_width_clk clk rf min_width ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_min_pulse_width_clk" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_min_pulse_width_clk" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_min_pulse_width_clk(arg1,(RiseFallBoth const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_min_pulse_width_inst(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  RiseFallBoth *arg2 = (RiseFallBoth *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_min_pulse_width_inst inst rf min_width ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_min_pulse_width_inst" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_min_pulse_width_inst" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_min_pulse_width_inst(arg1,(RiseFallBoth const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_max_area_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  float arg1 ;
  float val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_max_area_cmd area ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_max_area_cmd" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  {
    try {
      set_max_area_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_port_fanout_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_port_fanout_limit port min_max fanout ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_port_fanout_limit" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_port_fanout_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_port_fanout_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cell_fanout_limit(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Cell *arg1 = (Cell *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_cell_fanout_limit cell min_max fanout ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Cell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cell_fanout_limit" "', argument " "1"" of type '" "Cell *""'"); 
  }
  arg1 = reinterpret_cast< Cell * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_cell_fanout_limit" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_cell_fanout_limit(arg1,(MinMax const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_logic_value_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  LogicValue arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_logic_value_cmd pin value ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_logic_value_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "0") || stringEq(arg, "zero"))
    arg2 = LogicValue::zero;
    else if (stringEq(arg, "1") || stringEq(arg, "one"))
    arg2 = LogicValue::one;
    else if (stringEq(arg, "X"))
    arg2 = LogicValue::unknown;
    else if (stringEq(arg, "rise") || stringEq(arg, "rising"))
    arg2 = LogicValue::rise;
    else if (stringEq(arg, "fall") || stringEq(arg, "falling"))
    arg2 = LogicValue::fall;
    else {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown logic value."),
        TCL_STATIC);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_logic_value_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_case_analysis_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  LogicValue arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_case_analysis_cmd pin value ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_case_analysis_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "0") || stringEq(arg, "zero"))
    arg2 = LogicValue::zero;
    else if (stringEq(arg, "1") || stringEq(arg, "one"))
    arg2 = LogicValue::one;
    else if (stringEq(arg, "X"))
    arg2 = LogicValue::unknown;
    else if (stringEq(arg, "rise") || stringEq(arg, "rising"))
    arg2 = LogicValue::rise;
    else if (stringEq(arg, "fall") || stringEq(arg, "falling"))
    arg2 = LogicValue::fall;
    else {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown logic value."),
        TCL_STATIC);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_case_analysis_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_case_analysis_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_case_analysis_cmd pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_case_analysis_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      unset_case_analysis_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_timing_derate_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingDerateType arg1 ;
  PathClkOrData arg2 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  EarlyLate *arg4 = (EarlyLate *) 0 ;
  float arg5 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_timing_derate_cmd type clk_data rf early_late derate ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    if (stringEq(arg, "net_delay"))
    arg1 = TimingDerateType::net_delay;
    else if (stringEq(arg, "cell_delay"))
    arg1 = TimingDerateType::cell_delay;
    else if (stringEq(arg, "cell_check"))
    arg1 = TimingDerateType::cell_check;
    else {
      tclArgError(interp, "%s not net_delay, cell_delay or cell_check.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "clk"))
    arg2 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg2 = PathClkOrData::data;
    else {
      tclArgError(interp, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    EarlyLate *early_late = EarlyLate::find(arg);
    if (early_late)
    arg4 = early_late;
    else {
      tclArgError(interp, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_timing_derate_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_timing_derate_cmd(arg1,arg2,(RiseFallBoth const *)arg3,(EarlyLate const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_timing_derate_net_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  PathClkOrData arg2 ;
  RiseFallBoth *arg3 = (RiseFallBoth *) 0 ;
  EarlyLate *arg4 = (EarlyLate *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_timing_derate_net_cmd net clk_data rf early_late derate ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_timing_derate_net_cmd" "', argument " "1"" of type '" "Net const *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "clk"))
    arg2 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg2 = PathClkOrData::data;
    else {
      tclArgError(interp, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    EarlyLate *early_late = EarlyLate::find(arg);
    if (early_late)
    arg4 = early_late;
    else {
      tclArgError(interp, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_timing_derate_net_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_timing_derate_net_cmd((Net const *)arg1,arg2,(RiseFallBoth const *)arg3,(EarlyLate const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_timing_derate_inst_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  TimingDerateCellType arg2 ;
  PathClkOrData arg3 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  EarlyLate *arg5 = (EarlyLate *) 0 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_timing_derate_inst_cmd inst type clk_data rf early_late derate ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_timing_derate_inst_cmd" "', argument " "1"" of type '" "Instance const *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "cell_delay"))
    arg2 = TimingDerateCellType::cell_delay;
    else if (stringEq(arg, "cell_check"))
    arg2 = TimingDerateCellType::cell_check;
    else {
      tclArgError(interp, "%s not cell_delay or cell_check.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEq(arg, "clk"))
    arg3 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg3 = PathClkOrData::data;
    else {
      tclArgError(interp, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    EarlyLate *early_late = EarlyLate::find(arg);
    if (early_late)
    arg5 = early_late;
    else {
      tclArgError(interp, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_timing_derate_inst_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_timing_derate_inst_cmd((Instance const *)arg1,arg2,arg3,(RiseFallBoth const *)arg4,(EarlyLate const *)arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_timing_derate_cell_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  TimingDerateCellType arg2 ;
  PathClkOrData arg3 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  EarlyLate *arg5 = (EarlyLate *) 0 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_timing_derate_cell_cmd cell type clk_data rf early_late derate ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_timing_derate_cell_cmd" "', argument " "1"" of type '" "LibertyCell const *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    if (stringEq(arg, "cell_delay"))
    arg2 = TimingDerateCellType::cell_delay;
    else if (stringEq(arg, "cell_check"))
    arg2 = TimingDerateCellType::cell_check;
    else {
      tclArgError(interp, "%s not cell_delay or cell_check.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEq(arg, "clk"))
    arg3 = PathClkOrData::clk;
    else if (stringEq(arg, "data"))
    arg3 = PathClkOrData::data;
    else {
      tclArgError(interp, "%s not clk or data.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[5], &length);
    EarlyLate *early_late = EarlyLate::find(arg);
    if (early_late)
    arg5 = early_late;
    else {
      tclArgError(interp, "%s not early/min, late/max or early_late/min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_timing_derate_cell_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_timing_derate_cell_cmd((LibertyCell const *)arg1,arg2,arg3,(RiseFallBoth const *)arg4,(EarlyLate const *)arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_timing_derate_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::unset_timing_derate_cmd ") == TCL_ERROR) SWIG_fail;
  {
    try {
      unset_timing_derate_cmd(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clock_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::clock_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (ClockIterator *)clock_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_ClockIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  Clock *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_clock name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_clock" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (Clock *)find_clock((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Clock, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_clock_src(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_clock_src pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_clock_src" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_clock_src((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_default_arrival_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::default_arrival_clock ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Clock *)default_arrival_clock(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Clock, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_clocks_matching(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  ClockSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_clocks_matching pattern regexp nocase ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_clocks_matching" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_clocks_matching" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_clocks_matching" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  {
    try {
      result = (ClockSeq *)find_clocks_matching((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    ClockSeq *clks = result;
    ClockSeq::Iterator clk_iter(clks);
    while (clk_iter.hasNext()) {
      Clock *clk = clk_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(clk, SWIGTYPE_p_Clock, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete clks;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_update_generated_clks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::update_generated_clks ") == TCL_ERROR) SWIG_fail;
  {
    try {
      update_generated_clks(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_clock pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_clock" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_ideal_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_ideal_clock pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_ideal_clock" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_ideal_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_clock_search(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_clock_search pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_clock_search" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_clock_search((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_genclk_src(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_genclk_src pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_genclk_src" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (bool)is_genclk_src((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_time value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_time" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_time" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_time((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_capacitance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_capacitance value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_capacitance" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_capacitance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_capacitance((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_resistance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_resistance value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_resistance" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_resistance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_resistance((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_voltage(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_voltage value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_voltage" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_voltage" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_voltage((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_power(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_power value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_power" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_power" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_power((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_distance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_distance value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_distance" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_distance" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_distance((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_format_area(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::format_area value digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "format_area" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "format_area" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      result = (char *)format_area((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_time_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::time_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "time_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)time_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_time_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::time_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "time_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)time_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_capacitance_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::capacitance_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "capacitance_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)capacitance_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_capacitance_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::capacitance_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "capacitance_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)capacitance_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_resistance_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::resistance_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "resistance_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)resistance_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_resistance_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::resistance_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "resistance_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)resistance_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_voltage_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::voltage_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "voltage_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)voltage_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_voltage_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::voltage_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "voltage_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)voltage_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_current_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::current_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "current_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)current_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_current_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::current_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "current_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)current_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_power_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::power_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "power_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)power_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_power_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::power_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "power_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)power_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_distance_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::distance_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "distance_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)distance_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_distance_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::distance_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "distance_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)distance_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_area_ui_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::area_ui_sta value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "area_ui_sta" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)area_ui_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_area_sta_ui(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double arg1 ;
  double val1 ;
  int ecode1 = 0 ;
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::area_sta_ui value ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_double SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "area_sta_ui" "', argument " "1"" of type '" "double""'");
  } 
  arg1 = static_cast< double >(val1);
  {
    try {
      result = (double)area_sta_ui(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_unit_scale(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  float arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_cmd_unit_scale unit_name scale ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_unit_scale" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_cmd_unit_scale" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_cmd_unit_scale((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_unit_digits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_cmd_unit_digits unit_name digits ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_unit_digits" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_cmd_unit_digits" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      set_cmd_unit_digits((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cmd_unit_suffix(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_cmd_unit_suffix unit_name suffix ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_cmd_unit_suffix" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_cmd_unit_suffix" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  {
    try {
      set_cmd_unit_suffix((char const *)arg1,(char const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unit_scale_abreviation(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unit_scale_abreviation unit_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unit_scale_abreviation" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (char *)unit_scale_abreviation((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unit_suffix(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unit_suffix unit_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unit_suffix" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (char *)unit_suffix((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_vertex_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  VertexIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::vertex_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (VertexIterator *)vertex_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_VertexIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_arc_delay(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_arc_delay edge arc corner min_max delay ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_arc_delay" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_arc_delay" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "set_arc_delay" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_arc_delay" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_arc_delay(arg1,arg2,(Corner const *)arg3,(MinMaxAll const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_annotated_slew(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  RiseFallBoth *arg4 = (RiseFallBoth *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_annotated_slew vertex corner min_max rf slew ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_annotated_slew" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_annotated_slew" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[4], &length);
    RiseFallBoth *tr = RiseFallBoth::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg4 = tr;
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_annotated_slew" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_annotated_slew(arg1,(Corner const *)arg2,(MinMaxAll const *)arg3,(RiseFallBoth const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_remove_delay_slew_annotations(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::remove_delay_slew_annotations ") == TCL_ERROR) SWIG_fail;
  {
    try {
      remove_delay_slew_annotations(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_timing_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  CheckErrorSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::check_timing_cmd no_input_delay no_output_delay reg_multiple_clks reg_no_clks unconstrained_endpoints loops generated_clks ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "check_timing_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "check_timing_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "check_timing_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "check_timing_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "check_timing_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "check_timing_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "check_timing_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = (CheckErrorSeq *) &check_timing_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *error_list = Tcl_NewListObj(0, nullptr);
    CheckErrorSeq *check_errors = result;
    CheckErrorSeq::Iterator check_iter(check_errors);
    while (check_iter.hasNext()) {
      CheckError *error = check_iter.next();
      Tcl_Obj *string_list = Tcl_NewListObj(0, nullptr);
      CheckError::Iterator string_iter(error);
      while (string_iter.hasNext()) {
        const char *str = string_iter.next();
        size_t str_len = strlen(str);
        Tcl_Obj *obj = Tcl_NewStringObj(const_cast<char*>(str),
          static_cast<int>(str_len));
        Tcl_ListObjAppendElement(interp, string_list, obj);
      }
      Tcl_ListObjAppendElement(interp, error_list, string_list);
    }
    Tcl_SetObjResult(interp, error_list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_crpr_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::crpr_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)crpr_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_crpr_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_crpr_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_crpr_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_crpr_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_crpr_mode(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::crpr_mode ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (char *)crpr_mode(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_crpr_mode(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_crpr_mode mode ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_crpr_mode" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_crpr_mode((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pocv_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::pocv_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)pocv_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_pocv_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_pocv_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_pocv_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_pocv_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pocv_sigma_factor(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::pocv_sigma_factor ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (float)pocv_sigma_factor(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_pocv_sigma_factor(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  float arg1 ;
  float val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_pocv_sigma_factor factor ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_pocv_sigma_factor" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  {
    try {
      set_pocv_sigma_factor(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_propagate_gated_clock_enable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::propagate_gated_clock_enable ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)propagate_gated_clock_enable(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_propagate_gated_clock_enable(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_propagate_gated_clock_enable enable ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_propagate_gated_clock_enable" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_propagate_gated_clock_enable(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_preset_clr_arcs_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::preset_clr_arcs_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)preset_clr_arcs_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_preset_clr_arcs_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_preset_clr_arcs_enabled enable ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_preset_clr_arcs_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_preset_clr_arcs_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_cond_default_arcs_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::cond_default_arcs_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)cond_default_arcs_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_cond_default_arcs_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_cond_default_arcs_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_cond_default_arcs_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_cond_default_arcs_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_bidirect_inst_paths_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::bidirect_inst_paths_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)bidirect_inst_paths_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_bidirect_inst_paths_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_bidirect_inst_paths_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_bidirect_inst_paths_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_bidirect_inst_paths_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_bidirect_net_paths_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::bidirect_net_paths_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)bidirect_net_paths_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_bidirect_net_paths_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_bidirect_net_paths_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_bidirect_net_paths_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_bidirect_net_paths_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_recovery_removal_checks_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::recovery_removal_checks_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)recovery_removal_checks_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_recovery_removal_checks_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_recovery_removal_checks_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_recovery_removal_checks_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_recovery_removal_checks_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_gated_clk_checks_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::gated_clk_checks_enabled ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)gated_clk_checks_enabled(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_gated_clk_checks_enabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_gated_clk_checks_enabled enabled ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_gated_clk_checks_enabled" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_gated_clk_checks_enabled(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_dynamic_loop_breaking(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::dynamic_loop_breaking ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)dynamic_loop_breaking(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_dynamic_loop_breaking(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_dynamic_loop_breaking enable ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_dynamic_loop_breaking" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_dynamic_loop_breaking(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_use_default_arrival_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::use_default_arrival_clock ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)use_default_arrival_clock(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_use_default_arrival_clock(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_use_default_arrival_clock enable ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_use_default_arrival_clock" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_use_default_arrival_clock(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_propagate_all_clocks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::propagate_all_clocks ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (bool)propagate_all_clocks(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_propagate_all_clocks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_propagate_all_clocks prop ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_propagate_all_clocks" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_propagate_all_clocks(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_path_ends(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ExceptionFrom *arg1 = (ExceptionFrom *) 0 ;
  ExceptionThruSeq *arg2 = (ExceptionThruSeq *) 0 ;
  ExceptionTo *arg3 = (ExceptionTo *) 0 ;
  bool arg4 ;
  Corner *arg5 = (Corner *) 0 ;
  MinMaxAll *arg6 = (MinMaxAll *) 0 ;
  int arg7 ;
  int arg8 ;
  bool arg9 ;
  float arg10 ;
  float arg11 ;
  bool arg12 ;
  PathGroupNameSet *arg13 = (PathGroupNameSet *) 0 ;
  bool arg14 ;
  bool arg15 ;
  bool arg16 ;
  bool arg17 ;
  bool arg18 ;
  bool arg19 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  void *argp5 = 0 ;
  int res5 = 0 ;
  int val7 ;
  int ecode7 = 0 ;
  int val8 ;
  int ecode8 = 0 ;
  bool val9 ;
  int ecode9 = 0 ;
  float val10 ;
  int ecode10 = 0 ;
  float val11 ;
  int ecode11 = 0 ;
  bool val12 ;
  int ecode12 = 0 ;
  bool val14 ;
  int ecode14 = 0 ;
  bool val15 ;
  int ecode15 = 0 ;
  bool val16 ;
  int ecode16 = 0 ;
  bool val17 ;
  int ecode17 = 0 ;
  bool val18 ;
  int ecode18 = 0 ;
  bool val19 ;
  int ecode19 = 0 ;
  PathEndSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooooooooooooooo:sta::find_path_ends from thrus to unconstrained corner delay_min_max group_count endpoint_count unique_pins slack_min slack_max sort_by_slack groups setup hold recovery removal clk_gating_setup clk_gating_hold ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ExceptionFrom, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_path_ends" "', argument " "1"" of type '" "ExceptionFrom *""'"); 
  }
  arg1 = reinterpret_cast< ExceptionFrom * >(argp1);
  {
    arg2 = tclListSeq<ExceptionThru*>(objv[2], SWIGTYPE_p_ExceptionThru, interp);
  }
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_ExceptionTo, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "find_path_ends" "', argument " "3"" of type '" "ExceptionTo *""'"); 
  }
  arg3 = reinterpret_cast< ExceptionTo * >(argp3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_path_ends" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  res5 = SWIG_ConvertPtr(objv[5], &argp5,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "find_path_ends" "', argument " "5"" of type '" "Corner *""'"); 
  }
  arg5 = reinterpret_cast< Corner * >(argp5);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[6], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg6 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode7 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_path_ends" "', argument " "7"" of type '" "int""'");
  } 
  arg7 = static_cast< int >(val7);
  ecode8 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "find_path_ends" "', argument " "8"" of type '" "int""'");
  } 
  arg8 = static_cast< int >(val8);
  ecode9 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "find_path_ends" "', argument " "9"" of type '" "bool""'");
  } 
  arg9 = static_cast< bool >(val9);
  ecode10 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "find_path_ends" "', argument " "10"" of type '" "float""'");
  } 
  arg10 = static_cast< float >(val10);
  ecode11 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[11], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "find_path_ends" "', argument " "11"" of type '" "float""'");
  } 
  arg11 = static_cast< float >(val11);
  ecode12 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[12], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "find_path_ends" "', argument " "12"" of type '" "bool""'");
  } 
  arg12 = static_cast< bool >(val12);
  {
    arg13 = tclListSetConstChar(objv[13], interp);
  }
  ecode14 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[14], &val14);
  if (!SWIG_IsOK(ecode14)) {
    SWIG_exception_fail(SWIG_ArgError(ecode14), "in method '" "find_path_ends" "', argument " "14"" of type '" "bool""'");
  } 
  arg14 = static_cast< bool >(val14);
  ecode15 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[15], &val15);
  if (!SWIG_IsOK(ecode15)) {
    SWIG_exception_fail(SWIG_ArgError(ecode15), "in method '" "find_path_ends" "', argument " "15"" of type '" "bool""'");
  } 
  arg15 = static_cast< bool >(val15);
  ecode16 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[16], &val16);
  if (!SWIG_IsOK(ecode16)) {
    SWIG_exception_fail(SWIG_ArgError(ecode16), "in method '" "find_path_ends" "', argument " "16"" of type '" "bool""'");
  } 
  arg16 = static_cast< bool >(val16);
  ecode17 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[17], &val17);
  if (!SWIG_IsOK(ecode17)) {
    SWIG_exception_fail(SWIG_ArgError(ecode17), "in method '" "find_path_ends" "', argument " "17"" of type '" "bool""'");
  } 
  arg17 = static_cast< bool >(val17);
  ecode18 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[18], &val18);
  if (!SWIG_IsOK(ecode18)) {
    SWIG_exception_fail(SWIG_ArgError(ecode18), "in method '" "find_path_ends" "', argument " "18"" of type '" "bool""'");
  } 
  arg18 = static_cast< bool >(val18);
  ecode19 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[19], &val19);
  if (!SWIG_IsOK(ecode19)) {
    SWIG_exception_fail(SWIG_ArgError(ecode19), "in method '" "find_path_ends" "', argument " "19"" of type '" "bool""'");
  } 
  arg19 = static_cast< bool >(val19);
  {
    try {
      result = (PathEndSeq *)find_path_ends(arg1,arg2,arg3,arg4,arg5,(MinMaxAll const *)arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    const PathEndSeq *path_ends = result;
    PathEndSeq::ConstIterator end_iter(path_ends);
    while (end_iter.hasNext()) {
      PathEnd *path_end = end_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(path_end, SWIGTYPE_p_PathEnd, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    // Delete the PathEndSeq, not the ends.
    delete path_ends;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_end_header(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_path_end_header ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_path_end_header(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_end_footer(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_path_end_footer ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_path_end_footer(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_end(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::report_path_end end ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_path_end" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  {
    try {
      report_path_end(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_end2(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathEnd *arg1 = (PathEnd *) 0 ;
  PathEnd *arg2 = (PathEnd *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_path_end2 end prev_end ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_path_end2" "', argument " "1"" of type '" "PathEnd *""'"); 
  }
  arg1 = reinterpret_cast< PathEnd * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_PathEnd, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_path_end2" "', argument " "2"" of type '" "PathEnd *""'"); 
  }
  arg2 = reinterpret_cast< PathEnd * >(argp2);
  {
    try {
      report_path_end2(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_format(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ReportPathFormat arg1 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_format format ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    if (stringEq(arg, "full"))
    arg1 = ReportPathFormat::full;
    else if (stringEq(arg, "full_clock"))
    arg1 = ReportPathFormat::full_clock;
    else if (stringEq(arg, "full_clock_expanded"))
    arg1 = ReportPathFormat::full_clock_expanded;
    else if (stringEq(arg, "short"))
    arg1 = ReportPathFormat::shorter;
    else if (stringEq(arg, "end"))
    arg1 = ReportPathFormat::endpoint;
    else if (stringEq(arg, "summary"))
    arg1 = ReportPathFormat::summary;
    else if (stringEq(arg, "slack_only"))
    arg1 = ReportPathFormat::slack_only;
    else if (stringEq(arg, "json"))
    arg1 = ReportPathFormat::json;
    else {
      tclArgError(interp, "unknown path type %s.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      set_report_path_format(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_field_order(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  StringSeq *arg1 = (StringSeq *) 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_field_order field_names ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeqConstChar(objv[1], interp);
  }
  {
    try {
      set_report_path_field_order(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_fields(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_report_path_fields report_input_pin report_net report_cap report_slew ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_report_path_fields" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_report_path_fields" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_report_path_fields" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_report_path_fields" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      set_report_path_fields(arg1,arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_field_properties(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  int arg3 ;
  bool arg4 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::set_report_path_field_properties field_name title width left_justify ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_report_path_field_properties" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_report_path_field_properties" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  ecode3 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_report_path_field_properties" "', argument " "3"" of type '" "int""'");
  } 
  arg3 = static_cast< int >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_report_path_field_properties" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  {
    try {
      set_report_path_field_properties((char const *)arg1,(char const *)arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_field_width(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int arg2 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_report_path_field_width field_name width ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_report_path_field_width" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_report_path_field_width" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      set_report_path_field_width((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_digits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_digits digits ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_report_path_digits" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      set_report_path_digits(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_no_split(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_no_split no_split ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_report_path_no_split" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_report_path_no_split(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_report_path_sigmas(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_report_path_sigmas report_sigmas ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_report_path_sigmas" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      set_report_path_sigmas(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_path_ref(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_path_ref path ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_path_ref" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      delete_path_ref(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_remove_constraints(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::remove_constraints ") == TCL_ERROR) SWIG_fail;
  {
    try {
      remove_constraints(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_path_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::report_path_cmd path ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_path_cmd" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      report_path_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_clk_skew(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockSet *arg1 = (ClockSet *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  SetupHold *arg3 = (SetupHold *) 0 ;
  int arg4 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::report_clk_skew clks corner setup_hold digits ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSet<Clock*>(objv[1], SWIGTYPE_p_Clock, interp);
  }
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_clk_skew" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg3 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg3 = MinMax::max();
    else {
      tclArgError(interp, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "report_clk_skew" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  {
    try {
      report_clk_skew(arg1,(Corner const *)arg2,(SetupHold const *)arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_worst_clk_skew_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SetupHold *arg1 = (SetupHold *) 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::worst_clk_skew_cmd setup_hold ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    if (stringEqual(arg, "hold")
      || stringEqual(arg, "min"))
    arg1 = MinMax::min();
    else if (stringEqual(arg, "setup")
      || stringEqual(arg, "max"))
    arg1 = MinMax::max();
    else {
      tclArgError(interp, "%s not setup, hold, min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)worst_clk_skew_cmd((SetupHold const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_startpoints(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::startpoints ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (TmpPinSet *)startpoints(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_endpoints(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::endpoints ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (TmpPinSet *)endpoints(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_group_path_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::group_path_pins group_path_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "group_path_pins" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (TmpPinSet *)group_path_pins((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_pulse_width_violations(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinPulseWidthCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::min_pulse_width_violations corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "min_pulse_width_violations" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = (MinPulseWidthCheckSeq *) &min_pulse_width_violations((Corner const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheckSeq, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_pulse_width_check_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  MinPulseWidthCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::min_pulse_width_check_pins pins corner ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeq<Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "min_pulse_width_check_pins" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    try {
      result = (MinPulseWidthCheckSeq *) &min_pulse_width_check_pins(arg1,(Corner const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheckSeq, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_pulse_width_checks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinPulseWidthCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::min_pulse_width_checks corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "min_pulse_width_checks" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = (MinPulseWidthCheckSeq *) &min_pulse_width_checks((Corner const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheckSeq, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_pulse_width_check_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  MinPulseWidthCheck *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::min_pulse_width_check_slack corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "min_pulse_width_check_slack" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = (MinPulseWidthCheck *)min_pulse_width_check_slack((Corner const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_MinPulseWidthCheck, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_mpw_checks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinPulseWidthCheckSeq *arg1 = (MinPulseWidthCheckSeq *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_mpw_checks checks verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheckSeq, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_mpw_checks" "', argument " "1"" of type '" "MinPulseWidthCheckSeq *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheckSeq * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_mpw_checks" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_mpw_checks(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_mpw_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinPulseWidthCheck *arg1 = (MinPulseWidthCheck *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_mpw_check check verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPulseWidthCheck, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_mpw_check" "', argument " "1"" of type '" "MinPulseWidthCheck *""'"); 
  }
  arg1 = reinterpret_cast< MinPulseWidthCheck * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_mpw_check" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_mpw_check(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_period_violations(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinPeriodCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::min_period_violations ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (MinPeriodCheckSeq *) &min_period_violations(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_MinPeriodCheckSeq,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_min_period_check_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinPeriodCheck *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::min_period_check_slack ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (MinPeriodCheck *)min_period_check_slack(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_MinPeriodCheck,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_min_period_checks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinPeriodCheckSeq *arg1 = (MinPeriodCheckSeq *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_min_period_checks checks verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPeriodCheckSeq, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_min_period_checks" "', argument " "1"" of type '" "MinPeriodCheckSeq *""'"); 
  }
  arg1 = reinterpret_cast< MinPeriodCheckSeq * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_min_period_checks" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_min_period_checks(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_min_period_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinPeriodCheck *arg1 = (MinPeriodCheck *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_min_period_check check verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MinPeriodCheck, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_min_period_check" "', argument " "1"" of type '" "MinPeriodCheck *""'"); 
  }
  arg1 = reinterpret_cast< MinPeriodCheck * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_min_period_check" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_min_period_check(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_skew_violations(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MaxSkewCheckSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_skew_violations ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (MaxSkewCheckSeq *) &max_skew_violations(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_MaxSkewCheckSeq,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_skew_check_slack(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MaxSkewCheck *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_skew_check_slack ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (MaxSkewCheck *)max_skew_check_slack(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_MaxSkewCheck,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_max_skew_checks(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MaxSkewCheckSeq *arg1 = (MaxSkewCheckSeq *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_max_skew_checks checks verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MaxSkewCheckSeq, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_max_skew_checks" "', argument " "1"" of type '" "MaxSkewCheckSeq *""'"); 
  }
  arg1 = reinterpret_cast< MaxSkewCheckSeq * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_max_skew_checks" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_max_skew_checks(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_max_skew_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MaxSkewCheck *arg1 = (MaxSkewCheck *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_max_skew_check check verbose ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_MaxSkewCheck, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_max_skew_check" "', argument " "1"" of type '" "MaxSkewCheck *""'"); 
  }
  arg1 = reinterpret_cast< MaxSkewCheck * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_max_skew_check" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      report_max_skew_check(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_timing_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::find_timing_cmd full ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "find_timing_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  {
    try {
      find_timing_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_requireds(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::find_requireds ") == TCL_ERROR) SWIG_fail;
  {
    try {
      find_requireds(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_delays(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::find_delays ") == TCL_ERROR) SWIG_fail;
  {
    try {
      find_delays(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_total_negative_slack_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::total_negative_slack_cmd min_max ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = total_negative_slack_cmd((MinMax const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_total_negative_slack_corner_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::total_negative_slack_corner_cmd corner min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "total_negative_slack_corner_cmd" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = total_negative_slack_corner_cmd((Corner const *)arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_worst_slack_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::worst_slack_cmd min_max ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = worst_slack_cmd((MinMax const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_worst_slack_vertex(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  MinMax *arg1 = (MinMax *) 0 ;
  Vertex *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::worst_slack_vertex min_max ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[1], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg1 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (Vertex *)worst_slack_vertex((MinMax const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Vertex, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_worst_slack_corner(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::worst_slack_corner corner min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "worst_slack_corner" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = worst_slack_corner((Corner const *)arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_vertex_worst_arrival_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::vertex_worst_arrival_path vertex min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vertex_worst_arrival_path" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (PathRef *)vertex_worst_arrival_path(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_vertex_worst_arrival_path_rf(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::vertex_worst_arrival_path_rf vertex rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vertex_worst_arrival_path_rf" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (PathRef *)vertex_worst_arrival_path_rf(arg1,(RiseFall const *)arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_vertex_worst_slack_path(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  PathRef *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::vertex_worst_slack_path vertex min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "vertex_worst_slack_path" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (PathRef *)vertex_worst_slack_path(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_PathRef,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_clk_min_period(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  bool arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  Slack result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::find_clk_min_period clk ignore_port_paths ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_clk_min_period" "', argument " "1"" of type '" "Clock const *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_clk_min_period" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    try {
      result = find_clk_min_period((Clock const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_SetObjResult(interp,Tcl_NewDoubleObj(delayAsFloat(result)));
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_delay_calc_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  int arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  TmpString *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::report_delay_calc_cmd edge arc corner min_max digits ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_delay_calc_cmd" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_delay_calc_cmd" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "report_delay_calc_cmd" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "report_delay_calc_cmd" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  {
    try {
      result = (TmpString *)report_delay_calc_cmd(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    string *str = result;
    if (str) {
      // String is volatile because it is deleted.
      Tcl_SetResult(interp, const_cast<char*>(str->c_str()), TCL_VOLATILE);
      delete str;
    }
    else
    Tcl_SetResult(interp, nullptr, TCL_STATIC);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_slew_limits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  bool arg2 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PinSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::check_slew_limits net violators corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_slew_limits" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "check_slew_limits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "check_slew_limits" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (PinSeq *)check_slew_limits(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSeq *pins = result;
    PinSeq::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_slew_violation_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  size_t result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_slew_violation_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = max_slew_violation_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_size_t(static_cast< size_t >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_slew_limit_short_header(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_slew_limit_short_header ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_slew_limit_short_header(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_slew_limit_short(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::report_slew_limit_short pin corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_slew_limit_short" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_slew_limit_short" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_slew_limit_short(arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_slew_limit_verbose(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::report_slew_limit_verbose pin corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_slew_limit_verbose" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_slew_limit_verbose" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_slew_limit_verbose(arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_fanout_limits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  bool arg2 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  PinSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::check_fanout_limits net violators min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_fanout_limits" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "check_fanout_limits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (PinSeq *)check_fanout_limits(arg1,arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSeq *pins = result;
    PinSeq::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_fanout_violation_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  size_t result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_fanout_violation_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = max_fanout_violation_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_size_t(static_cast< size_t >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_fanout_limit_short_header(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_fanout_limit_short_header ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_fanout_limit_short_header(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_fanout_limit_short(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_fanout_limit_short pin min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_fanout_limit_short" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_fanout_limit_short(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_fanout_limit_verbose(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  MinMax *arg2 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::report_fanout_limit_verbose pin min_max ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_fanout_limit_verbose" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[2], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg2 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_fanout_limit_verbose(arg1,(MinMax const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_check_capacitance_limits(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  bool arg2 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  PinSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::check_capacitance_limits net violators corner min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "check_capacitance_limits" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "check_capacitance_limits" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "check_capacitance_limits" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (PinSeq *)check_capacitance_limits(arg1,arg2,(Corner const *)arg3,(MinMax const *)arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSeq *pins = result;
    PinSeq::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_max_capacitance_violation_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  size_t result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::max_capacitance_violation_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = max_capacitance_violation_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_size_t(static_cast< size_t >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_capacitance_limit_short_header(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_capacitance_limit_short_header ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_capacitance_limit_short_header(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_capacitance_limit_short(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::report_capacitance_limit_short pin corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_capacitance_limit_short" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_capacitance_limit_short" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_capacitance_limit_short(arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_capacitance_limit_verbose(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::report_capacitance_limit_verbose pin corner min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_capacitance_limit_verbose" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "report_capacitance_limit_verbose" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      report_capacitance_limit_verbose(arg1,(Corner const *)arg2,(MinMax const *)arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_design_power(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Corner *arg1 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TmpFloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::design_power corner ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "design_power" "', argument " "1"" of type '" "Corner const *""'"); 
  }
  arg1 = reinterpret_cast< Corner * >(argp1);
  {
    try {
      result = (TmpFloatSeq *)design_power((Corner const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (unsigned i = 0; i < floats->size(); i++) {
        Tcl_Obj *obj = Tcl_NewDoubleObj((*floats)[i]);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
      delete floats;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_instance_power(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  TmpFloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::instance_power inst corner ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "instance_power" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "instance_power" "', argument " "2"" of type '" "Corner const *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  {
    try {
      result = (TmpFloatSeq *)instance_power(arg1,(Corner const *)arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (unsigned i = 0; i < floats->size(); i++) {
        Tcl_Obj *obj = Tcl_NewDoubleObj((*floats)[i]);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
      delete floats;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_power_global_activity(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  float arg1 ;
  float arg2 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_power_global_activity activity duty ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_power_global_activity" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_power_global_activity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_power_global_activity(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_power_input_activity(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  float arg1 ;
  float arg2 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::set_power_input_activity activity duty ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_power_input_activity" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_power_input_activity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      set_power_input_activity(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_power_input_port_activity(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_power_input_port_activity input_port activity duty ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_power_input_port_activity" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_power_input_port_activity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_power_input_port_activity" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_power_input_port_activity((Port const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_power_pin_activity(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  float arg2 ;
  float arg3 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  float val3 ;
  int ecode3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::set_power_pin_activity pin activity duty ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_power_pin_activity" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "set_power_pin_activity" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  ecode3 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_power_pin_activity" "', argument " "3"" of type '" "float""'");
  } 
  arg3 = static_cast< float >(val3);
  {
    try {
      set_power_pin_activity((Pin const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disabled_edges_sorted(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  EdgeSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::disabled_edges_sorted ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (EdgeSeq *)disabled_edges_sorted(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    EdgeSeq *edges = result;
    EdgeSeq::Iterator edge_iter(edges);
    while (edge_iter.hasNext()) {
      Edge *edge = edge_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(edge, SWIGTYPE_p_Edge, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete edges;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_write_sdc_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  bool arg5 ;
  bool arg6 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::write_sdc_cmd filename leaf compatible digits gzip no_timestamp ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write_sdc_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "write_sdc_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "write_sdc_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "write_sdc_cmd" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "write_sdc_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "write_sdc_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  {
    try {
      write_sdc_cmd((char const *)arg1,arg2,arg3,arg4,arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_write_path_spice_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  char *arg2 = (char *) 0 ;
  char *arg3 = (char *) 0 ;
  char *arg4 = (char *) 0 ;
  char *arg5 = (char *) 0 ;
  char *arg6 = (char *) 0 ;
  char *arg7 = (char *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  int res3 ;
  char *buf3 = 0 ;
  int alloc3 = 0 ;
  int res4 ;
  char *buf4 = 0 ;
  int alloc4 = 0 ;
  int res5 ;
  char *buf5 = 0 ;
  int alloc5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  int res7 ;
  char *buf7 = 0 ;
  int alloc7 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::write_path_spice_cmd path spice_filename subckt_filename lib_subckt_filename model_filename power_name gnd_name ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write_path_spice_cmd" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "write_path_spice_cmd" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_AsCharPtrAndSize(objv[3], &buf3, NULL, &alloc3);
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "write_path_spice_cmd" "', argument " "3"" of type '" "char const *""'");
  }
  arg3 = reinterpret_cast< char * >(buf3);
  res4 = SWIG_AsCharPtrAndSize(objv[4], &buf4, NULL, &alloc4);
  if (!SWIG_IsOK(res4)) {
    SWIG_exception_fail(SWIG_ArgError(res4), "in method '" "write_path_spice_cmd" "', argument " "4"" of type '" "char const *""'");
  }
  arg4 = reinterpret_cast< char * >(buf4);
  res5 = SWIG_AsCharPtrAndSize(objv[5], &buf5, NULL, &alloc5);
  if (!SWIG_IsOK(res5)) {
    SWIG_exception_fail(SWIG_ArgError(res5), "in method '" "write_path_spice_cmd" "', argument " "5"" of type '" "char const *""'");
  }
  arg5 = reinterpret_cast< char * >(buf5);
  res6 = SWIG_AsCharPtrAndSize(objv[6], &buf6, NULL, &alloc6);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "write_path_spice_cmd" "', argument " "6"" of type '" "char const *""'");
  }
  arg6 = reinterpret_cast< char * >(buf6);
  res7 = SWIG_AsCharPtrAndSize(objv[7], &buf7, NULL, &alloc7);
  if (!SWIG_IsOK(res7)) {
    SWIG_exception_fail(SWIG_ArgError(res7), "in method '" "write_path_spice_cmd" "', argument " "7"" of type '" "char const *""'");
  }
  arg7 = reinterpret_cast< char * >(buf7);
  {
    try {
      write_path_spice_cmd(arg1,(char const *)arg2,(char const *)arg3,(char const *)arg4,(char const *)arg5,(char const *)arg6,(char const *)arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_OK;
fail:
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  if (alloc3 == SWIG_NEWOBJ) delete[] buf3;
  if (alloc4 == SWIG_NEWOBJ) delete[] buf4;
  if (alloc5 == SWIG_NEWOBJ) delete[] buf5;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  if (alloc7 == SWIG_NEWOBJ) delete[] buf7;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_liberty_supply_exists(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::liberty_supply_exists supply_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "liberty_supply_exists" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)liberty_supply_exists((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unit_scale(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unit_scale unit_name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unit_scale" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (float)unit_scale((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_fuzzy_equal(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  float arg1 ;
  float arg2 ;
  float val1 ;
  int ecode1 = 0 ;
  float val2 ;
  int ecode2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::fuzzy_equal value1 value2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "fuzzy_equal" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  ecode2 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "fuzzy_equal" "', argument " "2"" of type '" "float""'");
  } 
  arg2 = static_cast< float >(val2);
  {
    try {
      result = (bool)fuzzy_equal(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_sim_logic_value(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_sim_logic_value pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_sim_logic_value" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char)pin_sim_logic_value((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_char(static_cast< char >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_case_logic_value(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_case_logic_value pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_case_logic_value" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char)pin_case_logic_value((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_char(static_cast< char >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_logic_value(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_logic_value pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_logic_value" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char)pin_logic_value((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_char(static_cast< char >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_slow_driver_iterator(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SlowDrvrIterator *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::slow_driver_iterator ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (SlowDrvrIterator *)slow_driver_iterator(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_SlowDrvrIterator, false);
    Tcl_SetObjResult(interp, obj);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_timing_arc_disabled(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Edge *arg1 = (Edge *) 0 ;
  TimingArc *arg2 = (TimingArc *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::timing_arc_disabled edge arc ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Edge, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "timing_arc_disabled" "', argument " "1"" of type '" "Edge *""'"); 
  }
  arg1 = reinterpret_cast< Edge * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_TimingArc, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "timing_arc_disabled" "', argument " "2"" of type '" "TimingArc *""'"); 
  }
  arg2 = reinterpret_cast< TimingArc * >(argp2);
  {
    try {
      result = (bool)timing_arc_disabled(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_clock_groups(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  char *arg6 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  int res6 ;
  char *buf6 = 0 ;
  int alloc6 = 0 ;
  ClockGroups *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::make_clock_groups name logically_exclusive physically_exclusive asynchronous allow_paths comment ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_clock_groups" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "make_clock_groups" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "make_clock_groups" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "make_clock_groups" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "make_clock_groups" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  res6 = SWIG_AsCharPtrAndSize(objv[6], &buf6, NULL, &alloc6);
  if (!SWIG_IsOK(res6)) {
    SWIG_exception_fail(SWIG_ArgError(res6), "in method '" "make_clock_groups" "', argument " "6"" of type '" "char const *""'");
  }
  arg6 = reinterpret_cast< char * >(buf6);
  {
    try {
      result = (ClockGroups *)make_clock_groups((char const *)arg1,arg2,arg3,arg4,arg5,(char const *)arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_ClockGroups,0));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc6 == SWIG_NEWOBJ) delete[] buf6;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clock_groups_make_group(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  ClockGroups *arg1 = (ClockGroups *) 0 ;
  ClockSet *arg2 = (ClockSet *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::clock_groups_make_group clk_groups clks ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_ClockGroups, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "clock_groups_make_group" "', argument " "1"" of type '" "ClockGroups *""'"); 
  }
  arg1 = reinterpret_cast< ClockGroups * >(argp1);
  {
    arg2 = tclListSet<Clock*>(objv[2], SWIGTYPE_p_Clock, interp);
  }
  {
    try {
      clock_groups_make_group(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_groups_logically_exclusive(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_clock_groups_logically_exclusive name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_groups_logically_exclusive" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      unset_clock_groups_logically_exclusive((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_groups_physically_exclusive(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_clock_groups_physically_exclusive name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_groups_physically_exclusive" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      unset_clock_groups_physically_exclusive((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_unset_clock_groups_asynchronous(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::unset_clock_groups_asynchronous name ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "unset_clock_groups_asynchronous" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      unset_clock_groups_asynchronous((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_same_clk_group(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Clock *arg1 = (Clock *) 0 ;
  Clock *arg2 = (Clock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::same_clk_group clk1 clk2 ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "same_clk_group" "', argument " "1"" of type '" "Clock *""'"); 
  }
  arg1 = reinterpret_cast< Clock * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Clock, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "same_clk_group" "', argument " "2"" of type '" "Clock *""'"); 
  }
  arg2 = reinterpret_cast< Clock * >(argp2);
  {
    try {
      result = (bool)same_clk_group(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_clock_sense_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinSet *arg1 = (PinSet *) 0 ;
  ClockSet *arg2 = (ClockSet *) 0 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_clock_sense_cmd pins clks positive negative stop_propagation ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSetPin(objv[1], interp);
  }
  {
    arg2 = tclListSet<Clock*>(objv[2], SWIGTYPE_p_Clock, interp);
  }
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "set_clock_sense_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_clock_sense_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_clock_sense_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    try {
      set_clock_sense_cmd(arg1,arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_timing_role_is_check(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TimingRole *arg1 = (TimingRole *) 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::timing_role_is_check role ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[1], &length);
    TimingRole *role = TimingRole::find(arg);
    if (role)
    arg1 = TimingRole::find(arg);
    else {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown timing role."),
        TCL_STATIC);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (bool)timing_role_is_check(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_fanin_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::find_fanin_pins to flat startpoints_only inst_levels pin_levels thru_disabled thru_constants ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeq<Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_fanin_pins" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_fanin_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_fanin_pins" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "find_fanin_pins" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "find_fanin_pins" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_fanin_pins" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = (TmpPinSet *)find_fanin_pins(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_fanin_insts(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  TmpInstanceSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::find_fanin_insts to flat startpoints_only inst_levels pin_levels thru_disabled thru_constants ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeq<Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_fanin_insts" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_fanin_insts" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_fanin_insts" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "find_fanin_insts" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "find_fanin_insts" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_fanin_insts" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = (TmpInstanceSet *)find_fanin_insts(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    InstanceSet *insts = result;
    InstanceSet::Iterator inst_iter(insts);
    while (inst_iter.hasNext()) {
      Instance *inst = inst_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(inst, SWIGTYPE_p_Instance,false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete insts;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_fanout_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::find_fanout_pins from flat endpoints_only inst_levels pin_levels thru_disabled thru_constants ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeq<Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_fanout_pins" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_fanout_pins" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_fanout_pins" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "find_fanout_pins" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "find_fanout_pins" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_fanout_pins" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = (TmpPinSet *)find_fanout_pins(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_fanout_insts(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PinSeq *arg1 = (PinSeq *) 0 ;
  bool arg2 ;
  bool arg3 ;
  int arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  int val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  TmpInstanceSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooo:sta::find_fanout_insts from flat endpoints_only inst_levels pin_levels thru_disabled thru_constants ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  {
    arg1 = tclListSeq<Pin*>(objv[1], SWIGTYPE_p_Pin, interp);
  }
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "find_fanout_insts" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "find_fanout_insts" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "find_fanout_insts" "', argument " "4"" of type '" "int""'");
  } 
  arg4 = static_cast< int >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "find_fanout_insts" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "find_fanout_insts" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "find_fanout_insts" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  {
    try {
      result = (TmpInstanceSet *)find_fanout_insts(arg1,arg2,arg3,arg4,arg5,arg6,arg7); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    InstanceSet *insts = result;
    InstanceSet::Iterator inst_iter(insts);
    while (inst_iter.hasNext()) {
      Instance *inst = inst_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(inst, SWIGTYPE_p_Instance,false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete insts;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_net_load_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::net_load_pins net ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "net_load_pins" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (TmpPinSet *)net_load_pins(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_net_driver_pins(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TmpPinSet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::net_driver_pins net ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "net_driver_pins" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (TmpPinSet *)net_driver_pins(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    PinSet *pins = result;
    PinSet::Iterator pin_iter(pins);
    while (pin_iter.hasNext()) {
      Pin *pin = pin_iter.next();
      Tcl_Obj *obj = SWIG_NewInstanceObj(pin, SWIGTYPE_p_Pin, false);
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    delete pins;
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_loops(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_loops ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_loops(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_instance_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_instance_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_instance_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_pin_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_pin_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_pin_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_net_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_net_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_net_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_leaf_instance_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_leaf_instance_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_leaf_instance_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_leaf_pin_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_leaf_pin_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)network_leaf_pin_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_graph_vertex_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::graph_vertex_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)graph_vertex_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_graph_edge_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::graph_edge_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)graph_edge_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_graph_arc_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::graph_arc_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)graph_arc_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_tag_group_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::tag_group_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)tag_group_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_tag_groups(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_tag_groups ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_tag_groups(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_tag_arrivals_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Vertex *arg1 = (Vertex *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::report_tag_arrivals_cmd vertex ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Vertex, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "report_tag_arrivals_cmd" "', argument " "1"" of type '" "Vertex *""'"); 
  }
  arg1 = reinterpret_cast< Vertex * >(argp1);
  {
    try {
      report_tag_arrivals_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_arrival_count_histogram(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_arrival_count_histogram ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_arrival_count_histogram(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_tag_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::tag_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)tag_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_tags(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_tags ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_tags(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_clk_infos(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::report_clk_infos ") == TCL_ERROR) SWIG_fail;
  {
    try {
      report_clk_infos(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clk_info_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::clk_info_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)clk_info_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_arrival_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::arrival_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)arrival_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_required_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::required_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)required_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_graph_arrival_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::graph_arrival_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)graph_arrival_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_graph_required_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::graph_required_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)graph_required_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_all_memory(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::delete_all_memory ") == TCL_ERROR) SWIG_fail;
  {
    try {
      delete_all_memory(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_tcl_interp(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Tcl_Interp *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::tcl_interp ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (Tcl_Interp *)tcl_interp(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_Tcl_Interp,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_init_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::init_sta ") == TCL_ERROR) SWIG_fail;
  {
    try {
      init_sta(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clear_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::clear_sta ") == TCL_ERROR) SWIG_fail;
  {
    try {
      clear_sta(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Tcl_Interp *arg1 = (Tcl_Interp *) 0 ;
  
  {
    arg1 = interp;
  }
  if (SWIG_GetArgs(interp, objc, objv,":sta::make_sta ") == TCL_ERROR) SWIG_fail;
  {
    try {
      make_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_clear_network(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::clear_network ") == TCL_ERROR) SWIG_fail;
  {
    try {
      clear_network(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_elapsed_run_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::elapsed_run_time ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (double)elapsed_run_time(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_user_run_time(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  double result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::user_run_time ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (double)user_run_time(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_double(static_cast< double >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_cputime(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  unsigned long result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::cputime ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (unsigned long)cputime(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_memory_usage(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  unsigned long result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::memory_usage ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (unsigned long)memory_usage(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_long(static_cast< unsigned long >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_processor_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::processor_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)processor_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_thread_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::thread_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)thread_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_thread_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int arg1 ;
  int val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_thread_count count ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_thread_count" "', argument " "1"" of type '" "int""'");
  } 
  arg1 = static_cast< int >(val1);
  {
    try {
      set_thread_count(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_arrivals_invalid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::arrivals_invalid ") == TCL_ERROR) SWIG_fail;
  {
    try {
      arrivals_invalid(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delays_invalid(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::delays_invalid ") == TCL_ERROR) SWIG_fail;
  {
    try {
      delays_invalid(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_pin_location(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::pin_location pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "pin_location" "', argument " "1"" of type '" "Pin const *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (char *)pin_location((Pin const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_port_location(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  char *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::port_location port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "port_location" "', argument " "1"" of type '" "Port const *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (char *)port_location((Port const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_FromCharPtr((const char *)result));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_endpoint_count(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  int result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::endpoint_count ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (int)endpoint_count(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_int(static_cast< int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_instance_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  Instance *arg3 = (Instance *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  Instance *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::make_instance_cmd name cell parent ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_instance_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "make_instance_cmd" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "make_instance_cmd" "', argument " "3"" of type '" "Instance *""'"); 
  }
  arg3 = reinterpret_cast< Instance * >(argp3);
  {
    try {
      result = (Instance *)make_instance_cmd((char const *)arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Instance, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_instance_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_instance_cmd inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_instance_cmd" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      delete_instance_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_replace_cell_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  LibertyCell *arg2 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::replace_cell_cmd inst to_cell ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "replace_cell_cmd" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "replace_cell_cmd" "', argument " "2"" of type '" "LibertyCell *""'"); 
  }
  arg2 = reinterpret_cast< LibertyCell * >(argp2);
  {
    try {
      replace_cell_cmd(arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_make_net_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  Instance *arg2 = (Instance *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  Net *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::make_net_cmd name parent ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_net_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "make_net_cmd" "', argument " "2"" of type '" "Instance *""'"); 
  }
  arg2 = reinterpret_cast< Instance * >(argp2);
  {
    try {
      result = (Net *)make_net_cmd((char const *)arg1,arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    Tcl_Obj *obj = SWIG_NewInstanceObj(result, SWIGTYPE_p_Net, false);
    Tcl_SetObjResult(interp, obj);
  }
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_net_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_net_cmd net ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_net_cmd" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      delete_net_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_connect_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  Port *arg2 = (Port *) 0 ;
  Net *arg3 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::connect_pin_cmd inst port net ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "connect_pin_cmd" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "connect_pin_cmd" "', argument " "2"" of type '" "Port *""'"); 
  }
  arg2 = reinterpret_cast< Port * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "connect_pin_cmd" "', argument " "3"" of type '" "Net *""'"); 
  }
  arg3 = reinterpret_cast< Net * >(argp3);
  {
    try {
      connect_pin_cmd(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_disconnect_pin_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::disconnect_pin_cmd pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "disconnect_pin_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      disconnect_pin_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_network_changed(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::network_changed ") == TCL_ERROR) SWIG_fail;
  {
    try {
      network_changed(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_read_sdf_file(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  char *arg2 = (char *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  bool arg4 ;
  bool arg5 ;
  MinMaxAllNull *arg6 = (MinMaxAllNull *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  int res2 ;
  char *buf2 = 0 ;
  int alloc2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::read_sdf_file filename path corner unescaped_dividers incremental_only cond_use ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read_sdf_file" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_AsCharPtrAndSize(objv[2], &buf2, NULL, &alloc2);
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "read_sdf_file" "', argument " "2"" of type '" "char const *""'");
  }
  arg2 = reinterpret_cast< char * >(buf2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "read_sdf_file" "', argument " "3"" of type '" "Corner *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "read_sdf_file" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "read_sdf_file" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[6], &length);
    if (stringEqual(arg, "NULL"))
    arg6 = nullptr;
    else {
      MinMaxAll *min_max = MinMaxAll::find(arg);
      if (min_max)
      arg6 = min_max;
      else {
        tclArgError(interp, "%s not min, max or min_max.", arg);
        return TCL_ERROR;
      }
    }
  }
  {
    try {
      result = (bool)read_sdf_file((char const *)arg1,(char const *)arg2,arg3,arg4,arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  if (alloc2 == SWIG_NEWOBJ) delete[] buf2;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_annotated_delay_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  unsigned int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool arg8 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  unsigned int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val8 ;
  int ecode8 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooo:sta::report_annotated_delay_cmd report_cells report_nets report_in_ports report_out_ports max_lines list_annotated list_not_annotated report_constant_arcs ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_annotated_delay_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_annotated_delay_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_annotated_delay_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "report_annotated_delay_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_unsigned_SS_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "report_annotated_delay_cmd" "', argument " "5"" of type '" "unsigned int""'");
  } 
  arg5 = static_cast< unsigned int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "report_annotated_delay_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "report_annotated_delay_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  ecode8 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "report_annotated_delay_cmd" "', argument " "8"" of type '" "bool""'");
  } 
  arg8 = static_cast< bool >(val8);
  {
    try {
      report_annotated_delay_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_report_annotated_check_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  bool arg1 ;
  bool arg2 ;
  bool arg3 ;
  bool arg4 ;
  bool arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool arg8 ;
  unsigned int arg9 ;
  bool arg10 ;
  bool arg11 ;
  bool arg12 ;
  bool val1 ;
  int ecode1 = 0 ;
  bool val2 ;
  int ecode2 = 0 ;
  bool val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val8 ;
  int ecode8 = 0 ;
  unsigned int val9 ;
  int ecode9 = 0 ;
  bool val10 ;
  int ecode10 = 0 ;
  bool val11 ;
  int ecode11 = 0 ;
  bool val12 ;
  int ecode12 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooooooo:sta::report_annotated_check_cmd report_setup report_hold report_recovery report_removal report_nochange report_width report_period report_max_skew max_lines list_annotated list_not_annotated report_constant_arcs ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "report_annotated_check_cmd" "', argument " "1"" of type '" "bool""'");
  } 
  arg1 = static_cast< bool >(val1);
  ecode2 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "report_annotated_check_cmd" "', argument " "2"" of type '" "bool""'");
  } 
  arg2 = static_cast< bool >(val2);
  ecode3 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "report_annotated_check_cmd" "', argument " "3"" of type '" "bool""'");
  } 
  arg3 = static_cast< bool >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "report_annotated_check_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "report_annotated_check_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "report_annotated_check_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "report_annotated_check_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  ecode8 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "report_annotated_check_cmd" "', argument " "8"" of type '" "bool""'");
  } 
  arg8 = static_cast< bool >(val8);
  ecode9 = SWIG_AsVal_unsigned_SS_int SWIG_TCL_CALL_ARGS_2(objv[9], &val9);
  if (!SWIG_IsOK(ecode9)) {
    SWIG_exception_fail(SWIG_ArgError(ecode9), "in method '" "report_annotated_check_cmd" "', argument " "9"" of type '" "unsigned int""'");
  } 
  arg9 = static_cast< unsigned int >(val9);
  ecode10 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "report_annotated_check_cmd" "', argument " "10"" of type '" "bool""'");
  } 
  arg10 = static_cast< bool >(val10);
  ecode11 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[11], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "report_annotated_check_cmd" "', argument " "11"" of type '" "bool""'");
  } 
  arg11 = static_cast< bool >(val11);
  ecode12 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[12], &val12);
  if (!SWIG_IsOK(ecode12)) {
    SWIG_exception_fail(SWIG_ArgError(ecode12), "in method '" "report_annotated_check_cmd" "', argument " "12"" of type '" "bool""'");
  } 
  arg12 = static_cast< bool >(val12);
  {
    try {
      report_annotated_check_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_write_sdf_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  Corner *arg2 = (Corner *) 0 ;
  char arg3 ;
  bool arg4 ;
  int arg5 ;
  bool arg6 ;
  bool arg7 ;
  bool arg8 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  char val3 ;
  int ecode3 = 0 ;
  bool val4 ;
  int ecode4 = 0 ;
  int val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  bool val8 ;
  int ecode8 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooooo:sta::write_sdf_cmd filename corner divider include_typ digits gzip no_timestamp no_version ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "write_sdf_cmd" "', argument " "1"" of type '" "char *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "write_sdf_cmd" "', argument " "2"" of type '" "Corner *""'"); 
  }
  arg2 = reinterpret_cast< Corner * >(argp2);
  ecode3 = SWIG_AsVal_char SWIG_TCL_CALL_ARGS_2(objv[3], &val3);
  if (!SWIG_IsOK(ecode3)) {
    SWIG_exception_fail(SWIG_ArgError(ecode3), "in method '" "write_sdf_cmd" "', argument " "3"" of type '" "char""'");
  } 
  arg3 = static_cast< char >(val3);
  ecode4 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "write_sdf_cmd" "', argument " "4"" of type '" "bool""'");
  } 
  arg4 = static_cast< bool >(val4);
  ecode5 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "write_sdf_cmd" "', argument " "5"" of type '" "int""'");
  } 
  arg5 = static_cast< int >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "write_sdf_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "write_sdf_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  ecode8 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "write_sdf_cmd" "', argument " "8"" of type '" "bool""'");
  } 
  arg8 = static_cast< bool >(val8);
  {
    try {
      write_sdf_cmd(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delay_calc_names(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  TmpStringSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::delay_calc_names ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (TmpStringSeq *)delay_calc_names(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    StringSeq *strs = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    StringSeq::Iterator str_iter(strs);
    while (str_iter.hasNext()) {
      const char *str = str_iter.next();
      Tcl_Obj *obj = Tcl_NewStringObj(str, strlen(str));
      Tcl_ListObjAppendElement(interp, list, obj);
    }
    Tcl_SetObjResult(interp, list);
    delete strs;
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_is_delay_calc_name(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::is_delay_calc_name alg ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "is_delay_calc_name" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      result = (bool)is_delay_calc_name((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_delay_calculator_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_delay_calculator_cmd alg ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_delay_calculator_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  {
    try {
      set_delay_calculator_cmd((char const *)arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_delay_calc_incremental_tolerance(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  float arg1 ;
  float val1 ;
  int ecode1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::set_delay_calc_incremental_tolerance tol ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "set_delay_calc_incremental_tolerance" "', argument " "1"" of type '" "float""'");
  } 
  arg1 = static_cast< float >(val1);
  {
    try {
      set_delay_calc_incremental_tolerance(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_read_spef_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  char *arg1 = (char *) 0 ;
  Instance *arg2 = (Instance *) 0 ;
  Corner *arg3 = (Corner *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  bool arg5 ;
  bool arg6 ;
  bool arg7 ;
  float arg8 ;
  ReducedParasiticType arg9 ;
  bool arg10 ;
  bool arg11 ;
  int res1 ;
  char *buf1 = 0 ;
  int alloc1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  bool val5 ;
  int ecode5 = 0 ;
  bool val6 ;
  int ecode6 = 0 ;
  bool val7 ;
  int ecode7 = 0 ;
  float val8 ;
  int ecode8 = 0 ;
  bool val10 ;
  int ecode10 = 0 ;
  bool val11 ;
  int ecode11 = 0 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooooooooo:sta::read_spef_cmd filename instance corner min_max increment pin_cap_included keep_coupling_caps coupling_cap_factor reduce_to delete_after_reduce quiet ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_AsCharPtrAndSize(objv[1], &buf1, NULL, &alloc1);
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "read_spef_cmd" "', argument " "1"" of type '" "char const *""'");
  }
  arg1 = reinterpret_cast< char * >(buf1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "read_spef_cmd" "', argument " "2"" of type '" "Instance *""'"); 
  }
  arg2 = reinterpret_cast< Instance * >(argp2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3,SWIGTYPE_p_Corner, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "read_spef_cmd" "', argument " "3"" of type '" "Corner const *""'"); 
  }
  arg3 = reinterpret_cast< Corner * >(argp3);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "read_spef_cmd" "', argument " "5"" of type '" "bool""'");
  } 
  arg5 = static_cast< bool >(val5);
  ecode6 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "read_spef_cmd" "', argument " "6"" of type '" "bool""'");
  } 
  arg6 = static_cast< bool >(val6);
  ecode7 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[7], &val7);
  if (!SWIG_IsOK(ecode7)) {
    SWIG_exception_fail(SWIG_ArgError(ecode7), "in method '" "read_spef_cmd" "', argument " "7"" of type '" "bool""'");
  } 
  arg7 = static_cast< bool >(val7);
  ecode8 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[8], &val8);
  if (!SWIG_IsOK(ecode8)) {
    SWIG_exception_fail(SWIG_ArgError(ecode8), "in method '" "read_spef_cmd" "', argument " "8"" of type '" "float""'");
  } 
  arg8 = static_cast< float >(val8);
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[9], &length);
    if (stringEq(arg, "pi_elmore"))
    arg9 = ReducedParasiticType::pi_elmore;
    else if (stringEq(arg, "pi_pole_residue2"))
    arg9 = ReducedParasiticType::pi_pole_residue2;
    else if (stringEq(arg, "none"))
    arg9 = ReducedParasiticType::none;
    else {
      tclArgError(interp, "%s pi_elmore, pi_pole_residue2, or none.", arg);
      return TCL_ERROR;
    }
  }
  ecode10 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[10], &val10);
  if (!SWIG_IsOK(ecode10)) {
    SWIG_exception_fail(SWIG_ArgError(ecode10), "in method '" "read_spef_cmd" "', argument " "10"" of type '" "bool""'");
  } 
  arg10 = static_cast< bool >(val10);
  ecode11 = SWIG_AsVal_bool SWIG_TCL_CALL_ARGS_2(objv[11], &val11);
  if (!SWIG_IsOK(ecode11)) {
    SWIG_exception_fail(SWIG_ArgError(ecode11), "in method '" "read_spef_cmd" "', argument " "11"" of type '" "bool""'");
  } 
  arg11 = static_cast< bool >(val11);
  {
    try {
      result = (bool)read_spef_cmd((char const *)arg1,arg2,(Corner const *)arg3,(MinMaxAll const *)arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_OK;
fail:
  if (alloc1 == SWIG_NEWOBJ) delete[] buf1;
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_pi_elmore(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMax *arg3 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  TmpFloatSeq *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::find_pi_elmore drvr_pin rf min_max ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_pi_elmore" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (TmpFloatSeq *)find_pi_elmore(arg1,arg2,arg3); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    FloatSeq *floats = result;
    Tcl_Obj *list = Tcl_NewListObj(0, nullptr);
    if (floats) {
      for (unsigned i = 0; i < floats->size(); i++) {
        Tcl_Obj *obj = Tcl_NewDoubleObj((*floats)[i]);
        Tcl_ListObjAppendElement(interp, list, obj);
      }
      delete floats;
    }
    Tcl_SetObjResult(interp, list);
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_elmore(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  RiseFall *arg3 = (RiseFall *) 0 ;
  MinMax *arg4 = (MinMax *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float result;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooo:sta::find_elmore drvr_pin load_pin rf min_max ",(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "find_elmore" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "find_elmore" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMax *min_max = MinMax::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min or max.", arg);
      return TCL_ERROR;
    }
  }
  {
    try {
      result = (float)find_elmore(arg1,arg2,arg3,arg4); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_float(static_cast< float >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_pi_model_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  RiseFall *arg2 = (RiseFall *) 0 ;
  MinMaxAll *arg3 = (MinMaxAll *) 0 ;
  float arg4 ;
  float arg5 ;
  float arg6 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  float val4 ;
  int ecode4 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  float val6 ;
  int ecode6 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oooooo:sta::set_pi_model_cmd drvr_pin rf min_max c2 rpi c1 ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_pi_model_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[2], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg2 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[3], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg3 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode4 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[4], &val4);
  if (!SWIG_IsOK(ecode4)) {
    SWIG_exception_fail(SWIG_ArgError(ecode4), "in method '" "set_pi_model_cmd" "', argument " "4"" of type '" "float""'");
  } 
  arg4 = static_cast< float >(val4);
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_pi_model_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  ecode6 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[6], &val6);
  if (!SWIG_IsOK(ecode6)) {
    SWIG_exception_fail(SWIG_ArgError(ecode6), "in method '" "set_pi_model_cmd" "', argument " "6"" of type '" "float""'");
  } 
  arg6 = static_cast< float >(val6);
  {
    try {
      set_pi_model_cmd(arg1,arg2,arg3,arg4,arg5,arg6); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_set_elmore_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  Pin *arg2 = (Pin *) 0 ;
  RiseFall *arg3 = (RiseFall *) 0 ;
  MinMaxAll *arg4 = (MinMaxAll *) 0 ;
  float arg5 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  float val5 ;
  int ecode5 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooooo:sta::set_elmore_cmd drvr_pin load_pin rf min_max elmore ",(void *)0,(void *)0,(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "set_elmore_cmd" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "set_elmore_cmd" "', argument " "2"" of type '" "Pin *""'"); 
  }
  arg2 = reinterpret_cast< Pin * >(argp2);
  {
    int length;
    const char *arg = Tcl_GetStringFromObj(objv[3], &length);
    RiseFall *tr = RiseFall::find(arg);
    if (tr == nullptr) {
      Tcl_SetResult(interp,const_cast<char*>("Error: unknown transition name."),
        TCL_STATIC);
      return TCL_ERROR;
    }
    arg3 = tr;
  }
  {
    int length;
    char *arg = Tcl_GetStringFromObj(objv[4], &length);
    MinMaxAll *min_max = MinMaxAll::find(arg);
    if (min_max)
    arg4 = min_max;
    else {
      tclArgError(interp, "%s not min, max or min_max.", arg);
      return TCL_ERROR;
    }
  }
  ecode5 = SWIG_AsVal_float SWIG_TCL_CALL_ARGS_2(objv[5], &val5);
  if (!SWIG_IsOK(ecode5)) {
    SWIG_exception_fail(SWIG_ArgError(ecode5), "in method '" "set_elmore_cmd" "', argument " "5"" of type '" "float""'");
  } 
  arg5 = static_cast< float >(val5);
  {
    try {
      set_elmore_cmd(arg1,arg2,arg3,arg4,arg5); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_dbNetVector__SWIG_0(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  unsigned int arg1 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  std::vector< dbNet * > *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::new_dbNetVector size ",(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_dbNetVector" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  {
    try {
      result = (std::vector< dbNet * > *)new std::vector< dbNet * >(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_dbNet_p_t,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_dbNetVector__SWIG_1(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::new_dbNetVector ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = (std::vector< dbNet * > *)new std::vector< dbNet * >(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_dbNet_p_t,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_dbNetVector__SWIG_2(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  unsigned int arg1 ;
  dbNet **arg2 = 0 ;
  unsigned int val1 ;
  int ecode1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  dbNet *temp2 ;
  std::vector< dbNet * > *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::new_dbNetVector size value ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  ecode1 = SWIG_AsVal_unsigned_SS_int SWIG_TCL_CALL_ARGS_2(objv[1], &val1);
  if (!SWIG_IsOK(ecode1)) {
    SWIG_exception_fail(SWIG_ArgError(ecode1), "in method '" "new_dbNetVector" "', argument " "1"" of type '" "unsigned int""'");
  } 
  arg1 = static_cast< unsigned int >(val1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2, SWIGTYPE_p_dbNet, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "new_dbNetVector" "', argument " "2"" of type '" "dbNet *""'"); 
  }
  temp2 = reinterpret_cast< dbNet * >(argp2);
  arg2 = reinterpret_cast< dbNet ** >(&temp2);
  {
    try {
      result = (std::vector< dbNet * > *)new std::vector< dbNet * >(arg1,(dbNet *const &)*arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_dbNet_p_t,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_dbNetVector__SWIG_3(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *arg1 = 0 ;
  std::vector< dbNet * > *v1 ;
  std::vector< dbNet * > w1 ;
  std::vector< dbNet * > *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::new_dbNetVector other ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    Tcl_Obj **listobjv;
    int       nitems;
    int       i;
    dbNet **        temp;
    
    if(SWIG_ConvertPtr(objv[1], (void **) &v1, \
        SWIGTYPE_p_p_std__vectorT_dbNet_p_t, 0) == 0) {
      arg1 = v1;
    } else {
      // It isn't a vector< dbNet * > so it should be a list of dbNet *'s
      if(Tcl_ListObjGetElements(interp, objv[1], 
          &nitems, &listobjv) == TCL_ERROR)
      return TCL_ERROR;
      w1 = std::vector< dbNet * >();
      for (i = 0; i < nitems; i++) {
        if ((SWIG_ConvertPtr(listobjv[i],(void **) &temp,
              SWIGTYPE_p_p_dbNet,0)) != 0) {
          char message[] = 
          "list of " "dbNet *" " expected";
          Tcl_SetResult(interp, message, TCL_VOLATILE);
          return TCL_ERROR;
        }
        w1.push_back(*temp);
      } 
      arg1 = &w1;
    }
  }
  {
    try {
      result = (std::vector< dbNet * > *)new std::vector< dbNet * >((std::vector< dbNet * > const &)*arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_std__vectorT_dbNet_p_t,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_new_dbNetVector(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Tcl_Obj *CONST *argv = objv+1;
  int argc = objc-1;
  if (argc == 0) {
    return _wrap_new_dbNetVector__SWIG_1(clientData, interp, objc, argv - 1);
  }
  if (argc == 1) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int SWIG_TCL_CALL_ARGS_2(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      return _wrap_new_dbNetVector__SWIG_0(clientData, interp, objc, argv - 1);
    }
  }
  if (argc == 1) {
    int _v;
    {
      Tcl_Obj **listobjv;
      int       nitems;
      dbNet **         temp;
      std::vector< dbNet * > *v;
      
      if(SWIG_ConvertPtr(argv[0], (void **) &v, \
          SWIGTYPE_p_std__vectorT_dbNet_p_t, 0) == 0){
        /* wrapped vector */
        _v = 1;
      } else {
        // It isn't a vector< dbNet * > so it should be a list of dbNet *'s
        if(Tcl_ListObjGetElements(interp, argv[0], 
            &nitems, &listobjv) == TCL_ERROR)
        _v = 0;
        else
        if (nitems == 0)
        _v = 1;
        //check the first value to see if it is of correct type
        else if ((SWIG_ConvertPtr(listobjv[0],
              (void **) &temp,
              SWIGTYPE_p_p_dbNet,0)) != 0)
        _v = 0;
        else
        _v = 1;
      }
    }
    if (_v) {
      return _wrap_new_dbNetVector__SWIG_3(clientData, interp, objc, argv - 1);
    }
  }
  if (argc == 2) {
    int _v;
    {
      int res = SWIG_AsVal_unsigned_SS_int SWIG_TCL_CALL_ARGS_2(argv[0], NULL);
      _v = SWIG_CheckState(res);
    }
    if (_v) {
      void *vptr = 0;
      int res = SWIG_ConvertPtr(argv[1], &vptr, SWIGTYPE_p_dbNet, 0);
      _v = SWIG_CheckState(res);
      if (_v) {
        return _wrap_new_dbNetVector__SWIG_2(clientData, interp, objc, argv - 1);
      }
    }
  }
  
  Tcl_SetResult(interp,(char *) "Wrong number or type of arguments for overloaded function 'new_dbNetVector'.\n"
    "  Possible C/C++ prototypes are:\n"
    "    std::vector< dbNet * >::vector(unsigned int)\n"
    "    std::vector< dbNet * >::vector()\n"
    "    std::vector< dbNet * >::vector(unsigned int,dbNet *const &)\n"
    "    std::vector< dbNet * >::vector(std::vector< dbNet * > const &)\n", TCL_STATIC);
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_dbNetVector_size(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *arg1 = (std::vector< dbNet * > *) 0 ;
  std::vector< dbNet * > *v1 ;
  std::vector< dbNet * > w1 ;
  unsigned int result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::dbNetVector_size self ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    Tcl_Obj **listobjv;
    int       nitems;
    int       i;
    dbNet **        temp;
    
    if(SWIG_ConvertPtr(objv[1], (void **) &v1, \
        SWIGTYPE_p_p_std__vectorT_dbNet_p_t, 0) == 0) {
      arg1 = v1;
    } else {
      // It isn't a vector< dbNet * > so it should be a list of dbNet *'s
      if(Tcl_ListObjGetElements(interp, objv[1], 
          &nitems, &listobjv) == TCL_ERROR)
      return TCL_ERROR;
      w1 = std::vector< dbNet * >();
      for (i = 0; i < nitems; i++) {
        if ((SWIG_ConvertPtr(listobjv[i],(void **) &temp,
              SWIGTYPE_p_p_dbNet,0)) != 0) {
          char message[] = 
          "list of " "dbNet *" " expected";
          Tcl_SetResult(interp, message, TCL_VOLATILE);
          return TCL_ERROR;
        }
        w1.push_back(*temp);
      } 
      arg1 = &w1;
    }
  }
  {
    try {
      result = (unsigned int)((std::vector< dbNet * > const *)arg1)->size(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_unsigned_SS_int(static_cast< unsigned int >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_dbNetVector_empty(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *arg1 = (std::vector< dbNet * > *) 0 ;
  std::vector< dbNet * > *v1 ;
  std::vector< dbNet * > w1 ;
  bool result;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::dbNetVector_empty self ",(void *)0) == TCL_ERROR) SWIG_fail;
  {
    Tcl_Obj **listobjv;
    int       nitems;
    int       i;
    dbNet **        temp;
    
    if(SWIG_ConvertPtr(objv[1], (void **) &v1, \
        SWIGTYPE_p_p_std__vectorT_dbNet_p_t, 0) == 0) {
      arg1 = v1;
    } else {
      // It isn't a vector< dbNet * > so it should be a list of dbNet *'s
      if(Tcl_ListObjGetElements(interp, objv[1], 
          &nitems, &listobjv) == TCL_ERROR)
      return TCL_ERROR;
      w1 = std::vector< dbNet * >();
      for (i = 0; i < nitems; i++) {
        if ((SWIG_ConvertPtr(listobjv[i],(void **) &temp,
              SWIGTYPE_p_p_dbNet,0)) != 0) {
          char message[] = 
          "list of " "dbNet *" " expected";
          Tcl_SetResult(interp, message, TCL_VOLATILE);
          return TCL_ERROR;
        }
        w1.push_back(*temp);
      } 
      arg1 = &w1;
    }
  }
  {
    try {
      result = (bool)((std::vector< dbNet * > const *)arg1)->empty(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp,SWIG_From_bool(static_cast< bool >(result)));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_dbNetVector_clear(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *arg1 = (std::vector< dbNet * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::dbNetVector_clear self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_std__vectorT_dbNet_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dbNetVector_clear" "', argument " "1"" of type '" "std::vector< dbNet * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< dbNet * > * >(argp1);
  {
    try {
      (arg1)->clear(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_dbNetVector_push(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *arg1 = (std::vector< dbNet * > *) 0 ;
  dbNet **arg2 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  void *argp2 = 0 ;
  int res2 = 0 ;
  dbNet *temp2 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::dbNetVector_push self x ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_std__vectorT_dbNet_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dbNetVector_push" "', argument " "1"" of type '" "std::vector< dbNet * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< dbNet * > * >(argp1);
  res2 = SWIG_ConvertPtr(objv[2], &argp2, SWIGTYPE_p_dbNet, 0 |  0 );
  if (!SWIG_IsOK(res2)) {
    SWIG_exception_fail(SWIG_ArgError(res2), "in method '" "dbNetVector_push" "', argument " "2"" of type '" "dbNet *""'"); 
  }
  temp2 = reinterpret_cast< dbNet * >(argp2);
  arg2 = reinterpret_cast< dbNet ** >(&temp2);
  {
    try {
      (arg1)->push_back((dbNet *const &)*arg2); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_dbNetVector_pop(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *arg1 = (std::vector< dbNet * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  dbNet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::dbNetVector_pop self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_std__vectorT_dbNet_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dbNetVector_pop" "', argument " "1"" of type '" "std::vector< dbNet * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< dbNet * > * >(argp1);
  {
    try {
      try {
        result = (dbNet *)std_vector_Sl_dbNet_Sm__Sg__pop(arg1);
      } catch(std::out_of_range &_e) {
        SWIG_Tcl_SetErrorObj(interp,"std::out_of_range",SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN)); SWIG_fail;
      } 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_dbNet,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_dbNetVector_get(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *arg1 = (std::vector< dbNet * > *) 0 ;
  int arg2 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  dbNet **result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"oo:sta::dbNetVector_get self i ",(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_std__vectorT_dbNet_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dbNetVector_get" "', argument " "1"" of type '" "std::vector< dbNet * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< dbNet * > * >(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dbNetVector_get" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  {
    try {
      try {
        result = (dbNet **) &std_vector_Sl_dbNet_Sm__Sg__get(arg1,arg2);
      } catch(std::out_of_range &_e) {
        SWIG_Tcl_SetErrorObj(interp,"std::out_of_range",SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN)); SWIG_fail;
      } 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_p_dbNet,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_dbNetVector_set(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *arg1 = (std::vector< dbNet * > *) 0 ;
  int arg2 ;
  dbNet **arg3 = 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  int val2 ;
  int ecode2 = 0 ;
  void *argp3 = 0 ;
  int res3 = 0 ;
  dbNet *temp3 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"ooo:sta::dbNetVector_set self i x ",(void *)0,(void *)0,(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_std__vectorT_dbNet_p_t, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "dbNetVector_set" "', argument " "1"" of type '" "std::vector< dbNet * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< dbNet * > * >(argp1);
  ecode2 = SWIG_AsVal_int SWIG_TCL_CALL_ARGS_2(objv[2], &val2);
  if (!SWIG_IsOK(ecode2)) {
    SWIG_exception_fail(SWIG_ArgError(ecode2), "in method '" "dbNetVector_set" "', argument " "2"" of type '" "int""'");
  } 
  arg2 = static_cast< int >(val2);
  res3 = SWIG_ConvertPtr(objv[3], &argp3, SWIGTYPE_p_dbNet, 0 |  0 );
  if (!SWIG_IsOK(res3)) {
    SWIG_exception_fail(SWIG_ArgError(res3), "in method '" "dbNetVector_set" "', argument " "3"" of type '" "dbNet *""'"); 
  }
  temp3 = reinterpret_cast< dbNet * >(argp3);
  arg3 = reinterpret_cast< dbNet ** >(&temp3);
  {
    try {
      try {
        std_vector_Sl_dbNet_Sm__Sg__set(arg1,arg2,(dbNet *const &)*arg3);
      } catch(std::out_of_range &_e) {
        SWIG_Tcl_SetErrorObj(interp,"std::out_of_range",SWIG_NewPointerObj((new std::out_of_range(static_cast< const std::out_of_range& >(_e))),SWIGTYPE_p_std__out_of_range,SWIG_POINTER_OWN)); SWIG_fail;
      } 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_delete_dbNetVector(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  std::vector< dbNet * > *arg1 = (std::vector< dbNet * > *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::delete_dbNetVector self ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_std__vectorT_dbNet_p_t, SWIG_POINTER_DISOWN |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "delete_dbNetVector" "', argument " "1"" of type '" "std::vector< dbNet * > *""'"); 
  }
  arg1 = reinterpret_cast< std::vector< dbNet * > * >(argp1);
  {
    try {
      delete arg1; 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN void swig_delete_dbNetVector(void *obj) {
std::vector< dbNet * > *arg1 = (std::vector< dbNet * > *) obj;
delete arg1;
}
static swig_method swig_std_vector_Sl_dbNet_Sm__Sg__methods[] = {
    {"size", _wrap_dbNetVector_size}, 
    {"empty", _wrap_dbNetVector_empty}, 
    {"clear", _wrap_dbNetVector_clear}, 
    {"push", _wrap_dbNetVector_push}, 
    {"pop", _wrap_dbNetVector_pop}, 
    {"get", _wrap_dbNetVector_get}, 
    {"set", _wrap_dbNetVector_set}, 
    {0,0}
};
static swig_attribute swig_std_vector_Sl_dbNet_Sm__Sg__attributes[] = {
    {0,0,0}
};
static swig_class *swig_std_vector_Sl_dbNet_Sm__Sg__bases[] = {0};
static const char * swig_std_vector_Sl_dbNet_Sm__Sg__base_names[] = {0};
static swig_class _wrap_class_std_vector_Sl_dbNet_Sm__Sg_ = { "dbNetVector", &SWIGTYPE_p_std__vectorT_dbNet_p_t,_wrap_new_dbNetVector, swig_delete_dbNetVector, swig_std_vector_Sl_dbNet_Sm__Sg__methods, swig_std_vector_Sl_dbNet_Sm__Sg__attributes, swig_std_vector_Sl_dbNet_Sm__Sg__bases,swig_std_vector_Sl_dbNet_Sm__Sg__base_names, &swig_module, SWIG_TCL_HASHTABLE_INIT };
SWIGINTERN int
_wrap_make_block_sta(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  odb::dbBlock *arg1 = (odb::dbBlock *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  sta::Sta *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::make_block_sta block ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_odb__dbBlock, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "make_block_sta" "', argument " "1"" of type '" "odb::dbBlock *""'"); 
  }
  arg1 = reinterpret_cast< odb::dbBlock * >(argp1);
  {
    try {
      result = (sta::Sta *)make_block_sta(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_sta__Sta,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_logic_constants(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::find_logic_constants ") == TCL_ERROR) SWIG_fail;
  {
    try {
      find_logic_constants(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_highlight_path_cmd(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  PathRef *arg1 = (PathRef *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::highlight_path_cmd path ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_PathRef, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "highlight_path_cmd" "', argument " "1"" of type '" "PathRef *""'"); 
  }
  arg1 = reinterpret_cast< PathRef * >(argp1);
  {
    try {
      highlight_path_cmd(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_find_all_clk_nets(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  SwigValueWrapper< std::vector< odb::dbNet * > > result;
  
  if (SWIG_GetArgs(interp, objc, objv,":sta::find_all_clk_nets ") == TCL_ERROR) SWIG_fail;
  {
    try {
      result = find_all_clk_nets(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  {
    for (unsigned int i = 0; i < (&result)->size(); i++) {
      odb::dbNet* ptr = (((std::vector< odb::dbNet * > &)result)[i]);
      Tcl_ListObjAppendElement(interp, (Tcl_GetObjResult(interp)),  SWIG_NewInstanceObj(ptr, SWIGTYPE_p_odb__dbNet, 0));
    }
  }
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_sta_to_db_inst(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Instance *arg1 = (Instance *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  odb::dbInst *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::sta_to_db_inst inst ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Instance, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sta_to_db_inst" "', argument " "1"" of type '" "Instance *""'"); 
  }
  arg1 = reinterpret_cast< Instance * >(argp1);
  {
    try {
      result = (odb::dbInst *)sta_to_db_inst(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_odb__dbInst,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_sta_to_db_port(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Port *arg1 = (Port *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  odb::dbBTerm *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::sta_to_db_port port ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Port, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sta_to_db_port" "', argument " "1"" of type '" "Port *""'"); 
  }
  arg1 = reinterpret_cast< Port * >(argp1);
  {
    try {
      result = (odb::dbBTerm *)sta_to_db_port(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_odb__dbBTerm,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_sta_to_db_pin(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Pin *arg1 = (Pin *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  odb::dbITerm *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::sta_to_db_pin pin ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Pin, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sta_to_db_pin" "', argument " "1"" of type '" "Pin *""'"); 
  }
  arg1 = reinterpret_cast< Pin * >(argp1);
  {
    try {
      result = (odb::dbITerm *)sta_to_db_pin(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_odb__dbITerm,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_sta_to_db_net(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  Net *arg1 = (Net *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  odb::dbNet *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::sta_to_db_net net ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_Net, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sta_to_db_net" "', argument " "1"" of type '" "Net *""'"); 
  }
  arg1 = reinterpret_cast< Net * >(argp1);
  {
    try {
      result = (odb::dbNet *)sta_to_db_net(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_odb__dbNet,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_sta_to_db_master(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  LibertyCell *arg1 = (LibertyCell *) 0 ;
  void *argp1 = 0 ;
  int res1 = 0 ;
  odb::dbMaster *result = 0 ;
  
  if (SWIG_GetArgs(interp, objc, objv,"o:sta::sta_to_db_master cell ",(void *)0) == TCL_ERROR) SWIG_fail;
  res1 = SWIG_ConvertPtr(objv[1], &argp1,SWIGTYPE_p_LibertyCell, 0 |  0 );
  if (!SWIG_IsOK(res1)) {
    SWIG_exception_fail(SWIG_ArgError(res1), "in method '" "sta_to_db_master" "', argument " "1"" of type '" "LibertyCell *""'"); 
  }
  arg1 = reinterpret_cast< LibertyCell * >(argp1);
  {
    try {
      result = (odb::dbMaster *)sta_to_db_master(arg1); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  Tcl_SetObjResult(interp, SWIG_NewInstanceObj( SWIG_as_voidptr(result), SWIGTYPE_p_odb__dbMaster,0));
  return TCL_OK;
fail:
  return TCL_ERROR;
}


SWIGINTERN int
_wrap_db_network_defined(ClientData clientData SWIGUNUSED, Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]) {
  if (SWIG_GetArgs(interp, objc, objv,":sta::db_network_defined ") == TCL_ERROR) SWIG_fail;
  {
    try {
      db_network_defined(); 
    }
    catch (std::bad_alloc &) {
      fprintf(stderr, "Error: out of memory.");
      exit(0);
    }
    // This catches std::runtime_error (utl::error) and sta::Exception.
    catch (std::exception &excp) {
      Tcl_ResetResult(interp);
      Tcl_AppendResult(interp, excp.what(), nullptr);
      return TCL_ERROR;
    }
  }
  
  return TCL_OK;
fail:
  return TCL_ERROR;
}



static swig_command_info swig_commands[] = {
    { SWIG_prefix "Library_name", (swig_wrapper_func) _wrap_Library_name, NULL},
    { SWIG_prefix "Library_find_cell", (swig_wrapper_func) _wrap_Library_find_cell, NULL},
    { SWIG_prefix "Library_find_cells_matching", (swig_wrapper_func) _wrap_Library_find_cells_matching, NULL},
    { SWIG_prefix "Library", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Library},
    { SWIG_prefix "LibraryIterator_has_next", (swig_wrapper_func) _wrap_LibraryIterator_has_next, NULL},
    { SWIG_prefix "LibraryIterator_next", (swig_wrapper_func) _wrap_LibraryIterator_next, NULL},
    { SWIG_prefix "LibraryIterator_finish", (swig_wrapper_func) _wrap_LibraryIterator_finish, NULL},
    { SWIG_prefix "LibraryIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibraryIterator},
    { SWIG_prefix "Cell_library", (swig_wrapper_func) _wrap_Cell_library, NULL},
    { SWIG_prefix "Cell_liberty_cell", (swig_wrapper_func) _wrap_Cell_liberty_cell, NULL},
    { SWIG_prefix "Cell_is_leaf", (swig_wrapper_func) _wrap_Cell_is_leaf, NULL},
    { SWIG_prefix "Cell_port_iterator", (swig_wrapper_func) _wrap_Cell_port_iterator, NULL},
    { SWIG_prefix "Cell_find_port", (swig_wrapper_func) _wrap_Cell_find_port, NULL},
    { SWIG_prefix "Cell_find_ports_matching", (swig_wrapper_func) _wrap_Cell_find_ports_matching, NULL},
    { SWIG_prefix "Cell", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Cell},
    { SWIG_prefix "CellPortIterator_has_next", (swig_wrapper_func) _wrap_CellPortIterator_has_next, NULL},
    { SWIG_prefix "CellPortIterator_next", (swig_wrapper_func) _wrap_CellPortIterator_next, NULL},
    { SWIG_prefix "CellPortIterator_finish", (swig_wrapper_func) _wrap_CellPortIterator_finish, NULL},
    { SWIG_prefix "CellPortIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_CellPortIterator},
    { SWIG_prefix "LibertyCellPortIterator_has_next", (swig_wrapper_func) _wrap_LibertyCellPortIterator_has_next, NULL},
    { SWIG_prefix "LibertyCellPortIterator_next", (swig_wrapper_func) _wrap_LibertyCellPortIterator_next, NULL},
    { SWIG_prefix "LibertyCellPortIterator_finish", (swig_wrapper_func) _wrap_LibertyCellPortIterator_finish, NULL},
    { SWIG_prefix "LibertyCellPortIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyCellPortIterator},
    { SWIG_prefix "Port_bus_name", (swig_wrapper_func) _wrap_Port_bus_name, NULL},
    { SWIG_prefix "Port_cell", (swig_wrapper_func) _wrap_Port_cell, NULL},
    { SWIG_prefix "Port_liberty_port", (swig_wrapper_func) _wrap_Port_liberty_port, NULL},
    { SWIG_prefix "Port_is_bus", (swig_wrapper_func) _wrap_Port_is_bus, NULL},
    { SWIG_prefix "Port_member_iterator", (swig_wrapper_func) _wrap_Port_member_iterator, NULL},
    { SWIG_prefix "Port", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Port},
    { SWIG_prefix "PortMemberIterator_has_next", (swig_wrapper_func) _wrap_PortMemberIterator_has_next, NULL},
    { SWIG_prefix "PortMemberIterator_next", (swig_wrapper_func) _wrap_PortMemberIterator_next, NULL},
    { SWIG_prefix "PortMemberIterator_finish", (swig_wrapper_func) _wrap_PortMemberIterator_finish, NULL},
    { SWIG_prefix "PortMemberIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_PortMemberIterator},
    { SWIG_prefix "LibertyLibrary_name", (swig_wrapper_func) _wrap_LibertyLibrary_name, NULL},
    { SWIG_prefix "LibertyLibrary_find_liberty_cell", (swig_wrapper_func) _wrap_LibertyLibrary_find_liberty_cell, NULL},
    { SWIG_prefix "LibertyLibrary_find_liberty_cells_matching", (swig_wrapper_func) _wrap_LibertyLibrary_find_liberty_cells_matching, NULL},
    { SWIG_prefix "LibertyLibrary_find_wireload", (swig_wrapper_func) _wrap_LibertyLibrary_find_wireload, NULL},
    { SWIG_prefix "LibertyLibrary_find_wireload_selection", (swig_wrapper_func) _wrap_LibertyLibrary_find_wireload_selection, NULL},
    { SWIG_prefix "LibertyLibrary_find_operating_conditions", (swig_wrapper_func) _wrap_LibertyLibrary_find_operating_conditions, NULL},
    { SWIG_prefix "LibertyLibrary_default_operating_conditions", (swig_wrapper_func) _wrap_LibertyLibrary_default_operating_conditions, NULL},
    { SWIG_prefix "LibertyLibrary", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyLibrary},
    { SWIG_prefix "LibertyLibraryIterator_has_next", (swig_wrapper_func) _wrap_LibertyLibraryIterator_has_next, NULL},
    { SWIG_prefix "LibertyLibraryIterator_next", (swig_wrapper_func) _wrap_LibertyLibraryIterator_next, NULL},
    { SWIG_prefix "LibertyLibraryIterator_finish", (swig_wrapper_func) _wrap_LibertyLibraryIterator_finish, NULL},
    { SWIG_prefix "LibertyLibraryIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyLibraryIterator},
    { SWIG_prefix "LibertyCell_name", (swig_wrapper_func) _wrap_LibertyCell_name, NULL},
    { SWIG_prefix "LibertyCell_is_leaf", (swig_wrapper_func) _wrap_LibertyCell_is_leaf, NULL},
    { SWIG_prefix "LibertyCell_is_buffer", (swig_wrapper_func) _wrap_LibertyCell_is_buffer, NULL},
    { SWIG_prefix "LibertyCell_is_inverter", (swig_wrapper_func) _wrap_LibertyCell_is_inverter, NULL},
    { SWIG_prefix "LibertyCell_liberty_library", (swig_wrapper_func) _wrap_LibertyCell_liberty_library, NULL},
    { SWIG_prefix "LibertyCell_cell", (swig_wrapper_func) _wrap_LibertyCell_cell, NULL},
    { SWIG_prefix "LibertyCell_find_liberty_port", (swig_wrapper_func) _wrap_LibertyCell_find_liberty_port, NULL},
    { SWIG_prefix "LibertyCell_find_liberty_ports_matching", (swig_wrapper_func) _wrap_LibertyCell_find_liberty_ports_matching, NULL},
    { SWIG_prefix "LibertyCell_liberty_port_iterator", (swig_wrapper_func) _wrap_LibertyCell_liberty_port_iterator, NULL},
    { SWIG_prefix "LibertyCell_timing_arc_set_iterator", (swig_wrapper_func) _wrap_LibertyCell_timing_arc_set_iterator, NULL},
    { SWIG_prefix "LibertyCell", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyCell},
    { SWIG_prefix "LibertyPort_bus_name", (swig_wrapper_func) _wrap_LibertyPort_bus_name, NULL},
    { SWIG_prefix "LibertyPort_cell", (swig_wrapper_func) _wrap_LibertyPort_cell, NULL},
    { SWIG_prefix "LibertyPort_is_bus", (swig_wrapper_func) _wrap_LibertyPort_is_bus, NULL},
    { SWIG_prefix "LibertyPort_member_iterator", (swig_wrapper_func) _wrap_LibertyPort_member_iterator, NULL},
    { SWIG_prefix "LibertyPort_function", (swig_wrapper_func) _wrap_LibertyPort_function, NULL},
    { SWIG_prefix "LibertyPort_tristate_enable", (swig_wrapper_func) _wrap_LibertyPort_tristate_enable, NULL},
    { SWIG_prefix "LibertyPort_capacitance", (swig_wrapper_func) _wrap_LibertyPort_capacitance, NULL},
    { SWIG_prefix "LibertyPort", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyPort},
    { SWIG_prefix "LibertyPortMemberIterator_has_next", (swig_wrapper_func) _wrap_LibertyPortMemberIterator_has_next, NULL},
    { SWIG_prefix "LibertyPortMemberIterator_next", (swig_wrapper_func) _wrap_LibertyPortMemberIterator_next, NULL},
    { SWIG_prefix "LibertyPortMemberIterator_finish", (swig_wrapper_func) _wrap_LibertyPortMemberIterator_finish, NULL},
    { SWIG_prefix "LibertyPortMemberIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyPortMemberIterator},
    { SWIG_prefix "TimingArcSet_from", (swig_wrapper_func) _wrap_TimingArcSet_from, NULL},
    { SWIG_prefix "TimingArcSet_to", (swig_wrapper_func) _wrap_TimingArcSet_to, NULL},
    { SWIG_prefix "TimingArcSet_role", (swig_wrapper_func) _wrap_TimingArcSet_role, NULL},
    { SWIG_prefix "TimingArcSet_sdf_cond", (swig_wrapper_func) _wrap_TimingArcSet_sdf_cond, NULL},
    { SWIG_prefix "TimingArcSet_full_name", (swig_wrapper_func) _wrap_TimingArcSet_full_name, NULL},
    { SWIG_prefix "TimingArcSet", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_TimingArcSet},
    { SWIG_prefix "LibertyCellTimingArcSetIterator_has_next", (swig_wrapper_func) _wrap_LibertyCellTimingArcSetIterator_has_next, NULL},
    { SWIG_prefix "LibertyCellTimingArcSetIterator_next", (swig_wrapper_func) _wrap_LibertyCellTimingArcSetIterator_next, NULL},
    { SWIG_prefix "LibertyCellTimingArcSetIterator_finish", (swig_wrapper_func) _wrap_LibertyCellTimingArcSetIterator_finish, NULL},
    { SWIG_prefix "LibertyCellTimingArcSetIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LibertyCellTimingArcSetIterator},
    { SWIG_prefix "TimingArcSetArcIterator_has_next", (swig_wrapper_func) _wrap_TimingArcSetArcIterator_has_next, NULL},
    { SWIG_prefix "TimingArcSetArcIterator_next", (swig_wrapper_func) _wrap_TimingArcSetArcIterator_next, NULL},
    { SWIG_prefix "TimingArcSetArcIterator_finish", (swig_wrapper_func) _wrap_TimingArcSetArcIterator_finish, NULL},
    { SWIG_prefix "TimingArcSetArcIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_TimingArcSetArcIterator},
    { SWIG_prefix "TimingArc_from", (swig_wrapper_func) _wrap_TimingArc_from, NULL},
    { SWIG_prefix "TimingArc_to", (swig_wrapper_func) _wrap_TimingArc_to, NULL},
    { SWIG_prefix "TimingArc_from_edge", (swig_wrapper_func) _wrap_TimingArc_from_edge, NULL},
    { SWIG_prefix "TimingArc_from_edge_name", (swig_wrapper_func) _wrap_TimingArc_from_edge_name, NULL},
    { SWIG_prefix "TimingArc_to_edge", (swig_wrapper_func) _wrap_TimingArc_to_edge, NULL},
    { SWIG_prefix "TimingArc_to_edge_name", (swig_wrapper_func) _wrap_TimingArc_to_edge_name, NULL},
    { SWIG_prefix "TimingArc_role", (swig_wrapper_func) _wrap_TimingArc_role, NULL},
    { SWIG_prefix "TimingArc", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_TimingArc},
    { SWIG_prefix "Wireload", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Wireload},
    { SWIG_prefix "WireloadSelection", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_WireloadSelection},
    { SWIG_prefix "Transition", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Transition},
    { SWIG_prefix "Instance_parent", (swig_wrapper_func) _wrap_Instance_parent, NULL},
    { SWIG_prefix "Instance_cell", (swig_wrapper_func) _wrap_Instance_cell, NULL},
    { SWIG_prefix "Instance_liberty_cell", (swig_wrapper_func) _wrap_Instance_liberty_cell, NULL},
    { SWIG_prefix "Instance_is_leaf", (swig_wrapper_func) _wrap_Instance_is_leaf, NULL},
    { SWIG_prefix "Instance_child_iterator", (swig_wrapper_func) _wrap_Instance_child_iterator, NULL},
    { SWIG_prefix "Instance_pin_iterator", (swig_wrapper_func) _wrap_Instance_pin_iterator, NULL},
    { SWIG_prefix "Instance_net_iterator", (swig_wrapper_func) _wrap_Instance_net_iterator, NULL},
    { SWIG_prefix "Instance_find_pin", (swig_wrapper_func) _wrap_Instance_find_pin, NULL},
    { SWIG_prefix "Instance", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Instance},
    { SWIG_prefix "Pin_port_name", (swig_wrapper_func) _wrap_Pin_port_name, NULL},
    { SWIG_prefix "Pin_instance", (swig_wrapper_func) _wrap_Pin_instance, NULL},
    { SWIG_prefix "Pin_net", (swig_wrapper_func) _wrap_Pin_net, NULL},
    { SWIG_prefix "Pin_port", (swig_wrapper_func) _wrap_Pin_port, NULL},
    { SWIG_prefix "Pin_term", (swig_wrapper_func) _wrap_Pin_term, NULL},
    { SWIG_prefix "Pin_liberty_port", (swig_wrapper_func) _wrap_Pin_liberty_port, NULL},
    { SWIG_prefix "Pin_is_driver", (swig_wrapper_func) _wrap_Pin_is_driver, NULL},
    { SWIG_prefix "Pin_is_load", (swig_wrapper_func) _wrap_Pin_is_load, NULL},
    { SWIG_prefix "Pin_is_leaf", (swig_wrapper_func) _wrap_Pin_is_leaf, NULL},
    { SWIG_prefix "Pin_is_hierarchical", (swig_wrapper_func) _wrap_Pin_is_hierarchical, NULL},
    { SWIG_prefix "Pin_is_top_level_port", (swig_wrapper_func) _wrap_Pin_is_top_level_port, NULL},
    { SWIG_prefix "Pin_connected_pin_iterator", (swig_wrapper_func) _wrap_Pin_connected_pin_iterator, NULL},
    { SWIG_prefix "Pin_vertices", (swig_wrapper_func) _wrap_Pin_vertices, NULL},
    { SWIG_prefix "Pin_capacitance", (swig_wrapper_func) _wrap_Pin_capacitance, NULL},
    { SWIG_prefix "Pin_pin_capacitance", (swig_wrapper_func) _wrap_Pin_pin_capacitance, NULL},
    { SWIG_prefix "Pin_wire_capacitance", (swig_wrapper_func) _wrap_Pin_wire_capacitance, NULL},
    { SWIG_prefix "Pin", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Pin},
    { SWIG_prefix "Term_net", (swig_wrapper_func) _wrap_Term_net, NULL},
    { SWIG_prefix "Term_pin", (swig_wrapper_func) _wrap_Term_pin, NULL},
    { SWIG_prefix "Term", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Term},
    { SWIG_prefix "InstanceChildIterator_has_next", (swig_wrapper_func) _wrap_InstanceChildIterator_has_next, NULL},
    { SWIG_prefix "InstanceChildIterator_next", (swig_wrapper_func) _wrap_InstanceChildIterator_next, NULL},
    { SWIG_prefix "InstanceChildIterator_finish", (swig_wrapper_func) _wrap_InstanceChildIterator_finish, NULL},
    { SWIG_prefix "InstanceChildIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_InstanceChildIterator},
    { SWIG_prefix "InstancePinIterator_has_next", (swig_wrapper_func) _wrap_InstancePinIterator_has_next, NULL},
    { SWIG_prefix "InstancePinIterator_next", (swig_wrapper_func) _wrap_InstancePinIterator_next, NULL},
    { SWIG_prefix "InstancePinIterator_finish", (swig_wrapper_func) _wrap_InstancePinIterator_finish, NULL},
    { SWIG_prefix "InstancePinIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_InstancePinIterator},
    { SWIG_prefix "InstanceNetIterator_has_next", (swig_wrapper_func) _wrap_InstanceNetIterator_has_next, NULL},
    { SWIG_prefix "InstanceNetIterator_next", (swig_wrapper_func) _wrap_InstanceNetIterator_next, NULL},
    { SWIG_prefix "InstanceNetIterator_finish", (swig_wrapper_func) _wrap_InstanceNetIterator_finish, NULL},
    { SWIG_prefix "InstanceNetIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_InstanceNetIterator},
    { SWIG_prefix "LeafInstanceIterator_has_next", (swig_wrapper_func) _wrap_LeafInstanceIterator_has_next, NULL},
    { SWIG_prefix "LeafInstanceIterator_next", (swig_wrapper_func) _wrap_LeafInstanceIterator_next, NULL},
    { SWIG_prefix "LeafInstanceIterator_finish", (swig_wrapper_func) _wrap_LeafInstanceIterator_finish, NULL},
    { SWIG_prefix "LeafInstanceIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_LeafInstanceIterator},
    { SWIG_prefix "Net_instance", (swig_wrapper_func) _wrap_Net_instance, NULL},
    { SWIG_prefix "Net_highest_connected_net", (swig_wrapper_func) _wrap_Net_highest_connected_net, NULL},
    { SWIG_prefix "Net_pin_iterator", (swig_wrapper_func) _wrap_Net_pin_iterator, NULL},
    { SWIG_prefix "Net_term_iterator", (swig_wrapper_func) _wrap_Net_term_iterator, NULL},
    { SWIG_prefix "Net_connected_pin_iterator", (swig_wrapper_func) _wrap_Net_connected_pin_iterator, NULL},
    { SWIG_prefix "Net_is_power", (swig_wrapper_func) _wrap_Net_is_power, NULL},
    { SWIG_prefix "Net_is_ground", (swig_wrapper_func) _wrap_Net_is_ground, NULL},
    { SWIG_prefix "Net_capacitance", (swig_wrapper_func) _wrap_Net_capacitance, NULL},
    { SWIG_prefix "Net_pin_capacitance", (swig_wrapper_func) _wrap_Net_pin_capacitance, NULL},
    { SWIG_prefix "Net_wire_capacitance", (swig_wrapper_func) _wrap_Net_wire_capacitance, NULL},
    { SWIG_prefix "Net_ports", (swig_wrapper_func) _wrap_Net_ports, NULL},
    { SWIG_prefix "Net", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Net},
    { SWIG_prefix "NetPinIterator_has_next", (swig_wrapper_func) _wrap_NetPinIterator_has_next, NULL},
    { SWIG_prefix "NetPinIterator_next", (swig_wrapper_func) _wrap_NetPinIterator_next, NULL},
    { SWIG_prefix "NetPinIterator_finish", (swig_wrapper_func) _wrap_NetPinIterator_finish, NULL},
    { SWIG_prefix "NetPinIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_NetPinIterator},
    { SWIG_prefix "NetTermIterator_has_next", (swig_wrapper_func) _wrap_NetTermIterator_has_next, NULL},
    { SWIG_prefix "NetTermIterator_next", (swig_wrapper_func) _wrap_NetTermIterator_next, NULL},
    { SWIG_prefix "NetTermIterator_finish", (swig_wrapper_func) _wrap_NetTermIterator_finish, NULL},
    { SWIG_prefix "NetTermIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_NetTermIterator},
    { SWIG_prefix "NetConnectedPinIterator_has_next", (swig_wrapper_func) _wrap_NetConnectedPinIterator_has_next, NULL},
    { SWIG_prefix "NetConnectedPinIterator_next", (swig_wrapper_func) _wrap_NetConnectedPinIterator_next, NULL},
    { SWIG_prefix "NetConnectedPinIterator_finish", (swig_wrapper_func) _wrap_NetConnectedPinIterator_finish, NULL},
    { SWIG_prefix "NetConnectedPinIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_NetConnectedPinIterator},
    { SWIG_prefix "PinConnectedPinIterator_has_next", (swig_wrapper_func) _wrap_PinConnectedPinIterator_has_next, NULL},
    { SWIG_prefix "PinConnectedPinIterator_next", (swig_wrapper_func) _wrap_PinConnectedPinIterator_next, NULL},
    { SWIG_prefix "PinConnectedPinIterator_finish", (swig_wrapper_func) _wrap_PinConnectedPinIterator_finish, NULL},
    { SWIG_prefix "PinConnectedPinIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_PinConnectedPinIterator},
    { SWIG_prefix "Clock_period", (swig_wrapper_func) _wrap_Clock_period, NULL},
    { SWIG_prefix "Clock_waveform", (swig_wrapper_func) _wrap_Clock_waveform, NULL},
    { SWIG_prefix "Clock_time", (swig_wrapper_func) _wrap_Clock_time, NULL},
    { SWIG_prefix "Clock_is_generated", (swig_wrapper_func) _wrap_Clock_is_generated, NULL},
    { SWIG_prefix "Clock_waveform_valid", (swig_wrapper_func) _wrap_Clock_waveform_valid, NULL},
    { SWIG_prefix "Clock_is_virtual", (swig_wrapper_func) _wrap_Clock_is_virtual, NULL},
    { SWIG_prefix "Clock_is_propagated", (swig_wrapper_func) _wrap_Clock_is_propagated, NULL},
    { SWIG_prefix "Clock_sources", (swig_wrapper_func) _wrap_Clock_sources, NULL},
    { SWIG_prefix "Clock_slew", (swig_wrapper_func) _wrap_Clock_slew, NULL},
    { SWIG_prefix "Clock", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Clock},
    { SWIG_prefix "ClockIterator_has_next", (swig_wrapper_func) _wrap_ClockIterator_has_next, NULL},
    { SWIG_prefix "ClockIterator_next", (swig_wrapper_func) _wrap_ClockIterator_next, NULL},
    { SWIG_prefix "ClockIterator_finish", (swig_wrapper_func) _wrap_ClockIterator_finish, NULL},
    { SWIG_prefix "ClockIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_ClockIterator},
    { SWIG_prefix "ClockEdge_clock", (swig_wrapper_func) _wrap_ClockEdge_clock, NULL},
    { SWIG_prefix "ClockEdge_transition", (swig_wrapper_func) _wrap_ClockEdge_transition, NULL},
    { SWIG_prefix "ClockEdge_time", (swig_wrapper_func) _wrap_ClockEdge_time, NULL},
    { SWIG_prefix "ClockEdge", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_ClockEdge},
    { SWIG_prefix "Vertex_pin", (swig_wrapper_func) _wrap_Vertex_pin, NULL},
    { SWIG_prefix "Vertex_is_bidirect_driver", (swig_wrapper_func) _wrap_Vertex_is_bidirect_driver, NULL},
    { SWIG_prefix "Vertex_level", (swig_wrapper_func) _wrap_Vertex_level, NULL},
    { SWIG_prefix "Vertex_tag_group_index", (swig_wrapper_func) _wrap_Vertex_tag_group_index, NULL},
    { SWIG_prefix "Vertex_slew", (swig_wrapper_func) _wrap_Vertex_slew, NULL},
    { SWIG_prefix "Vertex_slew_corner", (swig_wrapper_func) _wrap_Vertex_slew_corner, NULL},
    { SWIG_prefix "Vertex_out_edge_iterator", (swig_wrapper_func) _wrap_Vertex_out_edge_iterator, NULL},
    { SWIG_prefix "Vertex_in_edge_iterator", (swig_wrapper_func) _wrap_Vertex_in_edge_iterator, NULL},
    { SWIG_prefix "Vertex_arrivals_clk", (swig_wrapper_func) _wrap_Vertex_arrivals_clk, NULL},
    { SWIG_prefix "Vertex_arrivals_clk_delays", (swig_wrapper_func) _wrap_Vertex_arrivals_clk_delays, NULL},
    { SWIG_prefix "Vertex_requireds_clk", (swig_wrapper_func) _wrap_Vertex_requireds_clk, NULL},
    { SWIG_prefix "Vertex_requireds_clk_delays", (swig_wrapper_func) _wrap_Vertex_requireds_clk_delays, NULL},
    { SWIG_prefix "Vertex_slack", (swig_wrapper_func) _wrap_Vertex_slack, NULL},
    { SWIG_prefix "Vertex_slacks", (swig_wrapper_func) _wrap_Vertex_slacks, NULL},
    { SWIG_prefix "Vertex_slacks_clk", (swig_wrapper_func) _wrap_Vertex_slacks_clk, NULL},
    { SWIG_prefix "Vertex_slacks_clk_delays", (swig_wrapper_func) _wrap_Vertex_slacks_clk_delays, NULL},
    { SWIG_prefix "Vertex_path_iterator", (swig_wrapper_func) _wrap_Vertex_path_iterator, NULL},
    { SWIG_prefix "Vertex_has_downstream_clk_pin", (swig_wrapper_func) _wrap_Vertex_has_downstream_clk_pin, NULL},
    { SWIG_prefix "Vertex_is_clock", (swig_wrapper_func) _wrap_Vertex_is_clock, NULL},
    { SWIG_prefix "Vertex_is_disabled_constraint", (swig_wrapper_func) _wrap_Vertex_is_disabled_constraint, NULL},
    { SWIG_prefix "Vertex", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Vertex},
    { SWIG_prefix "Edge_from", (swig_wrapper_func) _wrap_Edge_from, NULL},
    { SWIG_prefix "Edge_to", (swig_wrapper_func) _wrap_Edge_to, NULL},
    { SWIG_prefix "Edge_from_pin", (swig_wrapper_func) _wrap_Edge_from_pin, NULL},
    { SWIG_prefix "Edge_to_pin", (swig_wrapper_func) _wrap_Edge_to_pin, NULL},
    { SWIG_prefix "Edge_role", (swig_wrapper_func) _wrap_Edge_role, NULL},
    { SWIG_prefix "Edge_sense", (swig_wrapper_func) _wrap_Edge_sense, NULL},
    { SWIG_prefix "Edge_timing_arc_iterator", (swig_wrapper_func) _wrap_Edge_timing_arc_iterator, NULL},
    { SWIG_prefix "Edge_is_disabled_loop", (swig_wrapper_func) _wrap_Edge_is_disabled_loop, NULL},
    { SWIG_prefix "Edge_is_disabled_constraint", (swig_wrapper_func) _wrap_Edge_is_disabled_constraint, NULL},
    { SWIG_prefix "Edge_is_disabled_constant", (swig_wrapper_func) _wrap_Edge_is_disabled_constant, NULL},
    { SWIG_prefix "Edge_is_disabled_cond_default", (swig_wrapper_func) _wrap_Edge_is_disabled_cond_default, NULL},
    { SWIG_prefix "Edge_disabled_constant_pins", (swig_wrapper_func) _wrap_Edge_disabled_constant_pins, NULL},
    { SWIG_prefix "Edge_is_disabled_bidirect_inst_path", (swig_wrapper_func) _wrap_Edge_is_disabled_bidirect_inst_path, NULL},
    { SWIG_prefix "Edge_is_disabled_bidirect_net_path", (swig_wrapper_func) _wrap_Edge_is_disabled_bidirect_net_path, NULL},
    { SWIG_prefix "Edge_is_disabled_preset_clear", (swig_wrapper_func) _wrap_Edge_is_disabled_preset_clear, NULL},
    { SWIG_prefix "Edge_sim_timing_sense", (swig_wrapper_func) _wrap_Edge_sim_timing_sense, NULL},
    { SWIG_prefix "Edge_arc_delays", (swig_wrapper_func) _wrap_Edge_arc_delays, NULL},
    { SWIG_prefix "Edge_arc_delay_strings", (swig_wrapper_func) _wrap_Edge_arc_delay_strings, NULL},
    { SWIG_prefix "Edge_delay_annotated", (swig_wrapper_func) _wrap_Edge_delay_annotated, NULL},
    { SWIG_prefix "Edge_arc_delay", (swig_wrapper_func) _wrap_Edge_arc_delay, NULL},
    { SWIG_prefix "Edge_cond", (swig_wrapper_func) _wrap_Edge_cond, NULL},
    { SWIG_prefix "Edge_mode_name", (swig_wrapper_func) _wrap_Edge_mode_name, NULL},
    { SWIG_prefix "Edge_mode_value", (swig_wrapper_func) _wrap_Edge_mode_value, NULL},
    { SWIG_prefix "Edge_latch_d_to_q_en", (swig_wrapper_func) _wrap_Edge_latch_d_to_q_en, NULL},
    { SWIG_prefix "Edge", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Edge},
    { SWIG_prefix "VertexIterator_has_next", (swig_wrapper_func) _wrap_VertexIterator_has_next, NULL},
    { SWIG_prefix "VertexIterator_next", (swig_wrapper_func) _wrap_VertexIterator_next, NULL},
    { SWIG_prefix "VertexIterator_finish", (swig_wrapper_func) _wrap_VertexIterator_finish, NULL},
    { SWIG_prefix "VertexIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_VertexIterator},
    { SWIG_prefix "VertexInEdgeIterator_has_next", (swig_wrapper_func) _wrap_VertexInEdgeIterator_has_next, NULL},
    { SWIG_prefix "VertexInEdgeIterator_next", (swig_wrapper_func) _wrap_VertexInEdgeIterator_next, NULL},
    { SWIG_prefix "VertexInEdgeIterator_finish", (swig_wrapper_func) _wrap_VertexInEdgeIterator_finish, NULL},
    { SWIG_prefix "VertexInEdgeIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_VertexInEdgeIterator},
    { SWIG_prefix "VertexOutEdgeIterator_has_next", (swig_wrapper_func) _wrap_VertexOutEdgeIterator_has_next, NULL},
    { SWIG_prefix "VertexOutEdgeIterator_next", (swig_wrapper_func) _wrap_VertexOutEdgeIterator_next, NULL},
    { SWIG_prefix "VertexOutEdgeIterator_finish", (swig_wrapper_func) _wrap_VertexOutEdgeIterator_finish, NULL},
    { SWIG_prefix "VertexOutEdgeIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_VertexOutEdgeIterator},
    { SWIG_prefix "PathRef_arrival", (swig_wrapper_func) _wrap_PathRef_arrival, NULL},
    { SWIG_prefix "PathRef_required", (swig_wrapper_func) _wrap_PathRef_required, NULL},
    { SWIG_prefix "PathRef_slack", (swig_wrapper_func) _wrap_PathRef_slack, NULL},
    { SWIG_prefix "PathRef_pin", (swig_wrapper_func) _wrap_PathRef_pin, NULL},
    { SWIG_prefix "PathRef_tag", (swig_wrapper_func) _wrap_PathRef_tag, NULL},
    { SWIG_prefix "PathRef_pins", (swig_wrapper_func) _wrap_PathRef_pins, NULL},
    { SWIG_prefix "PathRef", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_PathRef},
    { SWIG_prefix "PathEnd_is_unconstrained", (swig_wrapper_func) _wrap_PathEnd_is_unconstrained, NULL},
    { SWIG_prefix "PathEnd_is_check", (swig_wrapper_func) _wrap_PathEnd_is_check, NULL},
    { SWIG_prefix "PathEnd_is_latch_check", (swig_wrapper_func) _wrap_PathEnd_is_latch_check, NULL},
    { SWIG_prefix "PathEnd_is_data_check", (swig_wrapper_func) _wrap_PathEnd_is_data_check, NULL},
    { SWIG_prefix "PathEnd_is_output_delay", (swig_wrapper_func) _wrap_PathEnd_is_output_delay, NULL},
    { SWIG_prefix "PathEnd_is_path_delay", (swig_wrapper_func) _wrap_PathEnd_is_path_delay, NULL},
    { SWIG_prefix "PathEnd_is_gated_clock", (swig_wrapper_func) _wrap_PathEnd_is_gated_clock, NULL},
    { SWIG_prefix "PathEnd_vertex", (swig_wrapper_func) _wrap_PathEnd_vertex, NULL},
    { SWIG_prefix "PathEnd_path", (swig_wrapper_func) _wrap_PathEnd_path, NULL},
    { SWIG_prefix "PathEnd_end_transition", (swig_wrapper_func) _wrap_PathEnd_end_transition, NULL},
    { SWIG_prefix "PathEnd_slack", (swig_wrapper_func) _wrap_PathEnd_slack, NULL},
    { SWIG_prefix "PathEnd_margin", (swig_wrapper_func) _wrap_PathEnd_margin, NULL},
    { SWIG_prefix "PathEnd_data_required_time", (swig_wrapper_func) _wrap_PathEnd_data_required_time, NULL},
    { SWIG_prefix "PathEnd_data_arrival_time", (swig_wrapper_func) _wrap_PathEnd_data_arrival_time, NULL},
    { SWIG_prefix "PathEnd_check_role", (swig_wrapper_func) _wrap_PathEnd_check_role, NULL},
    { SWIG_prefix "PathEnd_min_max", (swig_wrapper_func) _wrap_PathEnd_min_max, NULL},
    { SWIG_prefix "PathEnd_source_clk_offset", (swig_wrapper_func) _wrap_PathEnd_source_clk_offset, NULL},
    { SWIG_prefix "PathEnd_source_clk_latency", (swig_wrapper_func) _wrap_PathEnd_source_clk_latency, NULL},
    { SWIG_prefix "PathEnd_source_clk_insertion_delay", (swig_wrapper_func) _wrap_PathEnd_source_clk_insertion_delay, NULL},
    { SWIG_prefix "PathEnd_target_clk", (swig_wrapper_func) _wrap_PathEnd_target_clk, NULL},
    { SWIG_prefix "PathEnd_target_clk_edge", (swig_wrapper_func) _wrap_PathEnd_target_clk_edge, NULL},
    { SWIG_prefix "PathEnd_target_clk_path", (swig_wrapper_func) _wrap_PathEnd_target_clk_path, NULL},
    { SWIG_prefix "PathEnd_target_clk_time", (swig_wrapper_func) _wrap_PathEnd_target_clk_time, NULL},
    { SWIG_prefix "PathEnd_target_clk_offset", (swig_wrapper_func) _wrap_PathEnd_target_clk_offset, NULL},
    { SWIG_prefix "PathEnd_target_clk_mcp_adjustment", (swig_wrapper_func) _wrap_PathEnd_target_clk_mcp_adjustment, NULL},
    { SWIG_prefix "PathEnd_target_clk_delay", (swig_wrapper_func) _wrap_PathEnd_target_clk_delay, NULL},
    { SWIG_prefix "PathEnd_target_clk_insertion_delay", (swig_wrapper_func) _wrap_PathEnd_target_clk_insertion_delay, NULL},
    { SWIG_prefix "PathEnd_target_clk_uncertainty", (swig_wrapper_func) _wrap_PathEnd_target_clk_uncertainty, NULL},
    { SWIG_prefix "PathEnd_inter_clk_uncertainty", (swig_wrapper_func) _wrap_PathEnd_inter_clk_uncertainty, NULL},
    { SWIG_prefix "PathEnd_target_clk_arrival", (swig_wrapper_func) _wrap_PathEnd_target_clk_arrival, NULL},
    { SWIG_prefix "PathEnd_path_delay_margin_is_external", (swig_wrapper_func) _wrap_PathEnd_path_delay_margin_is_external, NULL},
    { SWIG_prefix "PathEnd_common_clk_pessimism", (swig_wrapper_func) _wrap_PathEnd_common_clk_pessimism, NULL},
    { SWIG_prefix "PathEnd_target_clk_end_trans", (swig_wrapper_func) _wrap_PathEnd_target_clk_end_trans, NULL},
    { SWIG_prefix "PathEnd", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_PathEnd},
    { SWIG_prefix "MinPulseWidthCheck", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_MinPulseWidthCheck},
    { SWIG_prefix "MinPulseWidthCheckSeq", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_MinPulseWidthCheckSeq},
    { SWIG_prefix "MinPulseWidthCheckSeqIterator_has_next", (swig_wrapper_func) _wrap_MinPulseWidthCheckSeqIterator_has_next, NULL},
    { SWIG_prefix "MinPulseWidthCheckSeqIterator_next", (swig_wrapper_func) _wrap_MinPulseWidthCheckSeqIterator_next, NULL},
    { SWIG_prefix "MinPulseWidthCheckSeqIterator_finish", (swig_wrapper_func) _wrap_MinPulseWidthCheckSeqIterator_finish, NULL},
    { SWIG_prefix "MinPulseWidthCheckSeqIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_MinPulseWidthCheckSeqIterator},
    { SWIG_prefix "VertexPathIterator_has_next", (swig_wrapper_func) _wrap_VertexPathIterator_has_next, NULL},
    { SWIG_prefix "VertexPathIterator_next", (swig_wrapper_func) _wrap_VertexPathIterator_next, NULL},
    { SWIG_prefix "VertexPathIterator_finish", (swig_wrapper_func) _wrap_VertexPathIterator_finish, NULL},
    { SWIG_prefix "VertexPathIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_VertexPathIterator},
    { SWIG_prefix "SlowDrvrIterator_has_next", (swig_wrapper_func) _wrap_SlowDrvrIterator_has_next, NULL},
    { SWIG_prefix "SlowDrvrIterator_next", (swig_wrapper_func) _wrap_SlowDrvrIterator_next, NULL},
    { SWIG_prefix "SlowDrvrIterator_finish", (swig_wrapper_func) _wrap_SlowDrvrIterator_finish, NULL},
    { SWIG_prefix "SlowDrvrIterator", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_SlowDrvrIterator},
    { SWIG_prefix "ExceptionFrom", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_ExceptionFrom},
    { SWIG_prefix "ExceptionThru", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_ExceptionThru},
    { SWIG_prefix "ExceptionTo", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_ExceptionTo},
    { SWIG_prefix "OperatingConditions_process", (swig_wrapper_func) _wrap_OperatingConditions_process, NULL},
    { SWIG_prefix "OperatingConditions_voltage", (swig_wrapper_func) _wrap_OperatingConditions_voltage, NULL},
    { SWIG_prefix "OperatingConditions_temperature", (swig_wrapper_func) _wrap_OperatingConditions_temperature, NULL},
    { SWIG_prefix "OperatingConditions", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_OperatingConditions},
    { SWIG_prefix "Corner_name", (swig_wrapper_func) _wrap_Corner_name, NULL},
    { SWIG_prefix "Corner", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_Corner},
    { SWIG_prefix "version", (swig_wrapper_func) _wrap_version, NULL},
    { SWIG_prefix "git_sha1", (swig_wrapper_func) _wrap_git_sha1, NULL},
    { SWIG_prefix "report_error", (swig_wrapper_func) _wrap_report_error, NULL},
    { SWIG_prefix "report_file_error", (swig_wrapper_func) _wrap_report_file_error, NULL},
    { SWIG_prefix "report_warn", (swig_wrapper_func) _wrap_report_warn, NULL},
    { SWIG_prefix "report_file_warn", (swig_wrapper_func) _wrap_report_file_warn, NULL},
    { SWIG_prefix "report_line", (swig_wrapper_func) _wrap_report_line, NULL},
    { SWIG_prefix "fflush", (swig_wrapper_func) _wrap_fflush, NULL},
    { SWIG_prefix "redirect_file_begin", (swig_wrapper_func) _wrap_redirect_file_begin, NULL},
    { SWIG_prefix "redirect_file_append_begin", (swig_wrapper_func) _wrap_redirect_file_append_begin, NULL},
    { SWIG_prefix "redirect_file_end", (swig_wrapper_func) _wrap_redirect_file_end, NULL},
    { SWIG_prefix "redirect_string_begin", (swig_wrapper_func) _wrap_redirect_string_begin, NULL},
    { SWIG_prefix "redirect_string_end", (swig_wrapper_func) _wrap_redirect_string_end, NULL},
    { SWIG_prefix "log_begin_cmd", (swig_wrapper_func) _wrap_log_begin_cmd, NULL},
    { SWIG_prefix "log_end", (swig_wrapper_func) _wrap_log_end, NULL},
    { SWIG_prefix "set_debug", (swig_wrapper_func) _wrap_set_debug, NULL},
    { SWIG_prefix "is_object", (swig_wrapper_func) _wrap_is_object, NULL},
    { SWIG_prefix "object_type", (swig_wrapper_func) _wrap_object_type, NULL},
    { SWIG_prefix "is_object_list", (swig_wrapper_func) _wrap_is_object_list, NULL},
    { SWIG_prefix "set_rise_fall_short_names", (swig_wrapper_func) _wrap_set_rise_fall_short_names, NULL},
    { SWIG_prefix "rise_short_name", (swig_wrapper_func) _wrap_rise_short_name, NULL},
    { SWIG_prefix "fall_short_name", (swig_wrapper_func) _wrap_fall_short_name, NULL},
    { SWIG_prefix "pin_is_constrained", (swig_wrapper_func) _wrap_pin_is_constrained, NULL},
    { SWIG_prefix "instance_is_constrained", (swig_wrapper_func) _wrap_instance_is_constrained, NULL},
    { SWIG_prefix "net_is_constrained", (swig_wrapper_func) _wrap_net_is_constrained, NULL},
    { SWIG_prefix "clk_thru_tristate_enabled", (swig_wrapper_func) _wrap_clk_thru_tristate_enabled, NULL},
    { SWIG_prefix "set_clk_thru_tristate_enabled", (swig_wrapper_func) _wrap_set_clk_thru_tristate_enabled, NULL},
    { SWIG_prefix "network_is_linked", (swig_wrapper_func) _wrap_network_is_linked, NULL},
    { SWIG_prefix "set_path_divider", (swig_wrapper_func) _wrap_set_path_divider, NULL},
    { SWIG_prefix "set_current_instance", (swig_wrapper_func) _wrap_set_current_instance, NULL},
    { SWIG_prefix "read_liberty_cmd", (swig_wrapper_func) _wrap_read_liberty_cmd, NULL},
    { SWIG_prefix "set_min_library_cmd", (swig_wrapper_func) _wrap_set_min_library_cmd, NULL},
    { SWIG_prefix "find_library", (swig_wrapper_func) _wrap_find_library, NULL},
    { SWIG_prefix "library_iterator", (swig_wrapper_func) _wrap_library_iterator, NULL},
    { SWIG_prefix "find_liberty", (swig_wrapper_func) _wrap_find_liberty, NULL},
    { SWIG_prefix "liberty_library_iterator", (swig_wrapper_func) _wrap_liberty_library_iterator, NULL},
    { SWIG_prefix "find_liberty_cell", (swig_wrapper_func) _wrap_find_liberty_cell, NULL},
    { SWIG_prefix "find_cells_matching", (swig_wrapper_func) _wrap_find_cells_matching, NULL},
    { SWIG_prefix "find_library_buffers", (swig_wrapper_func) _wrap_find_library_buffers, NULL},
    { SWIG_prefix "make_equiv_cells", (swig_wrapper_func) _wrap_make_equiv_cells, NULL},
    { SWIG_prefix "find_equiv_cells", (swig_wrapper_func) _wrap_find_equiv_cells, NULL},
    { SWIG_prefix "equiv_cells", (swig_wrapper_func) _wrap_equiv_cells, NULL},
    { SWIG_prefix "equiv_cell_ports", (swig_wrapper_func) _wrap_equiv_cell_ports, NULL},
    { SWIG_prefix "equiv_cell_timing_arcs", (swig_wrapper_func) _wrap_equiv_cell_timing_arcs, NULL},
    { SWIG_prefix "set_cmd_namespace_cmd", (swig_wrapper_func) _wrap_set_cmd_namespace_cmd, NULL},
    { SWIG_prefix "link_design_cmd", (swig_wrapper_func) _wrap_link_design_cmd, NULL},
    { SWIG_prefix "link_make_black_boxes", (swig_wrapper_func) _wrap_link_make_black_boxes, NULL},
    { SWIG_prefix "set_link_make_black_boxes", (swig_wrapper_func) _wrap_set_link_make_black_boxes, NULL},
    { SWIG_prefix "top_instance", (swig_wrapper_func) _wrap_top_instance, NULL},
    { SWIG_prefix "liberty_port_direction", (swig_wrapper_func) _wrap_liberty_port_direction, NULL},
    { SWIG_prefix "port_direction", (swig_wrapper_func) _wrap_port_direction, NULL},
    { SWIG_prefix "pin_direction", (swig_wrapper_func) _wrap_pin_direction, NULL},
    { SWIG_prefix "find_ports_matching", (swig_wrapper_func) _wrap_find_ports_matching, NULL},
    { SWIG_prefix "find_port_pins_matching", (swig_wrapper_func) _wrap_find_port_pins_matching, NULL},
    { SWIG_prefix "find_pin", (swig_wrapper_func) _wrap_find_pin, NULL},
    { SWIG_prefix "find_pins_matching", (swig_wrapper_func) _wrap_find_pins_matching, NULL},
    { SWIG_prefix "find_pins_hier_matching", (swig_wrapper_func) _wrap_find_pins_hier_matching, NULL},
    { SWIG_prefix "find_instance", (swig_wrapper_func) _wrap_find_instance, NULL},
    { SWIG_prefix "network_leaf_instances", (swig_wrapper_func) _wrap_network_leaf_instances, NULL},
    { SWIG_prefix "find_instances_matching", (swig_wrapper_func) _wrap_find_instances_matching, NULL},
    { SWIG_prefix "find_instances_hier_matching", (swig_wrapper_func) _wrap_find_instances_hier_matching, NULL},
    { SWIG_prefix "find_register_instances", (swig_wrapper_func) _wrap_find_register_instances, NULL},
    { SWIG_prefix "find_register_data_pins", (swig_wrapper_func) _wrap_find_register_data_pins, NULL},
    { SWIG_prefix "find_register_clk_pins", (swig_wrapper_func) _wrap_find_register_clk_pins, NULL},
    { SWIG_prefix "find_register_async_pins", (swig_wrapper_func) _wrap_find_register_async_pins, NULL},
    { SWIG_prefix "find_register_output_pins", (swig_wrapper_func) _wrap_find_register_output_pins, NULL},
    { SWIG_prefix "find_net", (swig_wrapper_func) _wrap_find_net, NULL},
    { SWIG_prefix "find_nets_matching", (swig_wrapper_func) _wrap_find_nets_matching, NULL},
    { SWIG_prefix "find_nets_hier_matching", (swig_wrapper_func) _wrap_find_nets_hier_matching, NULL},
    { SWIG_prefix "filter_ports", (swig_wrapper_func) _wrap_filter_ports, NULL},
    { SWIG_prefix "filter_insts", (swig_wrapper_func) _wrap_filter_insts, NULL},
    { SWIG_prefix "filter_pins", (swig_wrapper_func) _wrap_filter_pins, NULL},
    { SWIG_prefix "pin_property", (swig_wrapper_func) _wrap_pin_property, NULL},
    { SWIG_prefix "instance_property", (swig_wrapper_func) _wrap_instance_property, NULL},
    { SWIG_prefix "net_property", (swig_wrapper_func) _wrap_net_property, NULL},
    { SWIG_prefix "port_property", (swig_wrapper_func) _wrap_port_property, NULL},
    { SWIG_prefix "liberty_cell_property", (swig_wrapper_func) _wrap_liberty_cell_property, NULL},
    { SWIG_prefix "cell_property", (swig_wrapper_func) _wrap_cell_property, NULL},
    { SWIG_prefix "liberty_port_property", (swig_wrapper_func) _wrap_liberty_port_property, NULL},
    { SWIG_prefix "library_property", (swig_wrapper_func) _wrap_library_property, NULL},
    { SWIG_prefix "liberty_library_property", (swig_wrapper_func) _wrap_liberty_library_property, NULL},
    { SWIG_prefix "edge_property", (swig_wrapper_func) _wrap_edge_property, NULL},
    { SWIG_prefix "clock_property", (swig_wrapper_func) _wrap_clock_property, NULL},
    { SWIG_prefix "path_end_property", (swig_wrapper_func) _wrap_path_end_property, NULL},
    { SWIG_prefix "path_ref_property", (swig_wrapper_func) _wrap_path_ref_property, NULL},
    { SWIG_prefix "timing_arc_set_property", (swig_wrapper_func) _wrap_timing_arc_set_property, NULL},
    { SWIG_prefix "leaf_instance_iterator", (swig_wrapper_func) _wrap_leaf_instance_iterator, NULL},
    { SWIG_prefix "define_corners_cmd", (swig_wrapper_func) _wrap_define_corners_cmd, NULL},
    { SWIG_prefix "cmd_corner", (swig_wrapper_func) _wrap_cmd_corner, NULL},
    { SWIG_prefix "set_cmd_corner", (swig_wrapper_func) _wrap_set_cmd_corner, NULL},
    { SWIG_prefix "find_corner", (swig_wrapper_func) _wrap_find_corner, NULL},
    { SWIG_prefix "corners", (swig_wrapper_func) _wrap_corners, NULL},
    { SWIG_prefix "multi_corner", (swig_wrapper_func) _wrap_multi_corner, NULL},
    { SWIG_prefix "set_analysis_type_cmd", (swig_wrapper_func) _wrap_set_analysis_type_cmd, NULL},
    { SWIG_prefix "operating_conditions", (swig_wrapper_func) _wrap_operating_conditions, NULL},
    { SWIG_prefix "set_operating_conditions_cmd", (swig_wrapper_func) _wrap_set_operating_conditions_cmd, NULL},
    { SWIG_prefix "filter_timing_arcs", (swig_wrapper_func) _wrap_filter_timing_arcs, NULL},
    { SWIG_prefix "operating_condition_analysis_type", (swig_wrapper_func) _wrap_operating_condition_analysis_type, NULL},
    { SWIG_prefix "set_instance_pvt", (swig_wrapper_func) _wrap_set_instance_pvt, NULL},
    { SWIG_prefix "port_ext_pin_cap", (swig_wrapper_func) _wrap_port_ext_pin_cap, NULL},
    { SWIG_prefix "set_port_pin_cap", (swig_wrapper_func) _wrap_set_port_pin_cap, NULL},
    { SWIG_prefix "port_ext_wire_cap", (swig_wrapper_func) _wrap_port_ext_wire_cap, NULL},
    { SWIG_prefix "set_port_wire_cap", (swig_wrapper_func) _wrap_set_port_wire_cap, NULL},
    { SWIG_prefix "set_port_ext_fanout_cmd", (swig_wrapper_func) _wrap_set_port_ext_fanout_cmd, NULL},
    { SWIG_prefix "port_ext_fanout", (swig_wrapper_func) _wrap_port_ext_fanout, NULL},
    { SWIG_prefix "set_net_wire_cap", (swig_wrapper_func) _wrap_set_net_wire_cap, NULL},
    { SWIG_prefix "set_wire_load_mode_cmd", (swig_wrapper_func) _wrap_set_wire_load_mode_cmd, NULL},
    { SWIG_prefix "set_net_resistance", (swig_wrapper_func) _wrap_set_net_resistance, NULL},
    { SWIG_prefix "set_wire_load_cmd", (swig_wrapper_func) _wrap_set_wire_load_cmd, NULL},
    { SWIG_prefix "set_wire_load_selection_group_cmd", (swig_wrapper_func) _wrap_set_wire_load_selection_group_cmd, NULL},
    { SWIG_prefix "make_clock", (swig_wrapper_func) _wrap_make_clock, NULL},
    { SWIG_prefix "make_generated_clock", (swig_wrapper_func) _wrap_make_generated_clock, NULL},
    { SWIG_prefix "remove_clock_cmd", (swig_wrapper_func) _wrap_remove_clock_cmd, NULL},
    { SWIG_prefix "set_propagated_clock_cmd", (swig_wrapper_func) _wrap_set_propagated_clock_cmd, NULL},
    { SWIG_prefix "set_propagated_clock_pin_cmd", (swig_wrapper_func) _wrap_set_propagated_clock_pin_cmd, NULL},
    { SWIG_prefix "unset_propagated_clock_cmd", (swig_wrapper_func) _wrap_unset_propagated_clock_cmd, NULL},
    { SWIG_prefix "unset_propagated_clock_pin_cmd", (swig_wrapper_func) _wrap_unset_propagated_clock_pin_cmd, NULL},
    { SWIG_prefix "set_clock_slew_cmd", (swig_wrapper_func) _wrap_set_clock_slew_cmd, NULL},
    { SWIG_prefix "unset_clock_slew_cmd", (swig_wrapper_func) _wrap_unset_clock_slew_cmd, NULL},
    { SWIG_prefix "set_clock_latency_cmd", (swig_wrapper_func) _wrap_set_clock_latency_cmd, NULL},
    { SWIG_prefix "set_clock_insertion_cmd", (swig_wrapper_func) _wrap_set_clock_insertion_cmd, NULL},
    { SWIG_prefix "unset_clock_latency_cmd", (swig_wrapper_func) _wrap_unset_clock_latency_cmd, NULL},
    { SWIG_prefix "unset_clock_insertion_cmd", (swig_wrapper_func) _wrap_unset_clock_insertion_cmd, NULL},
    { SWIG_prefix "set_clock_uncertainty_clk", (swig_wrapper_func) _wrap_set_clock_uncertainty_clk, NULL},
    { SWIG_prefix "unset_clock_uncertainty_clk", (swig_wrapper_func) _wrap_unset_clock_uncertainty_clk, NULL},
    { SWIG_prefix "set_clock_uncertainty_pin", (swig_wrapper_func) _wrap_set_clock_uncertainty_pin, NULL},
    { SWIG_prefix "unset_clock_uncertainty_pin", (swig_wrapper_func) _wrap_unset_clock_uncertainty_pin, NULL},
    { SWIG_prefix "set_inter_clock_uncertainty", (swig_wrapper_func) _wrap_set_inter_clock_uncertainty, NULL},
    { SWIG_prefix "unset_inter_clock_uncertainty", (swig_wrapper_func) _wrap_unset_inter_clock_uncertainty, NULL},
    { SWIG_prefix "set_clock_gating_check_cmd", (swig_wrapper_func) _wrap_set_clock_gating_check_cmd, NULL},
    { SWIG_prefix "set_clock_gating_check_clk_cmd", (swig_wrapper_func) _wrap_set_clock_gating_check_clk_cmd, NULL},
    { SWIG_prefix "set_clock_gating_check_pin_cmd", (swig_wrapper_func) _wrap_set_clock_gating_check_pin_cmd, NULL},
    { SWIG_prefix "set_clock_gating_check_instance_cmd", (swig_wrapper_func) _wrap_set_clock_gating_check_instance_cmd, NULL},
    { SWIG_prefix "set_data_check_cmd", (swig_wrapper_func) _wrap_set_data_check_cmd, NULL},
    { SWIG_prefix "unset_data_check_cmd", (swig_wrapper_func) _wrap_unset_data_check_cmd, NULL},
    { SWIG_prefix "set_input_delay_cmd", (swig_wrapper_func) _wrap_set_input_delay_cmd, NULL},
    { SWIG_prefix "unset_input_delay_cmd", (swig_wrapper_func) _wrap_unset_input_delay_cmd, NULL},
    { SWIG_prefix "set_output_delay_cmd", (swig_wrapper_func) _wrap_set_output_delay_cmd, NULL},
    { SWIG_prefix "unset_output_delay_cmd", (swig_wrapper_func) _wrap_unset_output_delay_cmd, NULL},
    { SWIG_prefix "disable_cell", (swig_wrapper_func) _wrap_disable_cell, NULL},
    { SWIG_prefix "unset_disable_cell", (swig_wrapper_func) _wrap_unset_disable_cell, NULL},
    { SWIG_prefix "disable_lib_port", (swig_wrapper_func) _wrap_disable_lib_port, NULL},
    { SWIG_prefix "unset_disable_lib_port", (swig_wrapper_func) _wrap_unset_disable_lib_port, NULL},
    { SWIG_prefix "disable_port", (swig_wrapper_func) _wrap_disable_port, NULL},
    { SWIG_prefix "unset_disable_port", (swig_wrapper_func) _wrap_unset_disable_port, NULL},
    { SWIG_prefix "disable_instance", (swig_wrapper_func) _wrap_disable_instance, NULL},
    { SWIG_prefix "unset_disable_instance", (swig_wrapper_func) _wrap_unset_disable_instance, NULL},
    { SWIG_prefix "disable_pin", (swig_wrapper_func) _wrap_disable_pin, NULL},
    { SWIG_prefix "unset_disable_pin", (swig_wrapper_func) _wrap_unset_disable_pin, NULL},
    { SWIG_prefix "disable_edge", (swig_wrapper_func) _wrap_disable_edge, NULL},
    { SWIG_prefix "unset_disable_edge", (swig_wrapper_func) _wrap_unset_disable_edge, NULL},
    { SWIG_prefix "disable_timing_arc_set", (swig_wrapper_func) _wrap_disable_timing_arc_set, NULL},
    { SWIG_prefix "unset_disable_timing_arc_set", (swig_wrapper_func) _wrap_unset_disable_timing_arc_set, NULL},
    { SWIG_prefix "disable_clock_gating_check_inst", (swig_wrapper_func) _wrap_disable_clock_gating_check_inst, NULL},
    { SWIG_prefix "disable_clock_gating_check_pin", (swig_wrapper_func) _wrap_disable_clock_gating_check_pin, NULL},
    { SWIG_prefix "unset_disable_clock_gating_check_inst", (swig_wrapper_func) _wrap_unset_disable_clock_gating_check_inst, NULL},
    { SWIG_prefix "unset_disable_clock_gating_check_pin", (swig_wrapper_func) _wrap_unset_disable_clock_gating_check_pin, NULL},
    { SWIG_prefix "make_false_path", (swig_wrapper_func) _wrap_make_false_path, NULL},
    { SWIG_prefix "make_multicycle_path", (swig_wrapper_func) _wrap_make_multicycle_path, NULL},
    { SWIG_prefix "make_path_delay", (swig_wrapper_func) _wrap_make_path_delay, NULL},
    { SWIG_prefix "reset_path_cmd", (swig_wrapper_func) _wrap_reset_path_cmd, NULL},
    { SWIG_prefix "make_group_path", (swig_wrapper_func) _wrap_make_group_path, NULL},
    { SWIG_prefix "is_path_group_name", (swig_wrapper_func) _wrap_is_path_group_name, NULL},
    { SWIG_prefix "make_exception_from", (swig_wrapper_func) _wrap_make_exception_from, NULL},
    { SWIG_prefix "delete_exception_from", (swig_wrapper_func) _wrap_delete_exception_from, NULL},
    { SWIG_prefix "check_exception_from_pins", (swig_wrapper_func) _wrap_check_exception_from_pins, NULL},
    { SWIG_prefix "make_exception_thru", (swig_wrapper_func) _wrap_make_exception_thru, NULL},
    { SWIG_prefix "delete_exception_thru", (swig_wrapper_func) _wrap_delete_exception_thru, NULL},
    { SWIG_prefix "make_exception_to", (swig_wrapper_func) _wrap_make_exception_to, NULL},
    { SWIG_prefix "delete_exception_to", (swig_wrapper_func) _wrap_delete_exception_to, NULL},
    { SWIG_prefix "check_exception_to_pins", (swig_wrapper_func) _wrap_check_exception_to_pins, NULL},
    { SWIG_prefix "set_input_slew_cmd", (swig_wrapper_func) _wrap_set_input_slew_cmd, NULL},
    { SWIG_prefix "set_drive_cell_cmd", (swig_wrapper_func) _wrap_set_drive_cell_cmd, NULL},
    { SWIG_prefix "set_drive_resistance_cmd", (swig_wrapper_func) _wrap_set_drive_resistance_cmd, NULL},
    { SWIG_prefix "set_slew_limit_clk", (swig_wrapper_func) _wrap_set_slew_limit_clk, NULL},
    { SWIG_prefix "set_slew_limit_port", (swig_wrapper_func) _wrap_set_slew_limit_port, NULL},
    { SWIG_prefix "set_slew_limit_cell", (swig_wrapper_func) _wrap_set_slew_limit_cell, NULL},
    { SWIG_prefix "set_port_capacitance_limit", (swig_wrapper_func) _wrap_set_port_capacitance_limit, NULL},
    { SWIG_prefix "set_pin_capacitance_limit", (swig_wrapper_func) _wrap_set_pin_capacitance_limit, NULL},
    { SWIG_prefix "set_cell_capacitance_limit", (swig_wrapper_func) _wrap_set_cell_capacitance_limit, NULL},
    { SWIG_prefix "set_latch_borrow_limit_pin", (swig_wrapper_func) _wrap_set_latch_borrow_limit_pin, NULL},
    { SWIG_prefix "set_latch_borrow_limit_inst", (swig_wrapper_func) _wrap_set_latch_borrow_limit_inst, NULL},
    { SWIG_prefix "set_latch_borrow_limit_clk", (swig_wrapper_func) _wrap_set_latch_borrow_limit_clk, NULL},
    { SWIG_prefix "set_min_pulse_width_global", (swig_wrapper_func) _wrap_set_min_pulse_width_global, NULL},
    { SWIG_prefix "set_min_pulse_width_pin", (swig_wrapper_func) _wrap_set_min_pulse_width_pin, NULL},
    { SWIG_prefix "set_min_pulse_width_clk", (swig_wrapper_func) _wrap_set_min_pulse_width_clk, NULL},
    { SWIG_prefix "set_min_pulse_width_inst", (swig_wrapper_func) _wrap_set_min_pulse_width_inst, NULL},
    { SWIG_prefix "set_max_area_cmd", (swig_wrapper_func) _wrap_set_max_area_cmd, NULL},
    { SWIG_prefix "set_port_fanout_limit", (swig_wrapper_func) _wrap_set_port_fanout_limit, NULL},
    { SWIG_prefix "set_cell_fanout_limit", (swig_wrapper_func) _wrap_set_cell_fanout_limit, NULL},
    { SWIG_prefix "set_logic_value_cmd", (swig_wrapper_func) _wrap_set_logic_value_cmd, NULL},
    { SWIG_prefix "set_case_analysis_cmd", (swig_wrapper_func) _wrap_set_case_analysis_cmd, NULL},
    { SWIG_prefix "unset_case_analysis_cmd", (swig_wrapper_func) _wrap_unset_case_analysis_cmd, NULL},
    { SWIG_prefix "set_timing_derate_cmd", (swig_wrapper_func) _wrap_set_timing_derate_cmd, NULL},
    { SWIG_prefix "set_timing_derate_net_cmd", (swig_wrapper_func) _wrap_set_timing_derate_net_cmd, NULL},
    { SWIG_prefix "set_timing_derate_inst_cmd", (swig_wrapper_func) _wrap_set_timing_derate_inst_cmd, NULL},
    { SWIG_prefix "set_timing_derate_cell_cmd", (swig_wrapper_func) _wrap_set_timing_derate_cell_cmd, NULL},
    { SWIG_prefix "unset_timing_derate_cmd", (swig_wrapper_func) _wrap_unset_timing_derate_cmd, NULL},
    { SWIG_prefix "clock_iterator", (swig_wrapper_func) _wrap_clock_iterator, NULL},
    { SWIG_prefix "find_clock", (swig_wrapper_func) _wrap_find_clock, NULL},
    { SWIG_prefix "is_clock_src", (swig_wrapper_func) _wrap_is_clock_src, NULL},
    { SWIG_prefix "default_arrival_clock", (swig_wrapper_func) _wrap_default_arrival_clock, NULL},
    { SWIG_prefix "find_clocks_matching", (swig_wrapper_func) _wrap_find_clocks_matching, NULL},
    { SWIG_prefix "update_generated_clks", (swig_wrapper_func) _wrap_update_generated_clks, NULL},
    { SWIG_prefix "is_clock", (swig_wrapper_func) _wrap_is_clock, NULL},
    { SWIG_prefix "is_ideal_clock", (swig_wrapper_func) _wrap_is_ideal_clock, NULL},
    { SWIG_prefix "is_clock_search", (swig_wrapper_func) _wrap_is_clock_search, NULL},
    { SWIG_prefix "is_genclk_src", (swig_wrapper_func) _wrap_is_genclk_src, NULL},
    { SWIG_prefix "format_time", (swig_wrapper_func) _wrap_format_time, NULL},
    { SWIG_prefix "format_capacitance", (swig_wrapper_func) _wrap_format_capacitance, NULL},
    { SWIG_prefix "format_resistance", (swig_wrapper_func) _wrap_format_resistance, NULL},
    { SWIG_prefix "format_voltage", (swig_wrapper_func) _wrap_format_voltage, NULL},
    { SWIG_prefix "format_power", (swig_wrapper_func) _wrap_format_power, NULL},
    { SWIG_prefix "format_distance", (swig_wrapper_func) _wrap_format_distance, NULL},
    { SWIG_prefix "format_area", (swig_wrapper_func) _wrap_format_area, NULL},
    { SWIG_prefix "time_ui_sta", (swig_wrapper_func) _wrap_time_ui_sta, NULL},
    { SWIG_prefix "time_sta_ui", (swig_wrapper_func) _wrap_time_sta_ui, NULL},
    { SWIG_prefix "capacitance_ui_sta", (swig_wrapper_func) _wrap_capacitance_ui_sta, NULL},
    { SWIG_prefix "capacitance_sta_ui", (swig_wrapper_func) _wrap_capacitance_sta_ui, NULL},
    { SWIG_prefix "resistance_ui_sta", (swig_wrapper_func) _wrap_resistance_ui_sta, NULL},
    { SWIG_prefix "resistance_sta_ui", (swig_wrapper_func) _wrap_resistance_sta_ui, NULL},
    { SWIG_prefix "voltage_ui_sta", (swig_wrapper_func) _wrap_voltage_ui_sta, NULL},
    { SWIG_prefix "voltage_sta_ui", (swig_wrapper_func) _wrap_voltage_sta_ui, NULL},
    { SWIG_prefix "current_ui_sta", (swig_wrapper_func) _wrap_current_ui_sta, NULL},
    { SWIG_prefix "current_sta_ui", (swig_wrapper_func) _wrap_current_sta_ui, NULL},
    { SWIG_prefix "power_ui_sta", (swig_wrapper_func) _wrap_power_ui_sta, NULL},
    { SWIG_prefix "power_sta_ui", (swig_wrapper_func) _wrap_power_sta_ui, NULL},
    { SWIG_prefix "distance_ui_sta", (swig_wrapper_func) _wrap_distance_ui_sta, NULL},
    { SWIG_prefix "distance_sta_ui", (swig_wrapper_func) _wrap_distance_sta_ui, NULL},
    { SWIG_prefix "area_ui_sta", (swig_wrapper_func) _wrap_area_ui_sta, NULL},
    { SWIG_prefix "area_sta_ui", (swig_wrapper_func) _wrap_area_sta_ui, NULL},
    { SWIG_prefix "set_cmd_unit_scale", (swig_wrapper_func) _wrap_set_cmd_unit_scale, NULL},
    { SWIG_prefix "set_cmd_unit_digits", (swig_wrapper_func) _wrap_set_cmd_unit_digits, NULL},
    { SWIG_prefix "set_cmd_unit_suffix", (swig_wrapper_func) _wrap_set_cmd_unit_suffix, NULL},
    { SWIG_prefix "unit_scale_abreviation", (swig_wrapper_func) _wrap_unit_scale_abreviation, NULL},
    { SWIG_prefix "unit_suffix", (swig_wrapper_func) _wrap_unit_suffix, NULL},
    { SWIG_prefix "vertex_iterator", (swig_wrapper_func) _wrap_vertex_iterator, NULL},
    { SWIG_prefix "set_arc_delay", (swig_wrapper_func) _wrap_set_arc_delay, NULL},
    { SWIG_prefix "set_annotated_slew", (swig_wrapper_func) _wrap_set_annotated_slew, NULL},
    { SWIG_prefix "remove_delay_slew_annotations", (swig_wrapper_func) _wrap_remove_delay_slew_annotations, NULL},
    { SWIG_prefix "check_timing_cmd", (swig_wrapper_func) _wrap_check_timing_cmd, NULL},
    { SWIG_prefix "crpr_enabled", (swig_wrapper_func) _wrap_crpr_enabled, NULL},
    { SWIG_prefix "set_crpr_enabled", (swig_wrapper_func) _wrap_set_crpr_enabled, NULL},
    { SWIG_prefix "crpr_mode", (swig_wrapper_func) _wrap_crpr_mode, NULL},
    { SWIG_prefix "set_crpr_mode", (swig_wrapper_func) _wrap_set_crpr_mode, NULL},
    { SWIG_prefix "pocv_enabled", (swig_wrapper_func) _wrap_pocv_enabled, NULL},
    { SWIG_prefix "set_pocv_enabled", (swig_wrapper_func) _wrap_set_pocv_enabled, NULL},
    { SWIG_prefix "pocv_sigma_factor", (swig_wrapper_func) _wrap_pocv_sigma_factor, NULL},
    { SWIG_prefix "set_pocv_sigma_factor", (swig_wrapper_func) _wrap_set_pocv_sigma_factor, NULL},
    { SWIG_prefix "propagate_gated_clock_enable", (swig_wrapper_func) _wrap_propagate_gated_clock_enable, NULL},
    { SWIG_prefix "set_propagate_gated_clock_enable", (swig_wrapper_func) _wrap_set_propagate_gated_clock_enable, NULL},
    { SWIG_prefix "preset_clr_arcs_enabled", (swig_wrapper_func) _wrap_preset_clr_arcs_enabled, NULL},
    { SWIG_prefix "set_preset_clr_arcs_enabled", (swig_wrapper_func) _wrap_set_preset_clr_arcs_enabled, NULL},
    { SWIG_prefix "cond_default_arcs_enabled", (swig_wrapper_func) _wrap_cond_default_arcs_enabled, NULL},
    { SWIG_prefix "set_cond_default_arcs_enabled", (swig_wrapper_func) _wrap_set_cond_default_arcs_enabled, NULL},
    { SWIG_prefix "bidirect_inst_paths_enabled", (swig_wrapper_func) _wrap_bidirect_inst_paths_enabled, NULL},
    { SWIG_prefix "set_bidirect_inst_paths_enabled", (swig_wrapper_func) _wrap_set_bidirect_inst_paths_enabled, NULL},
    { SWIG_prefix "bidirect_net_paths_enabled", (swig_wrapper_func) _wrap_bidirect_net_paths_enabled, NULL},
    { SWIG_prefix "set_bidirect_net_paths_enabled", (swig_wrapper_func) _wrap_set_bidirect_net_paths_enabled, NULL},
    { SWIG_prefix "recovery_removal_checks_enabled", (swig_wrapper_func) _wrap_recovery_removal_checks_enabled, NULL},
    { SWIG_prefix "set_recovery_removal_checks_enabled", (swig_wrapper_func) _wrap_set_recovery_removal_checks_enabled, NULL},
    { SWIG_prefix "gated_clk_checks_enabled", (swig_wrapper_func) _wrap_gated_clk_checks_enabled, NULL},
    { SWIG_prefix "set_gated_clk_checks_enabled", (swig_wrapper_func) _wrap_set_gated_clk_checks_enabled, NULL},
    { SWIG_prefix "dynamic_loop_breaking", (swig_wrapper_func) _wrap_dynamic_loop_breaking, NULL},
    { SWIG_prefix "set_dynamic_loop_breaking", (swig_wrapper_func) _wrap_set_dynamic_loop_breaking, NULL},
    { SWIG_prefix "use_default_arrival_clock", (swig_wrapper_func) _wrap_use_default_arrival_clock, NULL},
    { SWIG_prefix "set_use_default_arrival_clock", (swig_wrapper_func) _wrap_set_use_default_arrival_clock, NULL},
    { SWIG_prefix "propagate_all_clocks", (swig_wrapper_func) _wrap_propagate_all_clocks, NULL},
    { SWIG_prefix "set_propagate_all_clocks", (swig_wrapper_func) _wrap_set_propagate_all_clocks, NULL},
    { SWIG_prefix "find_path_ends", (swig_wrapper_func) _wrap_find_path_ends, NULL},
    { SWIG_prefix "report_path_end_header", (swig_wrapper_func) _wrap_report_path_end_header, NULL},
    { SWIG_prefix "report_path_end_footer", (swig_wrapper_func) _wrap_report_path_end_footer, NULL},
    { SWIG_prefix "report_path_end", (swig_wrapper_func) _wrap_report_path_end, NULL},
    { SWIG_prefix "report_path_end2", (swig_wrapper_func) _wrap_report_path_end2, NULL},
    { SWIG_prefix "set_report_path_format", (swig_wrapper_func) _wrap_set_report_path_format, NULL},
    { SWIG_prefix "set_report_path_field_order", (swig_wrapper_func) _wrap_set_report_path_field_order, NULL},
    { SWIG_prefix "set_report_path_fields", (swig_wrapper_func) _wrap_set_report_path_fields, NULL},
    { SWIG_prefix "set_report_path_field_properties", (swig_wrapper_func) _wrap_set_report_path_field_properties, NULL},
    { SWIG_prefix "set_report_path_field_width", (swig_wrapper_func) _wrap_set_report_path_field_width, NULL},
    { SWIG_prefix "set_report_path_digits", (swig_wrapper_func) _wrap_set_report_path_digits, NULL},
    { SWIG_prefix "set_report_path_no_split", (swig_wrapper_func) _wrap_set_report_path_no_split, NULL},
    { SWIG_prefix "set_report_path_sigmas", (swig_wrapper_func) _wrap_set_report_path_sigmas, NULL},
    { SWIG_prefix "delete_path_ref", (swig_wrapper_func) _wrap_delete_path_ref, NULL},
    { SWIG_prefix "remove_constraints", (swig_wrapper_func) _wrap_remove_constraints, NULL},
    { SWIG_prefix "report_path_cmd", (swig_wrapper_func) _wrap_report_path_cmd, NULL},
    { SWIG_prefix "report_clk_skew", (swig_wrapper_func) _wrap_report_clk_skew, NULL},
    { SWIG_prefix "worst_clk_skew_cmd", (swig_wrapper_func) _wrap_worst_clk_skew_cmd, NULL},
    { SWIG_prefix "startpoints", (swig_wrapper_func) _wrap_startpoints, NULL},
    { SWIG_prefix "endpoints", (swig_wrapper_func) _wrap_endpoints, NULL},
    { SWIG_prefix "group_path_pins", (swig_wrapper_func) _wrap_group_path_pins, NULL},
    { SWIG_prefix "min_pulse_width_violations", (swig_wrapper_func) _wrap_min_pulse_width_violations, NULL},
    { SWIG_prefix "min_pulse_width_check_pins", (swig_wrapper_func) _wrap_min_pulse_width_check_pins, NULL},
    { SWIG_prefix "min_pulse_width_checks", (swig_wrapper_func) _wrap_min_pulse_width_checks, NULL},
    { SWIG_prefix "min_pulse_width_check_slack", (swig_wrapper_func) _wrap_min_pulse_width_check_slack, NULL},
    { SWIG_prefix "report_mpw_checks", (swig_wrapper_func) _wrap_report_mpw_checks, NULL},
    { SWIG_prefix "report_mpw_check", (swig_wrapper_func) _wrap_report_mpw_check, NULL},
    { SWIG_prefix "min_period_violations", (swig_wrapper_func) _wrap_min_period_violations, NULL},
    { SWIG_prefix "min_period_check_slack", (swig_wrapper_func) _wrap_min_period_check_slack, NULL},
    { SWIG_prefix "report_min_period_checks", (swig_wrapper_func) _wrap_report_min_period_checks, NULL},
    { SWIG_prefix "report_min_period_check", (swig_wrapper_func) _wrap_report_min_period_check, NULL},
    { SWIG_prefix "max_skew_violations", (swig_wrapper_func) _wrap_max_skew_violations, NULL},
    { SWIG_prefix "max_skew_check_slack", (swig_wrapper_func) _wrap_max_skew_check_slack, NULL},
    { SWIG_prefix "report_max_skew_checks", (swig_wrapper_func) _wrap_report_max_skew_checks, NULL},
    { SWIG_prefix "report_max_skew_check", (swig_wrapper_func) _wrap_report_max_skew_check, NULL},
    { SWIG_prefix "find_timing_cmd", (swig_wrapper_func) _wrap_find_timing_cmd, NULL},
    { SWIG_prefix "find_requireds", (swig_wrapper_func) _wrap_find_requireds, NULL},
    { SWIG_prefix "find_delays", (swig_wrapper_func) _wrap_find_delays, NULL},
    { SWIG_prefix "total_negative_slack_cmd", (swig_wrapper_func) _wrap_total_negative_slack_cmd, NULL},
    { SWIG_prefix "total_negative_slack_corner_cmd", (swig_wrapper_func) _wrap_total_negative_slack_corner_cmd, NULL},
    { SWIG_prefix "worst_slack_cmd", (swig_wrapper_func) _wrap_worst_slack_cmd, NULL},
    { SWIG_prefix "worst_slack_vertex", (swig_wrapper_func) _wrap_worst_slack_vertex, NULL},
    { SWIG_prefix "worst_slack_corner", (swig_wrapper_func) _wrap_worst_slack_corner, NULL},
    { SWIG_prefix "vertex_worst_arrival_path", (swig_wrapper_func) _wrap_vertex_worst_arrival_path, NULL},
    { SWIG_prefix "vertex_worst_arrival_path_rf", (swig_wrapper_func) _wrap_vertex_worst_arrival_path_rf, NULL},
    { SWIG_prefix "vertex_worst_slack_path", (swig_wrapper_func) _wrap_vertex_worst_slack_path, NULL},
    { SWIG_prefix "find_clk_min_period", (swig_wrapper_func) _wrap_find_clk_min_period, NULL},
    { SWIG_prefix "report_delay_calc_cmd", (swig_wrapper_func) _wrap_report_delay_calc_cmd, NULL},
    { SWIG_prefix "check_slew_limits", (swig_wrapper_func) _wrap_check_slew_limits, NULL},
    { SWIG_prefix "max_slew_violation_count", (swig_wrapper_func) _wrap_max_slew_violation_count, NULL},
    { SWIG_prefix "report_slew_limit_short_header", (swig_wrapper_func) _wrap_report_slew_limit_short_header, NULL},
    { SWIG_prefix "report_slew_limit_short", (swig_wrapper_func) _wrap_report_slew_limit_short, NULL},
    { SWIG_prefix "report_slew_limit_verbose", (swig_wrapper_func) _wrap_report_slew_limit_verbose, NULL},
    { SWIG_prefix "check_fanout_limits", (swig_wrapper_func) _wrap_check_fanout_limits, NULL},
    { SWIG_prefix "max_fanout_violation_count", (swig_wrapper_func) _wrap_max_fanout_violation_count, NULL},
    { SWIG_prefix "report_fanout_limit_short_header", (swig_wrapper_func) _wrap_report_fanout_limit_short_header, NULL},
    { SWIG_prefix "report_fanout_limit_short", (swig_wrapper_func) _wrap_report_fanout_limit_short, NULL},
    { SWIG_prefix "report_fanout_limit_verbose", (swig_wrapper_func) _wrap_report_fanout_limit_verbose, NULL},
    { SWIG_prefix "check_capacitance_limits", (swig_wrapper_func) _wrap_check_capacitance_limits, NULL},
    { SWIG_prefix "max_capacitance_violation_count", (swig_wrapper_func) _wrap_max_capacitance_violation_count, NULL},
    { SWIG_prefix "report_capacitance_limit_short_header", (swig_wrapper_func) _wrap_report_capacitance_limit_short_header, NULL},
    { SWIG_prefix "report_capacitance_limit_short", (swig_wrapper_func) _wrap_report_capacitance_limit_short, NULL},
    { SWIG_prefix "report_capacitance_limit_verbose", (swig_wrapper_func) _wrap_report_capacitance_limit_verbose, NULL},
    { SWIG_prefix "design_power", (swig_wrapper_func) _wrap_design_power, NULL},
    { SWIG_prefix "instance_power", (swig_wrapper_func) _wrap_instance_power, NULL},
    { SWIG_prefix "set_power_global_activity", (swig_wrapper_func) _wrap_set_power_global_activity, NULL},
    { SWIG_prefix "set_power_input_activity", (swig_wrapper_func) _wrap_set_power_input_activity, NULL},
    { SWIG_prefix "set_power_input_port_activity", (swig_wrapper_func) _wrap_set_power_input_port_activity, NULL},
    { SWIG_prefix "set_power_pin_activity", (swig_wrapper_func) _wrap_set_power_pin_activity, NULL},
    { SWIG_prefix "disabled_edges_sorted", (swig_wrapper_func) _wrap_disabled_edges_sorted, NULL},
    { SWIG_prefix "write_sdc_cmd", (swig_wrapper_func) _wrap_write_sdc_cmd, NULL},
    { SWIG_prefix "write_path_spice_cmd", (swig_wrapper_func) _wrap_write_path_spice_cmd, NULL},
    { SWIG_prefix "liberty_supply_exists", (swig_wrapper_func) _wrap_liberty_supply_exists, NULL},
    { SWIG_prefix "unit_scale", (swig_wrapper_func) _wrap_unit_scale, NULL},
    { SWIG_prefix "fuzzy_equal", (swig_wrapper_func) _wrap_fuzzy_equal, NULL},
    { SWIG_prefix "pin_sim_logic_value", (swig_wrapper_func) _wrap_pin_sim_logic_value, NULL},
    { SWIG_prefix "pin_case_logic_value", (swig_wrapper_func) _wrap_pin_case_logic_value, NULL},
    { SWIG_prefix "pin_logic_value", (swig_wrapper_func) _wrap_pin_logic_value, NULL},
    { SWIG_prefix "slow_driver_iterator", (swig_wrapper_func) _wrap_slow_driver_iterator, NULL},
    { SWIG_prefix "timing_arc_disabled", (swig_wrapper_func) _wrap_timing_arc_disabled, NULL},
    { SWIG_prefix "make_clock_groups", (swig_wrapper_func) _wrap_make_clock_groups, NULL},
    { SWIG_prefix "clock_groups_make_group", (swig_wrapper_func) _wrap_clock_groups_make_group, NULL},
    { SWIG_prefix "unset_clock_groups_logically_exclusive", (swig_wrapper_func) _wrap_unset_clock_groups_logically_exclusive, NULL},
    { SWIG_prefix "unset_clock_groups_physically_exclusive", (swig_wrapper_func) _wrap_unset_clock_groups_physically_exclusive, NULL},
    { SWIG_prefix "unset_clock_groups_asynchronous", (swig_wrapper_func) _wrap_unset_clock_groups_asynchronous, NULL},
    { SWIG_prefix "same_clk_group", (swig_wrapper_func) _wrap_same_clk_group, NULL},
    { SWIG_prefix "set_clock_sense_cmd", (swig_wrapper_func) _wrap_set_clock_sense_cmd, NULL},
    { SWIG_prefix "timing_role_is_check", (swig_wrapper_func) _wrap_timing_role_is_check, NULL},
    { SWIG_prefix "find_fanin_pins", (swig_wrapper_func) _wrap_find_fanin_pins, NULL},
    { SWIG_prefix "find_fanin_insts", (swig_wrapper_func) _wrap_find_fanin_insts, NULL},
    { SWIG_prefix "find_fanout_pins", (swig_wrapper_func) _wrap_find_fanout_pins, NULL},
    { SWIG_prefix "find_fanout_insts", (swig_wrapper_func) _wrap_find_fanout_insts, NULL},
    { SWIG_prefix "net_load_pins", (swig_wrapper_func) _wrap_net_load_pins, NULL},
    { SWIG_prefix "net_driver_pins", (swig_wrapper_func) _wrap_net_driver_pins, NULL},
    { SWIG_prefix "report_loops", (swig_wrapper_func) _wrap_report_loops, NULL},
    { SWIG_prefix "network_instance_count", (swig_wrapper_func) _wrap_network_instance_count, NULL},
    { SWIG_prefix "network_pin_count", (swig_wrapper_func) _wrap_network_pin_count, NULL},
    { SWIG_prefix "network_net_count", (swig_wrapper_func) _wrap_network_net_count, NULL},
    { SWIG_prefix "network_leaf_instance_count", (swig_wrapper_func) _wrap_network_leaf_instance_count, NULL},
    { SWIG_prefix "network_leaf_pin_count", (swig_wrapper_func) _wrap_network_leaf_pin_count, NULL},
    { SWIG_prefix "graph_vertex_count", (swig_wrapper_func) _wrap_graph_vertex_count, NULL},
    { SWIG_prefix "graph_edge_count", (swig_wrapper_func) _wrap_graph_edge_count, NULL},
    { SWIG_prefix "graph_arc_count", (swig_wrapper_func) _wrap_graph_arc_count, NULL},
    { SWIG_prefix "tag_group_count", (swig_wrapper_func) _wrap_tag_group_count, NULL},
    { SWIG_prefix "report_tag_groups", (swig_wrapper_func) _wrap_report_tag_groups, NULL},
    { SWIG_prefix "report_tag_arrivals_cmd", (swig_wrapper_func) _wrap_report_tag_arrivals_cmd, NULL},
    { SWIG_prefix "report_arrival_count_histogram", (swig_wrapper_func) _wrap_report_arrival_count_histogram, NULL},
    { SWIG_prefix "tag_count", (swig_wrapper_func) _wrap_tag_count, NULL},
    { SWIG_prefix "report_tags", (swig_wrapper_func) _wrap_report_tags, NULL},
    { SWIG_prefix "report_clk_infos", (swig_wrapper_func) _wrap_report_clk_infos, NULL},
    { SWIG_prefix "clk_info_count", (swig_wrapper_func) _wrap_clk_info_count, NULL},
    { SWIG_prefix "arrival_count", (swig_wrapper_func) _wrap_arrival_count, NULL},
    { SWIG_prefix "required_count", (swig_wrapper_func) _wrap_required_count, NULL},
    { SWIG_prefix "graph_arrival_count", (swig_wrapper_func) _wrap_graph_arrival_count, NULL},
    { SWIG_prefix "graph_required_count", (swig_wrapper_func) _wrap_graph_required_count, NULL},
    { SWIG_prefix "delete_all_memory", (swig_wrapper_func) _wrap_delete_all_memory, NULL},
    { SWIG_prefix "tcl_interp", (swig_wrapper_func) _wrap_tcl_interp, NULL},
    { SWIG_prefix "init_sta", (swig_wrapper_func) _wrap_init_sta, NULL},
    { SWIG_prefix "clear_sta", (swig_wrapper_func) _wrap_clear_sta, NULL},
    { SWIG_prefix "make_sta", (swig_wrapper_func) _wrap_make_sta, NULL},
    { SWIG_prefix "clear_network", (swig_wrapper_func) _wrap_clear_network, NULL},
    { SWIG_prefix "elapsed_run_time", (swig_wrapper_func) _wrap_elapsed_run_time, NULL},
    { SWIG_prefix "user_run_time", (swig_wrapper_func) _wrap_user_run_time, NULL},
    { SWIG_prefix "cputime", (swig_wrapper_func) _wrap_cputime, NULL},
    { SWIG_prefix "memory_usage", (swig_wrapper_func) _wrap_memory_usage, NULL},
    { SWIG_prefix "processor_count", (swig_wrapper_func) _wrap_processor_count, NULL},
    { SWIG_prefix "thread_count", (swig_wrapper_func) _wrap_thread_count, NULL},
    { SWIG_prefix "set_thread_count", (swig_wrapper_func) _wrap_set_thread_count, NULL},
    { SWIG_prefix "arrivals_invalid", (swig_wrapper_func) _wrap_arrivals_invalid, NULL},
    { SWIG_prefix "delays_invalid", (swig_wrapper_func) _wrap_delays_invalid, NULL},
    { SWIG_prefix "pin_location", (swig_wrapper_func) _wrap_pin_location, NULL},
    { SWIG_prefix "port_location", (swig_wrapper_func) _wrap_port_location, NULL},
    { SWIG_prefix "endpoint_count", (swig_wrapper_func) _wrap_endpoint_count, NULL},
    { SWIG_prefix "make_instance_cmd", (swig_wrapper_func) _wrap_make_instance_cmd, NULL},
    { SWIG_prefix "delete_instance_cmd", (swig_wrapper_func) _wrap_delete_instance_cmd, NULL},
    { SWIG_prefix "replace_cell_cmd", (swig_wrapper_func) _wrap_replace_cell_cmd, NULL},
    { SWIG_prefix "make_net_cmd", (swig_wrapper_func) _wrap_make_net_cmd, NULL},
    { SWIG_prefix "delete_net_cmd", (swig_wrapper_func) _wrap_delete_net_cmd, NULL},
    { SWIG_prefix "connect_pin_cmd", (swig_wrapper_func) _wrap_connect_pin_cmd, NULL},
    { SWIG_prefix "disconnect_pin_cmd", (swig_wrapper_func) _wrap_disconnect_pin_cmd, NULL},
    { SWIG_prefix "network_changed", (swig_wrapper_func) _wrap_network_changed, NULL},
    { SWIG_prefix "read_sdf_file", (swig_wrapper_func) _wrap_read_sdf_file, NULL},
    { SWIG_prefix "report_annotated_delay_cmd", (swig_wrapper_func) _wrap_report_annotated_delay_cmd, NULL},
    { SWIG_prefix "report_annotated_check_cmd", (swig_wrapper_func) _wrap_report_annotated_check_cmd, NULL},
    { SWIG_prefix "write_sdf_cmd", (swig_wrapper_func) _wrap_write_sdf_cmd, NULL},
    { SWIG_prefix "delay_calc_names", (swig_wrapper_func) _wrap_delay_calc_names, NULL},
    { SWIG_prefix "is_delay_calc_name", (swig_wrapper_func) _wrap_is_delay_calc_name, NULL},
    { SWIG_prefix "set_delay_calculator_cmd", (swig_wrapper_func) _wrap_set_delay_calculator_cmd, NULL},
    { SWIG_prefix "set_delay_calc_incremental_tolerance", (swig_wrapper_func) _wrap_set_delay_calc_incremental_tolerance, NULL},
    { SWIG_prefix "read_spef_cmd", (swig_wrapper_func) _wrap_read_spef_cmd, NULL},
    { SWIG_prefix "find_pi_elmore", (swig_wrapper_func) _wrap_find_pi_elmore, NULL},
    { SWIG_prefix "find_elmore", (swig_wrapper_func) _wrap_find_elmore, NULL},
    { SWIG_prefix "set_pi_model_cmd", (swig_wrapper_func) _wrap_set_pi_model_cmd, NULL},
    { SWIG_prefix "set_elmore_cmd", (swig_wrapper_func) _wrap_set_elmore_cmd, NULL},
    { SWIG_prefix "new_dbNetVector", (swig_wrapper_func) _wrap_new_dbNetVector, NULL},
    { SWIG_prefix "dbNetVector_size", (swig_wrapper_func) _wrap_dbNetVector_size, NULL},
    { SWIG_prefix "dbNetVector_empty", (swig_wrapper_func) _wrap_dbNetVector_empty, NULL},
    { SWIG_prefix "dbNetVector_clear", (swig_wrapper_func) _wrap_dbNetVector_clear, NULL},
    { SWIG_prefix "dbNetVector_push", (swig_wrapper_func) _wrap_dbNetVector_push, NULL},
    { SWIG_prefix "dbNetVector_pop", (swig_wrapper_func) _wrap_dbNetVector_pop, NULL},
    { SWIG_prefix "dbNetVector_get", (swig_wrapper_func) _wrap_dbNetVector_get, NULL},
    { SWIG_prefix "dbNetVector_set", (swig_wrapper_func) _wrap_dbNetVector_set, NULL},
    { SWIG_prefix "delete_dbNetVector", (swig_wrapper_func) _wrap_delete_dbNetVector, NULL},
    { SWIG_prefix "dbNetVector", (swig_wrapper_func) SWIG_ObjectConstructor, (ClientData)&_wrap_class_std_vector_Sl_dbNet_Sm__Sg_},
    { SWIG_prefix "make_block_sta", (swig_wrapper_func) _wrap_make_block_sta, NULL},
    { SWIG_prefix "find_logic_constants", (swig_wrapper_func) _wrap_find_logic_constants, NULL},
    { SWIG_prefix "highlight_path_cmd", (swig_wrapper_func) _wrap_highlight_path_cmd, NULL},
    { SWIG_prefix "find_all_clk_nets", (swig_wrapper_func) _wrap_find_all_clk_nets, NULL},
    { SWIG_prefix "sta_to_db_inst", (swig_wrapper_func) _wrap_sta_to_db_inst, NULL},
    { SWIG_prefix "sta_to_db_port", (swig_wrapper_func) _wrap_sta_to_db_port, NULL},
    { SWIG_prefix "sta_to_db_pin", (swig_wrapper_func) _wrap_sta_to_db_pin, NULL},
    { SWIG_prefix "sta_to_db_net", (swig_wrapper_func) _wrap_sta_to_db_net, NULL},
    { SWIG_prefix "sta_to_db_master", (swig_wrapper_func) _wrap_sta_to_db_master, NULL},
    { SWIG_prefix "db_network_defined", (swig_wrapper_func) _wrap_db_network_defined, NULL},
    {0, 0, 0}
};

static swig_var_info swig_variables[] = {
    { SWIG_prefix "float_inf", 0, (swig_variable_func) _wrap_float_inf_get,(swig_variable_func) _wrap_float_inf_set},
    { SWIG_prefix "group_count_max", 0, (swig_variable_func) _wrap_group_count_max_get,(swig_variable_func) _wrap_group_count_max_set},
    {0,0,0,0}
};

static swig_const_info swig_constants[] = {
    {0,0,0,0,0,0}
};

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static void *_p_odb__dbBoolPropertyTo_p_odb__dbProperty(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((odb::dbProperty *)  ((odb::dbBoolProperty *) x));
}
static void *_p_odb__dbStringPropertyTo_p_odb__dbProperty(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((odb::dbProperty *)  ((odb::dbStringProperty *) x));
}
static void *_p_odb__dbIntPropertyTo_p_odb__dbProperty(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((odb::dbProperty *)  ((odb::dbIntProperty *) x));
}
static void *_p_odb__dbDoublePropertyTo_p_odb__dbProperty(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((odb::dbProperty *)  ((odb::dbDoubleProperty *) x));
}
static void *_p_odb__dbSBoxTo_p_odb__dbBox(void *x, int *SWIGUNUSEDPARM(newmemory)) {
    return (void *)((odb::dbBox *)  ((odb::dbSBox *) x));
}
static swig_type_info _swigt__p_Cell = {"_p_Cell", "Cell *", 0, 0, (void*)&_wrap_class_Cell, 0};
static swig_type_info _swigt__p_CellPortIterator = {"_p_CellPortIterator", "CellPortIterator *", 0, 0, (void*)&_wrap_class_CellPortIterator, 0};
static swig_type_info _swigt__p_Clock = {"_p_Clock", "Clock *", 0, 0, (void*)&_wrap_class_Clock, 0};
static swig_type_info _swigt__p_ClockEdge = {"_p_ClockEdge", "ClockEdge *", 0, 0, (void*)&_wrap_class_ClockEdge, 0};
static swig_type_info _swigt__p_ClockGroups = {"_p_ClockGroups", "ClockGroups *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ClockIterator = {"_p_ClockIterator", "ClockIterator *", 0, 0, (void*)&_wrap_class_ClockIterator, 0};
static swig_type_info _swigt__p_ClockSet = {"_p_ClockSet", "ClockSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Corner = {"_p_Corner", "Corner *", 0, 0, (void*)&_wrap_class_Corner, 0};
static swig_type_info _swigt__p_Crpr = {"_p_Crpr", "Crpr *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EarlyLate = {"_p_EarlyLate", "EarlyLate *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_EarlyLateAll = {"_p_EarlyLateAll", "EarlyLateAll *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Edge = {"_p_Edge", "Edge *", 0, 0, (void*)&_wrap_class_Edge, 0};
static swig_type_info _swigt__p_EdgeSeq = {"_p_EdgeSeq", "EdgeSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ExceptionFrom = {"_p_ExceptionFrom", "ExceptionFrom *", 0, 0, (void*)&_wrap_class_ExceptionFrom, 0};
static swig_type_info _swigt__p_ExceptionThru = {"_p_ExceptionThru", "ExceptionThru *", 0, 0, (void*)&_wrap_class_ExceptionThru, 0};
static swig_type_info _swigt__p_ExceptionThruSeq = {"_p_ExceptionThruSeq", "ExceptionThruSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ExceptionTo = {"_p_ExceptionTo", "ExceptionTo *", 0, 0, (void*)&_wrap_class_ExceptionTo, 0};
static swig_type_info _swigt__p_FloatSeq = {"_p_FloatSeq", "FloatSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Instance = {"_p_Instance", "Instance *", 0, 0, (void*)&_wrap_class_Instance, 0};
static swig_type_info _swigt__p_InstanceChildIterator = {"_p_InstanceChildIterator", "InstanceChildIterator *", 0, 0, (void*)&_wrap_class_InstanceChildIterator, 0};
static swig_type_info _swigt__p_InstanceNetIterator = {"_p_InstanceNetIterator", "InstanceNetIterator *", 0, 0, (void*)&_wrap_class_InstanceNetIterator, 0};
static swig_type_info _swigt__p_InstancePinIterator = {"_p_InstancePinIterator", "InstancePinIterator *", 0, 0, (void*)&_wrap_class_InstancePinIterator, 0};
static swig_type_info _swigt__p_InstanceSeq = {"_p_InstanceSeq", "InstanceSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_InstanceSet = {"_p_InstanceSet", "InstanceSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_IntSeq = {"_p_IntSeq", "IntSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_LeafInstanceIterator = {"_p_LeafInstanceIterator", "LeafInstanceIterator *", 0, 0, (void*)&_wrap_class_LeafInstanceIterator, 0};
static swig_type_info _swigt__p_LibertyCell = {"_p_LibertyCell", "LibertyCell *", 0, 0, (void*)&_wrap_class_LibertyCell, 0};
static swig_type_info _swigt__p_LibertyCellPortIterator = {"_p_LibertyCellPortIterator", "LibertyCellPortIterator *", 0, 0, (void*)&_wrap_class_LibertyCellPortIterator, 0};
static swig_type_info _swigt__p_LibertyCellTimingArcSetIterator = {"_p_LibertyCellTimingArcSetIterator", "LibertyCellTimingArcSetIterator *", 0, 0, (void*)&_wrap_class_LibertyCellTimingArcSetIterator, 0};
static swig_type_info _swigt__p_LibertyLibrary = {"_p_LibertyLibrary", "LibertyLibrary *", 0, 0, (void*)&_wrap_class_LibertyLibrary, 0};
static swig_type_info _swigt__p_LibertyLibraryIterator = {"_p_LibertyLibraryIterator", "LibertyLibraryIterator *", 0, 0, (void*)&_wrap_class_LibertyLibraryIterator, 0};
static swig_type_info _swigt__p_LibertyPort = {"_p_LibertyPort", "LibertyPort *", 0, 0, (void*)&_wrap_class_LibertyPort, 0};
static swig_type_info _swigt__p_LibertyPortMemberIterator = {"_p_LibertyPortMemberIterator", "LibertyPortMemberIterator *", 0, 0, (void*)&_wrap_class_LibertyPortMemberIterator, 0};
static swig_type_info _swigt__p_Library = {"_p_Library", "Library *", 0, 0, (void*)&_wrap_class_Library, 0};
static swig_type_info _swigt__p_LibraryIterator = {"_p_LibraryIterator", "LibraryIterator *", 0, 0, (void*)&_wrap_class_LibraryIterator, 0};
static swig_type_info _swigt__p_LogicValue = {"_p_LogicValue", "LogicValue *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MaxSkewCheck = {"_p_MaxSkewCheck", "MaxSkewCheck *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MaxSkewCheckSeq = {"_p_MaxSkewCheckSeq", "MaxSkewCheckSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinMax = {"_p_MinMax", "MinMax *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinMaxAll = {"_p_MinMaxAll", "MinMaxAll *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinMaxAllNull = {"_p_MinMaxAllNull", "MinMaxAllNull *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinPeriodCheck = {"_p_MinPeriodCheck", "MinPeriodCheck *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinPeriodCheckSeq = {"_p_MinPeriodCheckSeq", "MinPeriodCheckSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_MinPulseWidthCheck = {"_p_MinPulseWidthCheck", "MinPulseWidthCheck *", 0, 0, (void*)&_wrap_class_MinPulseWidthCheck, 0};
static swig_type_info _swigt__p_MinPulseWidthCheckSeq = {"_p_MinPulseWidthCheckSeq", "MinPulseWidthCheckSeq *", 0, 0, (void*)&_wrap_class_MinPulseWidthCheckSeq, 0};
static swig_type_info _swigt__p_MinPulseWidthCheckSeqIterator = {"_p_MinPulseWidthCheckSeqIterator", "MinPulseWidthCheckSeqIterator *", 0, 0, (void*)&_wrap_class_MinPulseWidthCheckSeqIterator, 0};
static swig_type_info _swigt__p_Net = {"_p_Net", "Net *", 0, 0, (void*)&_wrap_class_Net, 0};
static swig_type_info _swigt__p_NetConnectedPinIterator = {"_p_NetConnectedPinIterator", "NetConnectedPinIterator *", 0, 0, (void*)&_wrap_class_NetConnectedPinIterator, 0};
static swig_type_info _swigt__p_NetPinIterator = {"_p_NetPinIterator", "NetPinIterator *", 0, 0, (void*)&_wrap_class_NetPinIterator, 0};
static swig_type_info _swigt__p_NetSet = {"_p_NetSet", "NetSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_NetTermIterator = {"_p_NetTermIterator", "NetTermIterator *", 0, 0, (void*)&_wrap_class_NetTermIterator, 0};
static swig_type_info _swigt__p_OperatingConditions = {"_p_OperatingConditions", "OperatingConditions *", 0, 0, (void*)&_wrap_class_OperatingConditions, 0};
static swig_type_info _swigt__p_Path = {"_p_Path", "Path *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PathClkOrData = {"_p_PathClkOrData", "PathClkOrData *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PathEnd = {"_p_PathEnd", "PathEnd *", 0, 0, (void*)&_wrap_class_PathEnd, 0};
static swig_type_info _swigt__p_PathGroupNameSet = {"_p_PathGroupNameSet", "PathGroupNameSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PathRef = {"_p_PathRef", "PathRef *", 0, 0, (void*)&_wrap_class_PathRef, 0};
static swig_type_info _swigt__p_Pin = {"_p_Pin", "Pin *", 0, 0, (void*)&_wrap_class_Pin, 0};
static swig_type_info _swigt__p_PinConnectedPinIterator = {"_p_PinConnectedPinIterator", "PinConnectedPinIterator *", 0, 0, (void*)&_wrap_class_PinConnectedPinIterator, 0};
static swig_type_info _swigt__p_PinSeq = {"_p_PinSeq", "PinSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_PinSet = {"_p_PinSet", "PinSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Polygon90 = {"_p_Polygon90", "Polygon90 *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Polygon90Set = {"_p_Polygon90Set", "Polygon90Set *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Port = {"_p_Port", "Port *", 0, 0, (void*)&_wrap_class_Port, 0};
static swig_type_info _swigt__p_PortMemberIterator = {"_p_PortMemberIterator", "PortMemberIterator *", 0, 0, (void*)&_wrap_class_PortMemberIterator, 0};
static swig_type_info _swigt__p_PortSeq = {"_p_PortSeq", "PortSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ReducedParasiticType = {"_p_ReducedParasiticType", "ReducedParasiticType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_ReportPathFormat = {"_p_ReportPathFormat", "ReportPathFormat *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RiseFall = {"_p_RiseFall", "RiseFall *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_RiseFallBoth = {"_p_RiseFallBoth", "RiseFallBoth *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SetupHold = {"_p_SetupHold", "SetupHold *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SetupHoldAll = {"_p_SetupHoldAll", "SetupHoldAll *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_SlowDrvrIterator = {"_p_SlowDrvrIterator", "SlowDrvrIterator *", 0, 0, (void*)&_wrap_class_SlowDrvrIterator, 0};
static swig_type_info _swigt__p_StringSeq = {"_p_StringSeq", "StringSeq *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_StringSet = {"_p_StringSet", "StringSet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Tcl_Interp = {"_p_Tcl_Interp", "Tcl_Interp *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Term = {"_p_Term", "Term *", 0, 0, (void*)&_wrap_class_Term, 0};
static swig_type_info _swigt__p_TimingArc = {"_p_TimingArc", "TimingArc *", 0, 0, (void*)&_wrap_class_TimingArc, 0};
static swig_type_info _swigt__p_TimingArcSet = {"_p_TimingArcSet", "TimingArcSet *", 0, 0, (void*)&_wrap_class_TimingArcSet, 0};
static swig_type_info _swigt__p_TimingArcSetArcIterator = {"_p_TimingArcSetArcIterator", "TimingArcSetArcIterator *", 0, 0, (void*)&_wrap_class_TimingArcSetArcIterator, 0};
static swig_type_info _swigt__p_TimingDerateCellType = {"_p_TimingDerateCellType", "TimingDerateCellType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TimingDerateType = {"_p_TimingDerateType", "TimingDerateType *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_TimingRole = {"_p_TimingRole", "TimingRole *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_Transition = {"_p_Transition", "Transition *", 0, 0, (void*)&_wrap_class_Transition, 0};
static swig_type_info _swigt__p_Vertex = {"_p_Vertex", "Vertex *", 0, 0, (void*)&_wrap_class_Vertex, 0};
static swig_type_info _swigt__p_VertexInEdgeIterator = {"_p_VertexInEdgeIterator", "VertexInEdgeIterator *", 0, 0, (void*)&_wrap_class_VertexInEdgeIterator, 0};
static swig_type_info _swigt__p_VertexIterator = {"_p_VertexIterator", "VertexIterator *", 0, 0, (void*)&_wrap_class_VertexIterator, 0};
static swig_type_info _swigt__p_VertexOutEdgeIterator = {"_p_VertexOutEdgeIterator", "VertexOutEdgeIterator *", 0, 0, (void*)&_wrap_class_VertexOutEdgeIterator, 0};
static swig_type_info _swigt__p_VertexPathIterator = {"_p_VertexPathIterator", "VertexPathIterator *", 0, 0, (void*)&_wrap_class_VertexPathIterator, 0};
static swig_type_info _swigt__p_Wireload = {"_p_Wireload", "Wireload *", 0, 0, (void*)&_wrap_class_Wireload, 0};
static swig_type_info _swigt__p_WireloadSelection = {"_p_WireloadSelection", "WireloadSelection *", 0, 0, (void*)&_wrap_class_WireloadSelection, 0};
static swig_type_info _swigt__p_char = {"_p_char", "char *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_dbNet = {"_p_dbNet", "dbNet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_difference_type = {"_p_difference_type", "difference_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_edge_iterator = {"_p_edge_iterator", "edge_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_node_iterator = {"_p_node_iterator", "node_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_object_iterator = {"_p_object_iterator", "object_iterator *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__Point = {"_p_odb__Point", "odb::Point *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__Rect = {"_p_odb__Rect", "odb::Rect *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbAccessPoint = {"_p_odb__dbAccessPoint", "odb::dbAccessPoint *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbBPin = {"_p_odb__dbBPin", "odb::dbBPin *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbBTerm = {"_p_odb__dbBTerm", "odb::dbBTerm *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbBlock = {"_p_odb__dbBlock", "odb::dbBlock *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbBlockage = {"_p_odb__dbBlockage", "odb::dbBlockage *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbBox = {"_p_odb__dbBox", "odb::dbBox *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbCCSeg = {"_p_odb__dbCCSeg", "odb::dbCCSeg *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbCapNode = {"_p_odb__dbCapNode", "odb::dbCapNode *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbChip = {"_p_odb__dbChip", "odb::dbChip *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbGroup = {"_p_odb__dbGroup", "odb::dbGroup *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbITerm = {"_p_odb__dbITerm", "odb::dbITerm *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbInst = {"_p_odb__dbInst", "odb::dbInst *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbLib = {"_p_odb__dbLib", "odb::dbLib *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbMPin = {"_p_odb__dbMPin", "odb::dbMPin *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbMTerm = {"_p_odb__dbMTerm", "odb::dbMTerm *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbMaster = {"_p_odb__dbMaster", "odb::dbMaster *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbModInst = {"_p_odb__dbModInst", "odb::dbModInst *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbModule = {"_p_odb__dbModule", "odb::dbModule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbNet = {"_p_odb__dbNet", "odb::dbNet *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbObstruction = {"_p_odb__dbObstruction", "odb::dbObstruction *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbProperty = {"_p_odb__dbProperty", "odb::dbProperty *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbBoolProperty = {"_p_odb__dbBoolProperty", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_odb__dbStringProperty = {"_p_odb__dbStringProperty", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_odb__dbIntProperty = {"_p_odb__dbIntProperty", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_odb__dbDoubleProperty = {"_p_odb__dbDoubleProperty", 0, 0, 0, 0, 0};
static swig_type_info _swigt__p_odb__dbRSeg = {"_p_odb__dbRSeg", "odb::dbRSeg *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbRegion = {"_p_odb__dbRegion", "odb::dbRegion *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbRow = {"_p_odb__dbRow", "odb::dbRow *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbSBox = {"_p_odb__dbSBox", "odb::dbSBox *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbSWire = {"_p_odb__dbSWire", "odb::dbSWire *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbSite = {"_p_odb__dbSite", "odb::dbSite *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTarget = {"_p_odb__dbTarget", "odb::dbTarget *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechLayer = {"_p_odb__dbTechLayer", "odb::dbTechLayer *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechLayerCornerSpacingRule = {"_p_odb__dbTechLayerCornerSpacingRule", "odb::dbTechLayerCornerSpacingRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechLayerCutClassRule = {"_p_odb__dbTechLayerCutClassRule", "odb::dbTechLayerCutClassRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechLayerCutSpacingRule = {"_p_odb__dbTechLayerCutSpacingRule", "odb::dbTechLayerCutSpacingRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechLayerCutSpacingTableDefRule = {"_p_odb__dbTechLayerCutSpacingTableDefRule", "odb::dbTechLayerCutSpacingTableDefRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechLayerCutSpacingTableOrthRule = {"_p_odb__dbTechLayerCutSpacingTableOrthRule", "odb::dbTechLayerCutSpacingTableOrthRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechLayerMinStepRule = {"_p_odb__dbTechLayerMinStepRule", "odb::dbTechLayerMinStepRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechLayerSpacingRule = {"_p_odb__dbTechLayerSpacingRule", "odb::dbTechLayerSpacingRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechLayerSpacingTablePrlRule = {"_p_odb__dbTechLayerSpacingTablePrlRule", "odb::dbTechLayerSpacingTablePrlRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechMinCutRule = {"_p_odb__dbTechMinCutRule", "odb::dbTechMinCutRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechMinEncRule = {"_p_odb__dbTechMinEncRule", "odb::dbTechMinEncRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechNonDefaultRule = {"_p_odb__dbTechNonDefaultRule", "odb::dbTechNonDefaultRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechV55InfluenceEntry = {"_p_odb__dbTechV55InfluenceEntry", "odb::dbTechV55InfluenceEntry *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechVia = {"_p_odb__dbTechVia", "odb::dbTechVia *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechViaGenerateRule = {"_p_odb__dbTechViaGenerateRule", "odb::dbTechViaGenerateRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTechViaRule = {"_p_odb__dbTechViaRule", "odb::dbTechViaRule *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbTrackGrid = {"_p_odb__dbTrackGrid", "odb::dbTrackGrid *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbVia = {"_p_odb__dbVia", "odb::dbVia *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_odb__dbWire = {"_p_odb__dbWire", "odb::dbWire *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_dbNet = {"_p_p_dbNet", "dbNet **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_p_std__vectorT_dbNet_p_t = {"_p_p_std__vectorT_dbNet_p_t", "std::vector< dbNet * > **", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_size_type = {"_p_size_type", "size_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_sta__Sta = {"_p_sta__Sta", "sta::Sta *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__out_of_range = {"_p_std__out_of_range", "std::out_of_range *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__p_std__vectorT_dbNet_p_t = {"_p_std__vectorT_dbNet_p_t", "std::vector< dbNet * > *", 0, 0, (void*)&_wrap_class_std_vector_Sl_dbNet_Sm__Sg_, 0};
static swig_type_info _swigt__p_value_type = {"_p_value_type", "value_type *", 0, 0, (void*)0, 0};
static swig_type_info _swigt__std__ptrdiff_t = {"_std__ptrdiff_t", "std::ptrdiff_t", 0, 0, (void*)0, 0};
static swig_type_info _swigt__std__size_t = {"_std__size_t", "std::size_t", 0, 0, (void*)0, 0};

static swig_type_info *swig_type_initial[] = {
  &_swigt__p_Cell,
  &_swigt__p_CellPortIterator,
  &_swigt__p_Clock,
  &_swigt__p_ClockEdge,
  &_swigt__p_ClockGroups,
  &_swigt__p_ClockIterator,
  &_swigt__p_ClockSet,
  &_swigt__p_Corner,
  &_swigt__p_Crpr,
  &_swigt__p_EarlyLate,
  &_swigt__p_EarlyLateAll,
  &_swigt__p_Edge,
  &_swigt__p_EdgeSeq,
  &_swigt__p_ExceptionFrom,
  &_swigt__p_ExceptionThru,
  &_swigt__p_ExceptionThruSeq,
  &_swigt__p_ExceptionTo,
  &_swigt__p_FloatSeq,
  &_swigt__p_Instance,
  &_swigt__p_InstanceChildIterator,
  &_swigt__p_InstanceNetIterator,
  &_swigt__p_InstancePinIterator,
  &_swigt__p_InstanceSeq,
  &_swigt__p_InstanceSet,
  &_swigt__p_IntSeq,
  &_swigt__p_LeafInstanceIterator,
  &_swigt__p_LibertyCell,
  &_swigt__p_LibertyCellPortIterator,
  &_swigt__p_LibertyCellTimingArcSetIterator,
  &_swigt__p_LibertyLibrary,
  &_swigt__p_LibertyLibraryIterator,
  &_swigt__p_LibertyPort,
  &_swigt__p_LibertyPortMemberIterator,
  &_swigt__p_Library,
  &_swigt__p_LibraryIterator,
  &_swigt__p_LogicValue,
  &_swigt__p_MaxSkewCheck,
  &_swigt__p_MaxSkewCheckSeq,
  &_swigt__p_MinMax,
  &_swigt__p_MinMaxAll,
  &_swigt__p_MinMaxAllNull,
  &_swigt__p_MinPeriodCheck,
  &_swigt__p_MinPeriodCheckSeq,
  &_swigt__p_MinPulseWidthCheck,
  &_swigt__p_MinPulseWidthCheckSeq,
  &_swigt__p_MinPulseWidthCheckSeqIterator,
  &_swigt__p_Net,
  &_swigt__p_NetConnectedPinIterator,
  &_swigt__p_NetPinIterator,
  &_swigt__p_NetSet,
  &_swigt__p_NetTermIterator,
  &_swigt__p_OperatingConditions,
  &_swigt__p_Path,
  &_swigt__p_PathClkOrData,
  &_swigt__p_PathEnd,
  &_swigt__p_PathGroupNameSet,
  &_swigt__p_PathRef,
  &_swigt__p_Pin,
  &_swigt__p_PinConnectedPinIterator,
  &_swigt__p_PinSeq,
  &_swigt__p_PinSet,
  &_swigt__p_Polygon90,
  &_swigt__p_Polygon90Set,
  &_swigt__p_Port,
  &_swigt__p_PortMemberIterator,
  &_swigt__p_PortSeq,
  &_swigt__p_ReducedParasiticType,
  &_swigt__p_ReportPathFormat,
  &_swigt__p_RiseFall,
  &_swigt__p_RiseFallBoth,
  &_swigt__p_SetupHold,
  &_swigt__p_SetupHoldAll,
  &_swigt__p_SlowDrvrIterator,
  &_swigt__p_StringSeq,
  &_swigt__p_StringSet,
  &_swigt__p_Tcl_Interp,
  &_swigt__p_Term,
  &_swigt__p_TimingArc,
  &_swigt__p_TimingArcSet,
  &_swigt__p_TimingArcSetArcIterator,
  &_swigt__p_TimingDerateCellType,
  &_swigt__p_TimingDerateType,
  &_swigt__p_TimingRole,
  &_swigt__p_Transition,
  &_swigt__p_Vertex,
  &_swigt__p_VertexInEdgeIterator,
  &_swigt__p_VertexIterator,
  &_swigt__p_VertexOutEdgeIterator,
  &_swigt__p_VertexPathIterator,
  &_swigt__p_Wireload,
  &_swigt__p_WireloadSelection,
  &_swigt__p_char,
  &_swigt__p_dbNet,
  &_swigt__p_difference_type,
  &_swigt__p_edge_iterator,
  &_swigt__p_node_iterator,
  &_swigt__p_object_iterator,
  &_swigt__p_odb__Point,
  &_swigt__p_odb__Rect,
  &_swigt__p_odb__dbAccessPoint,
  &_swigt__p_odb__dbBPin,
  &_swigt__p_odb__dbBTerm,
  &_swigt__p_odb__dbBlock,
  &_swigt__p_odb__dbBlockage,
  &_swigt__p_odb__dbBoolProperty,
  &_swigt__p_odb__dbBox,
  &_swigt__p_odb__dbCCSeg,
  &_swigt__p_odb__dbCapNode,
  &_swigt__p_odb__dbChip,
  &_swigt__p_odb__dbDoubleProperty,
  &_swigt__p_odb__dbGroup,
  &_swigt__p_odb__dbITerm,
  &_swigt__p_odb__dbInst,
  &_swigt__p_odb__dbIntProperty,
  &_swigt__p_odb__dbLib,
  &_swigt__p_odb__dbMPin,
  &_swigt__p_odb__dbMTerm,
  &_swigt__p_odb__dbMaster,
  &_swigt__p_odb__dbModInst,
  &_swigt__p_odb__dbModule,
  &_swigt__p_odb__dbNet,
  &_swigt__p_odb__dbObstruction,
  &_swigt__p_odb__dbProperty,
  &_swigt__p_odb__dbRSeg,
  &_swigt__p_odb__dbRegion,
  &_swigt__p_odb__dbRow,
  &_swigt__p_odb__dbSBox,
  &_swigt__p_odb__dbSWire,
  &_swigt__p_odb__dbSite,
  &_swigt__p_odb__dbStringProperty,
  &_swigt__p_odb__dbTarget,
  &_swigt__p_odb__dbTechLayer,
  &_swigt__p_odb__dbTechLayerCornerSpacingRule,
  &_swigt__p_odb__dbTechLayerCutClassRule,
  &_swigt__p_odb__dbTechLayerCutSpacingRule,
  &_swigt__p_odb__dbTechLayerCutSpacingTableDefRule,
  &_swigt__p_odb__dbTechLayerCutSpacingTableOrthRule,
  &_swigt__p_odb__dbTechLayerMinStepRule,
  &_swigt__p_odb__dbTechLayerSpacingRule,
  &_swigt__p_odb__dbTechLayerSpacingTablePrlRule,
  &_swigt__p_odb__dbTechMinCutRule,
  &_swigt__p_odb__dbTechMinEncRule,
  &_swigt__p_odb__dbTechNonDefaultRule,
  &_swigt__p_odb__dbTechV55InfluenceEntry,
  &_swigt__p_odb__dbTechVia,
  &_swigt__p_odb__dbTechViaGenerateRule,
  &_swigt__p_odb__dbTechViaRule,
  &_swigt__p_odb__dbTrackGrid,
  &_swigt__p_odb__dbVia,
  &_swigt__p_odb__dbWire,
  &_swigt__p_p_dbNet,
  &_swigt__p_p_std__vectorT_dbNet_p_t,
  &_swigt__p_size_type,
  &_swigt__p_sta__Sta,
  &_swigt__p_std__out_of_range,
  &_swigt__p_std__vectorT_dbNet_p_t,
  &_swigt__p_value_type,
  &_swigt__std__ptrdiff_t,
  &_swigt__std__size_t,
};

static swig_cast_info _swigc__p_Cell[] = {  {&_swigt__p_Cell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_CellPortIterator[] = {  {&_swigt__p_CellPortIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Clock[] = {  {&_swigt__p_Clock, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ClockEdge[] = {  {&_swigt__p_ClockEdge, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ClockGroups[] = {  {&_swigt__p_ClockGroups, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ClockIterator[] = {  {&_swigt__p_ClockIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ClockSet[] = {  {&_swigt__p_ClockSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Corner[] = {  {&_swigt__p_Corner, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Crpr[] = {  {&_swigt__p_Crpr, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EarlyLate[] = {  {&_swigt__p_EarlyLate, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EarlyLateAll[] = {  {&_swigt__p_EarlyLateAll, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Edge[] = {  {&_swigt__p_Edge, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_EdgeSeq[] = {  {&_swigt__p_EdgeSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExceptionFrom[] = {  {&_swigt__p_ExceptionFrom, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExceptionThru[] = {  {&_swigt__p_ExceptionThru, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExceptionThruSeq[] = {  {&_swigt__p_ExceptionThruSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ExceptionTo[] = {  {&_swigt__p_ExceptionTo, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_FloatSeq[] = {  {&_swigt__p_FloatSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Instance[] = {  {&_swigt__p_Instance, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceChildIterator[] = {  {&_swigt__p_InstanceChildIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceNetIterator[] = {  {&_swigt__p_InstanceNetIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstancePinIterator[] = {  {&_swigt__p_InstancePinIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceSeq[] = {  {&_swigt__p_InstanceSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_InstanceSet[] = {  {&_swigt__p_InstanceSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_IntSeq[] = {  {&_swigt__p_IntSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LeafInstanceIterator[] = {  {&_swigt__p_LeafInstanceIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyCell[] = {  {&_swigt__p_LibertyCell, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyCellPortIterator[] = {  {&_swigt__p_LibertyCellPortIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyCellTimingArcSetIterator[] = {  {&_swigt__p_LibertyCellTimingArcSetIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyLibrary[] = {  {&_swigt__p_LibertyLibrary, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyLibraryIterator[] = {  {&_swigt__p_LibertyLibraryIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyPort[] = {  {&_swigt__p_LibertyPort, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibertyPortMemberIterator[] = {  {&_swigt__p_LibertyPortMemberIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Library[] = {  {&_swigt__p_Library, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LibraryIterator[] = {  {&_swigt__p_LibraryIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_LogicValue[] = {  {&_swigt__p_LogicValue, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MaxSkewCheck[] = {  {&_swigt__p_MaxSkewCheck, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MaxSkewCheckSeq[] = {  {&_swigt__p_MaxSkewCheckSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinMax[] = {  {&_swigt__p_MinMax, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinMaxAll[] = {  {&_swigt__p_MinMaxAll, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinMaxAllNull[] = {  {&_swigt__p_MinMaxAllNull, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPeriodCheck[] = {  {&_swigt__p_MinPeriodCheck, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPeriodCheckSeq[] = {  {&_swigt__p_MinPeriodCheckSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPulseWidthCheck[] = {  {&_swigt__p_MinPulseWidthCheck, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPulseWidthCheckSeq[] = {  {&_swigt__p_MinPulseWidthCheckSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_MinPulseWidthCheckSeqIterator[] = {  {&_swigt__p_MinPulseWidthCheckSeqIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Net[] = {  {&_swigt__p_Net, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NetConnectedPinIterator[] = {  {&_swigt__p_NetConnectedPinIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NetPinIterator[] = {  {&_swigt__p_NetPinIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NetSet[] = {  {&_swigt__p_NetSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_NetTermIterator[] = {  {&_swigt__p_NetTermIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_OperatingConditions[] = {  {&_swigt__p_OperatingConditions, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Path[] = {  {&_swigt__p_Path, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathClkOrData[] = {  {&_swigt__p_PathClkOrData, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathEnd[] = {  {&_swigt__p_PathEnd, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathGroupNameSet[] = {  {&_swigt__p_PathGroupNameSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PathRef[] = {  {&_swigt__p_PathRef, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Pin[] = {  {&_swigt__p_Pin, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PinConnectedPinIterator[] = {  {&_swigt__p_PinConnectedPinIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PinSeq[] = {  {&_swigt__p_PinSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PinSet[] = {  {&_swigt__p_PinSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Polygon90[] = {  {&_swigt__p_Polygon90, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Polygon90Set[] = {  {&_swigt__p_Polygon90Set, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Port[] = {  {&_swigt__p_Port, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PortMemberIterator[] = {  {&_swigt__p_PortMemberIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_PortSeq[] = {  {&_swigt__p_PortSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ReducedParasiticType[] = {  {&_swigt__p_ReducedParasiticType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_ReportPathFormat[] = {  {&_swigt__p_ReportPathFormat, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RiseFall[] = {  {&_swigt__p_RiseFall, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_RiseFallBoth[] = {  {&_swigt__p_RiseFallBoth, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SetupHold[] = {  {&_swigt__p_SetupHold, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SetupHoldAll[] = {  {&_swigt__p_SetupHoldAll, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_SlowDrvrIterator[] = {  {&_swigt__p_SlowDrvrIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StringSeq[] = {  {&_swigt__p_StringSeq, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_StringSet[] = {  {&_swigt__p_StringSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Tcl_Interp[] = {  {&_swigt__p_Tcl_Interp, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Term[] = {  {&_swigt__p_Term, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingArc[] = {  {&_swigt__p_TimingArc, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingArcSet[] = {  {&_swigt__p_TimingArcSet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingArcSetArcIterator[] = {  {&_swigt__p_TimingArcSetArcIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingDerateCellType[] = {  {&_swigt__p_TimingDerateCellType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingDerateType[] = {  {&_swigt__p_TimingDerateType, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_TimingRole[] = {  {&_swigt__p_TimingRole, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Transition[] = {  {&_swigt__p_Transition, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Vertex[] = {  {&_swigt__p_Vertex, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexInEdgeIterator[] = {  {&_swigt__p_VertexInEdgeIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexIterator[] = {  {&_swigt__p_VertexIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexOutEdgeIterator[] = {  {&_swigt__p_VertexOutEdgeIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_VertexPathIterator[] = {  {&_swigt__p_VertexPathIterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_Wireload[] = {  {&_swigt__p_Wireload, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_WireloadSelection[] = {  {&_swigt__p_WireloadSelection, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_char[] = {  {&_swigt__p_char, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_dbNet[] = {  {&_swigt__p_dbNet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_difference_type[] = {  {&_swigt__p_difference_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_edge_iterator[] = {  {&_swigt__p_edge_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_node_iterator[] = {  {&_swigt__p_node_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_object_iterator[] = {  {&_swigt__p_object_iterator, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__Point[] = {  {&_swigt__p_odb__Point, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__Rect[] = {  {&_swigt__p_odb__Rect, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbAccessPoint[] = {  {&_swigt__p_odb__dbAccessPoint, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbBPin[] = {  {&_swigt__p_odb__dbBPin, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbBTerm[] = {  {&_swigt__p_odb__dbBTerm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbBlock[] = {  {&_swigt__p_odb__dbBlock, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbBlockage[] = {  {&_swigt__p_odb__dbBlockage, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbBox[] = {  {&_swigt__p_odb__dbBox, 0, 0, 0},  {&_swigt__p_odb__dbSBox, _p_odb__dbSBoxTo_p_odb__dbBox, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbCCSeg[] = {  {&_swigt__p_odb__dbCCSeg, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbCapNode[] = {  {&_swigt__p_odb__dbCapNode, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbChip[] = {  {&_swigt__p_odb__dbChip, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbGroup[] = {  {&_swigt__p_odb__dbGroup, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbITerm[] = {  {&_swigt__p_odb__dbITerm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbInst[] = {  {&_swigt__p_odb__dbInst, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbLib[] = {  {&_swigt__p_odb__dbLib, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbMPin[] = {  {&_swigt__p_odb__dbMPin, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbMTerm[] = {  {&_swigt__p_odb__dbMTerm, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbMaster[] = {  {&_swigt__p_odb__dbMaster, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbModInst[] = {  {&_swigt__p_odb__dbModInst, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbModule[] = {  {&_swigt__p_odb__dbModule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbNet[] = {  {&_swigt__p_odb__dbNet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbObstruction[] = {  {&_swigt__p_odb__dbObstruction, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbBoolProperty[] = {{&_swigt__p_odb__dbBoolProperty, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbStringProperty[] = {{&_swigt__p_odb__dbStringProperty, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbIntProperty[] = {{&_swigt__p_odb__dbIntProperty, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbDoubleProperty[] = {{&_swigt__p_odb__dbDoubleProperty, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbProperty[] = {  {&_swigt__p_odb__dbProperty, 0, 0, 0},  {&_swigt__p_odb__dbBoolProperty, _p_odb__dbBoolPropertyTo_p_odb__dbProperty, 0, 0},  {&_swigt__p_odb__dbStringProperty, _p_odb__dbStringPropertyTo_p_odb__dbProperty, 0, 0},  {&_swigt__p_odb__dbIntProperty, _p_odb__dbIntPropertyTo_p_odb__dbProperty, 0, 0},  {&_swigt__p_odb__dbDoubleProperty, _p_odb__dbDoublePropertyTo_p_odb__dbProperty, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbRSeg[] = {  {&_swigt__p_odb__dbRSeg, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbRegion[] = {  {&_swigt__p_odb__dbRegion, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbRow[] = {  {&_swigt__p_odb__dbRow, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbSBox[] = {  {&_swigt__p_odb__dbSBox, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbSWire[] = {  {&_swigt__p_odb__dbSWire, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbSite[] = {  {&_swigt__p_odb__dbSite, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTarget[] = {  {&_swigt__p_odb__dbTarget, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechLayer[] = {  {&_swigt__p_odb__dbTechLayer, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechLayerCornerSpacingRule[] = {  {&_swigt__p_odb__dbTechLayerCornerSpacingRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechLayerCutClassRule[] = {  {&_swigt__p_odb__dbTechLayerCutClassRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechLayerCutSpacingRule[] = {  {&_swigt__p_odb__dbTechLayerCutSpacingRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechLayerCutSpacingTableDefRule[] = {  {&_swigt__p_odb__dbTechLayerCutSpacingTableDefRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechLayerCutSpacingTableOrthRule[] = {  {&_swigt__p_odb__dbTechLayerCutSpacingTableOrthRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechLayerMinStepRule[] = {  {&_swigt__p_odb__dbTechLayerMinStepRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechLayerSpacingRule[] = {  {&_swigt__p_odb__dbTechLayerSpacingRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechLayerSpacingTablePrlRule[] = {  {&_swigt__p_odb__dbTechLayerSpacingTablePrlRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechMinCutRule[] = {  {&_swigt__p_odb__dbTechMinCutRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechMinEncRule[] = {  {&_swigt__p_odb__dbTechMinEncRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechNonDefaultRule[] = {  {&_swigt__p_odb__dbTechNonDefaultRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechV55InfluenceEntry[] = {  {&_swigt__p_odb__dbTechV55InfluenceEntry, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechVia[] = {  {&_swigt__p_odb__dbTechVia, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechViaGenerateRule[] = {  {&_swigt__p_odb__dbTechViaGenerateRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTechViaRule[] = {  {&_swigt__p_odb__dbTechViaRule, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbTrackGrid[] = {  {&_swigt__p_odb__dbTrackGrid, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbVia[] = {  {&_swigt__p_odb__dbVia, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_odb__dbWire[] = {  {&_swigt__p_odb__dbWire, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_dbNet[] = {  {&_swigt__p_p_dbNet, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_p_std__vectorT_dbNet_p_t[] = {  {&_swigt__p_p_std__vectorT_dbNet_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_size_type[] = {  {&_swigt__p_size_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_sta__Sta[] = {  {&_swigt__p_sta__Sta, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__out_of_range[] = {  {&_swigt__p_std__out_of_range, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_std__vectorT_dbNet_p_t[] = {  {&_swigt__p_std__vectorT_dbNet_p_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__p_value_type[] = {  {&_swigt__p_value_type, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__std__ptrdiff_t[] = {  {&_swigt__std__ptrdiff_t, 0, 0, 0},{0, 0, 0, 0}};
static swig_cast_info _swigc__std__size_t[] = {  {&_swigt__std__size_t, 0, 0, 0},{0, 0, 0, 0}};

static swig_cast_info *swig_cast_initial[] = {
  _swigc__p_Cell,
  _swigc__p_CellPortIterator,
  _swigc__p_Clock,
  _swigc__p_ClockEdge,
  _swigc__p_ClockGroups,
  _swigc__p_ClockIterator,
  _swigc__p_ClockSet,
  _swigc__p_Corner,
  _swigc__p_Crpr,
  _swigc__p_EarlyLate,
  _swigc__p_EarlyLateAll,
  _swigc__p_Edge,
  _swigc__p_EdgeSeq,
  _swigc__p_ExceptionFrom,
  _swigc__p_ExceptionThru,
  _swigc__p_ExceptionThruSeq,
  _swigc__p_ExceptionTo,
  _swigc__p_FloatSeq,
  _swigc__p_Instance,
  _swigc__p_InstanceChildIterator,
  _swigc__p_InstanceNetIterator,
  _swigc__p_InstancePinIterator,
  _swigc__p_InstanceSeq,
  _swigc__p_InstanceSet,
  _swigc__p_IntSeq,
  _swigc__p_LeafInstanceIterator,
  _swigc__p_LibertyCell,
  _swigc__p_LibertyCellPortIterator,
  _swigc__p_LibertyCellTimingArcSetIterator,
  _swigc__p_LibertyLibrary,
  _swigc__p_LibertyLibraryIterator,
  _swigc__p_LibertyPort,
  _swigc__p_LibertyPortMemberIterator,
  _swigc__p_Library,
  _swigc__p_LibraryIterator,
  _swigc__p_LogicValue,
  _swigc__p_MaxSkewCheck,
  _swigc__p_MaxSkewCheckSeq,
  _swigc__p_MinMax,
  _swigc__p_MinMaxAll,
  _swigc__p_MinMaxAllNull,
  _swigc__p_MinPeriodCheck,
  _swigc__p_MinPeriodCheckSeq,
  _swigc__p_MinPulseWidthCheck,
  _swigc__p_MinPulseWidthCheckSeq,
  _swigc__p_MinPulseWidthCheckSeqIterator,
  _swigc__p_Net,
  _swigc__p_NetConnectedPinIterator,
  _swigc__p_NetPinIterator,
  _swigc__p_NetSet,
  _swigc__p_NetTermIterator,
  _swigc__p_OperatingConditions,
  _swigc__p_Path,
  _swigc__p_PathClkOrData,
  _swigc__p_PathEnd,
  _swigc__p_PathGroupNameSet,
  _swigc__p_PathRef,
  _swigc__p_Pin,
  _swigc__p_PinConnectedPinIterator,
  _swigc__p_PinSeq,
  _swigc__p_PinSet,
  _swigc__p_Polygon90,
  _swigc__p_Polygon90Set,
  _swigc__p_Port,
  _swigc__p_PortMemberIterator,
  _swigc__p_PortSeq,
  _swigc__p_ReducedParasiticType,
  _swigc__p_ReportPathFormat,
  _swigc__p_RiseFall,
  _swigc__p_RiseFallBoth,
  _swigc__p_SetupHold,
  _swigc__p_SetupHoldAll,
  _swigc__p_SlowDrvrIterator,
  _swigc__p_StringSeq,
  _swigc__p_StringSet,
  _swigc__p_Tcl_Interp,
  _swigc__p_Term,
  _swigc__p_TimingArc,
  _swigc__p_TimingArcSet,
  _swigc__p_TimingArcSetArcIterator,
  _swigc__p_TimingDerateCellType,
  _swigc__p_TimingDerateType,
  _swigc__p_TimingRole,
  _swigc__p_Transition,
  _swigc__p_Vertex,
  _swigc__p_VertexInEdgeIterator,
  _swigc__p_VertexIterator,
  _swigc__p_VertexOutEdgeIterator,
  _swigc__p_VertexPathIterator,
  _swigc__p_Wireload,
  _swigc__p_WireloadSelection,
  _swigc__p_char,
  _swigc__p_dbNet,
  _swigc__p_difference_type,
  _swigc__p_edge_iterator,
  _swigc__p_node_iterator,
  _swigc__p_object_iterator,
  _swigc__p_odb__Point,
  _swigc__p_odb__Rect,
  _swigc__p_odb__dbAccessPoint,
  _swigc__p_odb__dbBPin,
  _swigc__p_odb__dbBTerm,
  _swigc__p_odb__dbBlock,
  _swigc__p_odb__dbBlockage,
  _swigc__p_odb__dbBoolProperty,
  _swigc__p_odb__dbBox,
  _swigc__p_odb__dbCCSeg,
  _swigc__p_odb__dbCapNode,
  _swigc__p_odb__dbChip,
  _swigc__p_odb__dbDoubleProperty,
  _swigc__p_odb__dbGroup,
  _swigc__p_odb__dbITerm,
  _swigc__p_odb__dbInst,
  _swigc__p_odb__dbIntProperty,
  _swigc__p_odb__dbLib,
  _swigc__p_odb__dbMPin,
  _swigc__p_odb__dbMTerm,
  _swigc__p_odb__dbMaster,
  _swigc__p_odb__dbModInst,
  _swigc__p_odb__dbModule,
  _swigc__p_odb__dbNet,
  _swigc__p_odb__dbObstruction,
  _swigc__p_odb__dbProperty,
  _swigc__p_odb__dbRSeg,
  _swigc__p_odb__dbRegion,
  _swigc__p_odb__dbRow,
  _swigc__p_odb__dbSBox,
  _swigc__p_odb__dbSWire,
  _swigc__p_odb__dbSite,
  _swigc__p_odb__dbStringProperty,
  _swigc__p_odb__dbTarget,
  _swigc__p_odb__dbTechLayer,
  _swigc__p_odb__dbTechLayerCornerSpacingRule,
  _swigc__p_odb__dbTechLayerCutClassRule,
  _swigc__p_odb__dbTechLayerCutSpacingRule,
  _swigc__p_odb__dbTechLayerCutSpacingTableDefRule,
  _swigc__p_odb__dbTechLayerCutSpacingTableOrthRule,
  _swigc__p_odb__dbTechLayerMinStepRule,
  _swigc__p_odb__dbTechLayerSpacingRule,
  _swigc__p_odb__dbTechLayerSpacingTablePrlRule,
  _swigc__p_odb__dbTechMinCutRule,
  _swigc__p_odb__dbTechMinEncRule,
  _swigc__p_odb__dbTechNonDefaultRule,
  _swigc__p_odb__dbTechV55InfluenceEntry,
  _swigc__p_odb__dbTechVia,
  _swigc__p_odb__dbTechViaGenerateRule,
  _swigc__p_odb__dbTechViaRule,
  _swigc__p_odb__dbTrackGrid,
  _swigc__p_odb__dbVia,
  _swigc__p_odb__dbWire,
  _swigc__p_p_dbNet,
  _swigc__p_p_std__vectorT_dbNet_p_t,
  _swigc__p_size_type,
  _swigc__p_sta__Sta,
  _swigc__p_std__out_of_range,
  _swigc__p_std__vectorT_dbNet_p_t,
  _swigc__p_value_type,
  _swigc__std__ptrdiff_t,
  _swigc__std__size_t,
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

#ifdef __cplusplus
}
#endif
/* -----------------------------------------------------------------------------
 * Type initialization:
 * This problem is tough by the requirement that no dynamic
 * memory is used. Also, since swig_type_info structures store pointers to
 * swig_cast_info structures and swig_cast_info structures store pointers back
 * to swig_type_info structures, we need some lookup code at initialization.
 * The idea is that swig generates all the structures that are needed.
 * The runtime then collects these partially filled structures.
 * The SWIG_InitializeModule function takes these initial arrays out of
 * swig_module, and does all the lookup, filling in the swig_module.types
 * array with the correct data and linking the correct swig_cast_info
 * structures together.
 *
 * The generated swig_type_info structures are assigned statically to an initial
 * array. We just loop through that array, and handle each type individually.
 * First we lookup if this type has been already loaded, and if so, use the
 * loaded structure instead of the generated one. Then we have to fill in the
 * cast linked list. The cast data is initially stored in something like a
 * two-dimensional array. Each row corresponds to a type (there are the same
 * number of rows as there are in the swig_type_initial array). Each entry in
 * a column is one of the swig_cast_info structures for that type.
 * The cast_initial array is actually an array of arrays, because each row has
 * a variable number of columns. So to actually build the cast linked list,
 * we find the array of casts associated with the type, and loop through it
 * adding the casts to the list. The one last trick we need to do is making
 * sure the type pointer in the swig_cast_info struct is correct.
 *
 * First off, we lookup the cast->type name to see if it is already loaded.
 * There are three cases to handle:
 *  1) If the cast->type has already been loaded AND the type we are adding
 *     casting info to has not been loaded (it is in this module), THEN we
 *     replace the cast->type pointer with the type pointer that has already
 *     been loaded.
 *  2) If BOTH types (the one we are adding casting info to, and the
 *     cast->type) are loaded, THEN the cast info has already been loaded by
 *     the previous module so we just ignore it.
 *  3) Finally, if cast->type has not already been loaded, then we add that
 *     swig_cast_info to the linked list (because the cast->type) pointer will
 *     be correct.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#if 0
} /* c-mode */
#endif
#endif

#if 0
#define SWIGRUNTIME_DEBUG
#endif


SWIGRUNTIME void
SWIG_InitializeModule(void *clientdata) {
  size_t i;
  swig_module_info *module_head, *iter;
  int init;
  
  /* check to see if the circular list has been setup, if not, set it up */
  if (swig_module.next==0) {
    /* Initialize the swig_module */
    swig_module.type_initial = swig_type_initial;
    swig_module.cast_initial = swig_cast_initial;
    swig_module.next = &swig_module;
    init = 1;
  } else {
    init = 0;
  }
  
  /* Try and load any already created modules */
  module_head = SWIG_GetModule(clientdata);
  if (!module_head) {
    /* This is the first module loaded for this interpreter */
    /* so set the swig module into the interpreter */
    SWIG_SetModule(clientdata, &swig_module);
  } else {
    /* the interpreter has loaded a SWIG module, but has it loaded this one? */
    iter=module_head;
    do {
      if (iter==&swig_module) {
        /* Our module is already in the list, so there's nothing more to do. */
        return;
      }
      iter=iter->next;
    } while (iter!= module_head);
    
    /* otherwise we must add our module into the list */
    swig_module.next = module_head->next;
    module_head->next = &swig_module;
  }
  
  /* When multiple interpreters are used, a module could have already been initialized in
       a different interpreter, but not yet have a pointer in this interpreter.
       In this case, we do not want to continue adding types... everything should be
       set up already */
  if (init == 0) return;
  
  /* Now work on filling in swig_module.types */
#ifdef SWIGRUNTIME_DEBUG
  printf("SWIG_InitializeModule: size %lu\n", (unsigned long)swig_module.size);
#endif
  for (i = 0; i < swig_module.size; ++i) {
    swig_type_info *type = 0;
    swig_type_info *ret;
    swig_cast_info *cast;
    
#ifdef SWIGRUNTIME_DEBUG
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
#endif
    
    /* if there is another module already loaded */
    if (swig_module.next != &swig_module) {
      type = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, swig_module.type_initial[i]->name);
    }
    if (type) {
      /* Overwrite clientdata field */
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: found type %s\n", type->name);
#endif
      if (swig_module.type_initial[i]->clientdata) {
        type->clientdata = swig_module.type_initial[i]->clientdata;
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: found and overwrite type %s \n", type->name);
#endif
      }
    } else {
      type = swig_module.type_initial[i];
    }
    
    /* Insert casting types */
    cast = swig_module.cast_initial[i];
    while (cast->type) {
      /* Don't need to add information already in the list */
      ret = 0;
#ifdef SWIGRUNTIME_DEBUG
      printf("SWIG_InitializeModule: look cast %s\n", cast->type->name);
#endif
      if (swig_module.next != &swig_module) {
        ret = SWIG_MangledTypeQueryModule(swig_module.next, &swig_module, cast->type->name);
#ifdef SWIGRUNTIME_DEBUG
        if (ret) printf("SWIG_InitializeModule: found cast %s\n", ret->name);
#endif
      }
      if (ret) {
        if (type == swig_module.type_initial[i]) {
#ifdef SWIGRUNTIME_DEBUG
          printf("SWIG_InitializeModule: skip old type %s\n", ret->name);
#endif
          cast->type = ret;
          ret = 0;
        } else {
          /* Check for casting already in the list */
          swig_cast_info *ocast = SWIG_TypeCheck(ret->name, type);
#ifdef SWIGRUNTIME_DEBUG
          if (ocast) printf("SWIG_InitializeModule: skip old cast %s\n", ret->name);
#endif
          if (!ocast) ret = 0;
        }
      }
      
      if (!ret) {
#ifdef SWIGRUNTIME_DEBUG
        printf("SWIG_InitializeModule: adding cast %s\n", cast->type->name);
#endif
        if (type->cast) {
          type->cast->prev = cast;
          cast->next = type->cast;
        }
        type->cast = cast;
      }
      cast++;
    }
    /* Set entry in modules->types array equal to the type */
    swig_module.types[i] = type;
  }
  swig_module.types[i] = 0;
  
#ifdef SWIGRUNTIME_DEBUG
  printf("**** SWIG_InitializeModule: Cast List ******\n");
  for (i = 0; i < swig_module.size; ++i) {
    int j = 0;
    swig_cast_info *cast = swig_module.cast_initial[i];
    printf("SWIG_InitializeModule: type %lu %s\n", (unsigned long)i, swig_module.type_initial[i]->name);
    while (cast->type) {
      printf("SWIG_InitializeModule: cast type %s\n", cast->type->name);
      cast++;
      ++j;
    }
    printf("---- Total casts: %d\n",j);
  }
  printf("**** SWIG_InitializeModule: Cast List ******\n");
#endif
}

/* This function will propagate the clientdata field of type to
* any new swig_type_info structures that have been added into the list
* of equivalent types.  It is like calling
* SWIG_TypeClientData(type, clientdata) a second time.
*/
SWIGRUNTIME void
SWIG_PropagateClientData(void) {
  size_t i;
  swig_cast_info *equiv;
  static int init_run = 0;
  
  if (init_run) return;
  init_run = 1;
  
  for (i = 0; i < swig_module.size; i++) {
    if (swig_module.types[i]->clientdata) {
      equiv = swig_module.types[i]->cast;
      while (equiv) {
        if (!equiv->converter) {
          if (equiv->type && !equiv->type->clientdata)
          SWIG_TypeClientData(equiv->type, swig_module.types[i]->clientdata);
        }
        equiv = equiv->next;
      }
    }
  }
}

#ifdef __cplusplus
#if 0
{
  /* c-mode */
#endif
}
#endif


#ifdef __cplusplus
extern "C" {
#endif
  
  /* -----------------------------------------------------------------------------
   * constants/methods manipulation
   * ----------------------------------------------------------------------------- */
  
  /* Install Constants */
  
  SWIGINTERN void
  SWIG_Tcl_InstallConstants(Tcl_Interp *interp, swig_const_info constants[]) {
    size_t i;
    Tcl_Obj *obj;
    
    if (!swigconstTableinit) {
      Tcl_InitHashTable(&swigconstTable, TCL_STRING_KEYS);
      swigconstTableinit = 1;
    }
    for (i = 0; constants[i].type; i++) {
      switch(constants[i].type) {
      case SWIG_TCL_POINTER:
        obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
        break;
      case SWIG_TCL_BINARY:
        obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
        break;
      default:
        obj = 0;
        break;
      }
      if (obj) {
        SWIG_Tcl_SetConstantObj(interp, constants[i].name, obj);
      }
    }
  }
  
  /* Create fast method lookup tables */
  
  SWIGINTERN void
  SWIG_Tcl_InstallMethodLookupTables(void) {
    size_t i;
    
    for (i = 0; i < swig_module.size; ++i) {
      swig_type_info *type = swig_module.type_initial[i];
      if (type->clientdata) {
        swig_class* klass = (swig_class*) type->clientdata;
        swig_method* meth;
        Tcl_InitHashTable(&(klass->hashtable), TCL_STRING_KEYS);
        for (meth = klass->methods; meth && meth->name; ++meth) {
          int newEntry;
          Tcl_HashEntry* hashentry = Tcl_CreateHashEntry(&(klass->hashtable), meth->name, &newEntry);
          Tcl_SetHashValue(hashentry, (ClientData)meth->method);
        }
      }
    }
  }
  
#ifdef __cplusplus
}
#endif

/* -----------------------------------------------------------------------------*
 *  Partial Init method
 * -----------------------------------------------------------------------------*/

SWIGEXPORT int SWIG_init(Tcl_Interp *interp) {
  size_t i;
  if (interp == 0) return TCL_ERROR;
#ifdef USE_TCL_STUBS
  /* (char*) cast is required to avoid compiler warning/error for Tcl < 8.4. */
  if (Tcl_InitStubs(interp, (char*)SWIG_TCL_STUBS_VERSION, 0) == NULL) {
    return TCL_ERROR;
  }
#endif  
#ifdef USE_TK_STUBS
  /* (char*) cast is required to avoid compiler warning/error. */
  if (Tk_InitStubs(interp, (char*)SWIG_TCL_STUBS_VERSION, 0) == NULL) {
    return TCL_ERROR;
  }
#endif
  
  Tcl_PkgProvide(interp, (char*)SWIG_name, (char*)SWIG_version);
  
#ifdef SWIG_namespace
  Tcl_Eval(interp, "namespace eval " SWIG_namespace " { }");
#endif
  
  SWIG_InitializeModule((void *) interp);
  SWIG_PropagateClientData();
  
  for (i = 0; swig_commands[i].name; i++) {
    Tcl_CreateObjCommand(interp, (char *) swig_commands[i].name, (swig_wrapper_func) swig_commands[i].wrapper,
      swig_commands[i].clientdata, NULL);
  }
  for (i = 0; swig_variables[i].name; i++) {
    Tcl_SetVar(interp, (char *) swig_variables[i].name, (char *) "", TCL_GLOBAL_ONLY);
    Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_READS | TCL_GLOBAL_ONLY, 
      (Tcl_VarTraceProc *) swig_variables[i].get, (ClientData) swig_variables[i].addr);
    Tcl_TraceVar(interp, (char *) swig_variables[i].name, TCL_TRACE_WRITES | TCL_GLOBAL_ONLY, 
      (Tcl_VarTraceProc *) swig_variables[i].set, (ClientData) swig_variables[i].addr);
  }
  
  SWIG_Tcl_InstallConstants(interp, swig_constants);
  SWIG_Tcl_InstallMethodLookupTables();
  
  
  return TCL_OK;
}
SWIGEXPORT int Dbsta_SafeInit(Tcl_Interp *interp) {
  return SWIG_init(interp);
}

