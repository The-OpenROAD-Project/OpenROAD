///////////////////////////////////////////////////////////////////////////////
// BSD 3-Clause License
//
// Copyright (c) 2022, The Regents of the University of California
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of the copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

#pragma once

#include <array>
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/point_xy.hpp>
#include <boost/geometry/index/rtree.hpp>
#include <map>
#include <memory>

#include "odb/dbTypes.h"
#include "odb/geom.h"

namespace odb {
class dbBlock;
class dbNet;
class dbTech;
class dbTechLayer;
class dbTechLayerCutClassRule;
class dbViaVia;
class dbTechVia;
class dbTechViaGenerateRule;
class dbTechViaLayerRule;
class dbSBox;
class dbSWire;
class dbVia;
class dbViaParams;
class dbTechLayerCutEnclosureRule;
}  // namespace odb

namespace utl {
class Logger;
}  // namespace utl

namespace pdn {

namespace bg = boost::geometry;
namespace bgi = boost::geometry::index;

class Connect;
class Shape;
class Via;
class ViaGenerator;

using Point = bg::model::d2::point_xy<int, bg::cs::cartesian>;
using Box = bg::model::box<Point>;
using ShapePtr = std::shared_ptr<Shape>;
using ViaPtr = std::shared_ptr<Via>;
using ShapeValue = std::pair<Box, ShapePtr>;
using ViaValue = std::pair<Box, ViaPtr>;
using ShapeTree = bgi::rtree<ShapeValue, bgi::quadratic<16>>;
using ViaTree = bgi::rtree<ViaValue, bgi::quadratic<16>>;
using ShapeTreeMap = std::map<odb::dbTechLayer*, ShapeTree>;

using ViaReport = std::map<std::string, int>;

class Grid;
class TechLayer;

enum class failedViaReason
{
  OBSTRUCTED,
  BUILD,
  RIPUP,
  RECHECK,
  OTHER
};

class Enclosure
{
 public:
  Enclosure();
  Enclosure(int x, int y);
  Enclosure(odb::dbTechLayerCutEnclosureRule* rule,
            odb::dbTechLayer* layer,
            const odb::Rect& cut,
            odb::dbTechLayerDir direction);
  Enclosure(odb::dbTechViaLayerRule* rule, odb::dbTechLayer* layer);

  int getX() const { return x_; }
  int getY() const { return y_; }

  void setX(int x) { x_ = x; }
  void setY(int y) { y_ = y; }

  bool check(int x, int y) const;

  bool operator<(const Enclosure& other) const;
  bool operator==(const Enclosure& other) const;

  void copy(const Enclosure* other);
  void copy(const Enclosure& other);

  bool isPreferredOver(const Enclosure* other, odb::dbTechLayer* layer) const;
  bool isPreferredOver(const Enclosure* other, bool minimize_x) const;

  void snap(odb::dbTech* tech);

 private:
  int x_;
  int y_;

  bool allow_swap_;

  void swap(odb::dbTechLayer* layer);
};

// Wrapper class to handle building actual ODB DB Vias
class DbVia
{
 public:
  struct ViaLayerShape
  {
    using RectBoxPair = std::pair<odb::Rect, odb::dbSBox*>;
    std::set<RectBoxPair> bottom;
    std::set<RectBoxPair> middle;
    std::set<RectBoxPair> top;
  };

  DbVia();

  virtual ~DbVia() {}

  virtual ViaLayerShape generate(odb::dbBlock* block,
                                 odb::dbSWire* wire,
                                 odb::dbWireShapeType type,
                                 int x,
                                 int y,
                                 utl::Logger* logger)
      = 0;

  virtual bool requiresPatch() const { return false; }

  odb::Rect adjustToMinArea(odb::dbTechLayer* layer,
                            const odb::Rect& rect) const;

  virtual ViaReport getViaReport() const = 0;

  void setGenerator(const std::shared_ptr<ViaGenerator>& generator)
  {
    generator_ = generator;
  }
  bool hasGenerator() const { return generator_ != nullptr; }
  ViaGenerator* getGenerator() const { return generator_.get(); }

 protected:
  ViaLayerShape getLayerShapes(odb::dbSBox* box) const;
  void combineLayerShapes(const ViaLayerShape& other,
                          ViaLayerShape& shapes) const;

  void addToViaReport(DbVia* via, ViaReport& report) const;

 private:
  std::shared_ptr<ViaGenerator> generator_;
};

// Used as the base class for actual vias like TechVias and GenerateVias
class DbBaseVia : public DbVia
{
 public:
  DbBaseVia();

  virtual std::string getName() const = 0;
  virtual const odb::Rect getViaRect(bool include_enclosure,
                                     bool include_via_shape,
                                     bool include_bottom = true,
                                     bool include_top = true) const = 0;

  int getCount() const { return count_; }

  virtual ViaReport getViaReport() const override;

 protected:
  void incrementCount() { count_++; }

 private:
  int count_;
};

// Wrapper to handle building dbTechVia as a single via or an array
class DbTechVia : public DbBaseVia
{
 public:
  DbTechVia(odb::dbTechVia* via,
            int rows,
            int row_pitch,
            int cols,
            int col_pitch,
            Enclosure* required_bottom_enc = nullptr,
            Enclosure* required_top_enc = nullptr);
  virtual ~DbTechVia() {}

  virtual ViaLayerShape generate(odb::dbBlock* block,
                                 odb::dbSWire* wire,
                                 odb::dbWireShapeType type,
                                 int x,
                                 int y,
                                 utl::Logger* logger) override;

  virtual bool requiresPatch() const override { return rows_ > 1 || cols_ > 1; }

  virtual std::string getName() const override;
  virtual const odb::Rect getViaRect(bool include_enclosure,
                                     bool include_via_shape,
                                     bool include_bottom = true,
                                     bool include_top = true) const override;

 private:
  odb::dbTechVia* via_;
  int rows_;
  int row_pitch_;
  int cols_;
  int col_pitch_;

  odb::Rect via_rect_;
  odb::Rect enc_bottom_rect_;
  odb::Rect enc_top_rect_;

  odb::Rect required_bottom_rect_;
  odb::Rect required_top_rect_;

  odb::Point via_center_;
};

// Wrapper to handle building dbTechViaGenerate vias (GENERATE vias) as
// a single via or an array.
class DbGenerateVia : public DbBaseVia
{
 public:
  DbGenerateVia(const odb::Rect& rect,
                odb::dbTechViaGenerateRule* rule,
                int rows,
                int columns,
                int cut_pitch_x,
                int cut_pitch_y,
                int bottom_enclosure_x,
                int bottom_enclosure_y,
                int top_enclosure_x,
                int top_enclosure_y,
                odb::dbTechLayer* bottom,
                odb::dbTechLayer* cut,
                odb::dbTechLayer* top);
  virtual ~DbGenerateVia() {}

  virtual ViaLayerShape generate(odb::dbBlock* block,
                                 odb::dbSWire* wire,
                                 odb::dbWireShapeType type,
                                 int x,
                                 int y,
                                 utl::Logger* logger) override;

  virtual std::string getName() const override;
  virtual const odb::Rect getViaRect(bool include_enclosure,
                                     bool include_via_shape,
                                     bool include_bottom = true,
                                     bool include_top = true) const override;

 private:
  odb::Rect rect_;
  odb::Rect cut_rect_;

  odb::dbTechViaGenerateRule* rule_;
  int rows_;
  int columns_;

  int cut_pitch_x_;
  int cut_pitch_y_;

  int bottom_enclosure_x_;
  int bottom_enclosure_y_;
  int top_enclosure_x_;
  int top_enclosure_y_;

  odb::dbTechLayer* bottom_;
  odb::dbTechLayer* cut_;
  odb::dbTechLayer* top_;

  const std::string getViaName() const;
};

// Wrapper class to build split cut array vias (-split_cut)
class DbSplitCutVia : public DbVia
{
 public:
  DbSplitCutVia(DbBaseVia* via,
                int rows,
                int row_pitch,
                int cols,
                int col_pitch,
                odb::dbBlock* block,
                odb::dbTechLayer* bottom,
                bool snap_bottom,
                odb::dbTechLayer* top,
                bool snap_top);
  virtual ~DbSplitCutVia();

  virtual ViaLayerShape generate(odb::dbBlock* block,
                                 odb::dbSWire* wire,
                                 odb::dbWireShapeType type,
                                 int x,
                                 int y,
                                 utl::Logger* logger) override;

  virtual ViaReport getViaReport() const override;

 private:
  std::unique_ptr<TechLayer> bottom_;
  std::unique_ptr<TechLayer> top_;

  std::unique_ptr<DbBaseVia> via_;
  int rows_;
  int row_pitch_;
  int cols_;
  int col_pitch_;
};

// Wrapper to build via arrays according to ARRAYSPACING rules
class DbArrayVia : public DbVia
{
 public:
  DbArrayVia(DbBaseVia* core_via,
             DbBaseVia* end_of_row,
             DbBaseVia* end_of_column,
             DbBaseVia* end_of_row_column,
             int core_rows,
             int core_cols,
             int array_spacing_x,
             int array_spacing_y);
  virtual ~DbArrayVia() {}

  virtual ViaLayerShape generate(odb::dbBlock* block,
                                 odb::dbSWire* wire,
                                 odb::dbWireShapeType type,
                                 int x,
                                 int y,
                                 utl::Logger* logger) override;

  virtual bool requiresPatch() const override { return true; }

  virtual ViaReport getViaReport() const override;

 private:
  std::unique_ptr<DbBaseVia> core_via_;
  std::unique_ptr<DbBaseVia> end_of_row_;
  std::unique_ptr<DbBaseVia> end_of_column_;
  std::unique_ptr<DbBaseVia> end_of_row_column_;
  int rows_;
  int columns_;

  int array_spacing_x_;
  int array_spacing_y_;

  int array_start_x_;
  int array_start_y_;
};

// Wrapper to build multiple level vias as a stack.
class DbGenerateStackedVia : public DbVia
{
 public:
  DbGenerateStackedVia(const std::vector<DbVia*>& vias,
                       odb::dbTechLayer* bottom,
                       odb::dbBlock* block,
                       const std::set<odb::dbTechLayer*>& ongrid);
  virtual ~DbGenerateStackedVia();

  virtual ViaLayerShape generate(odb::dbBlock* block,
                                 odb::dbSWire* wire,
                                 odb::dbWireShapeType type,
                                 int x,
                                 int y,
                                 utl::Logger* logger) override;

  virtual ViaReport getViaReport() const override;

 private:
  std::vector<std::unique_ptr<DbVia>> vias_;
  std::vector<std::unique_ptr<TechLayer>> layers_;
};

// Dummy via doesn't build anything but instead generates a warning that a via
// cannot be inserted at the given location.
class DbGenerateDummyVia : public DbVia
{
 public:
  DbGenerateDummyVia(Connect* connect,
                     const odb::Rect& shape,
                     odb::dbTechLayer* bottom,
                     odb::dbTechLayer* top,
                     bool add_report);
  virtual ~DbGenerateDummyVia() {}

  virtual ViaLayerShape generate(odb::dbBlock* block,
                                 odb::dbSWire* wire,
                                 odb::dbWireShapeType /* type */,
                                 int x,
                                 int y,
                                 utl::Logger* logger) override;

  virtual ViaReport getViaReport() const override { return {}; }

 private:
  Connect* connect_;
  bool add_report_;
  const odb::Rect shape_;
  odb::dbTechLayer* bottom_;
  odb::dbTechLayer* top_;
};

// Class to build a generate via, either as a single group or as an array
class ViaGenerator
{
 public:
  struct Constraint
  {
    bool must_fit_x;
    bool must_fit_y;
    bool intersection_only;
  };

  ViaGenerator(utl::Logger* logger,
               const odb::Rect& lower_rect,
               const Constraint& lower_constraint,
               const odb::Rect& upper_rect,
               const Constraint& upper_constraint);
  virtual ~ViaGenerator() = default;

  virtual const std::string getName() const = 0;

  virtual odb::dbTechLayer* getBottomLayer() const = 0;
  virtual odb::dbTechLayer* getTopLayer() const = 0;
  virtual odb::dbTechLayer* getCutLayer() const = 0;

  virtual const odb::Rect& getCut() const { return cut_; }
  virtual int getCutArea() const;

  void setCutPitchX(int pitch) { cut_pitch_x_ = pitch; }
  int getCutPitchX() const { return cut_pitch_x_; }
  void setCutPitchY(int pitch) { cut_pitch_y_ = pitch; }
  int getCutPitchY() const { return cut_pitch_y_; }

  void setMaxRows(int rows) { max_rows_ = rows; }
  void setMaxColumns(int columns) { max_cols_ = columns; }

  odb::dbTechLayerCutClassRule* getCutClass() const { return cutclass_; }
  bool hasCutClass() const { return cutclass_ != nullptr; }

  virtual bool isSetupValid(odb::dbTechLayer* lower,
                            odb::dbTechLayer* upper) const;
  virtual bool checkConstraints(bool check_cuts = true,
                                bool check_min_cut = true,
                                bool check_enclosure = true) const;

  // determine the shape of the vias
  bool build(bool bottom_is_internal_layer, bool top_is_internal_layer);
  virtual int getRows() const;
  virtual int getColumns() const;
  virtual int getTotalCuts() const;

  DbVia* generate(odb::dbBlock* block) const;
  virtual DbBaseVia* makeBaseVia(int rows,
                                 int row_pitch,
                                 int cols,
                                 int col_pitch) const = 0;

  const odb::Rect& getLowerRect() const { return lower_rect_; }
  const odb::Rect& getUpperRect() const { return upper_rect_; }
  const odb::Rect& getIntersectionRect() const { return intersection_rect_; }

  void setSplitCutArray(bool split_cuts_bot, bool split_cuts_top);
  bool isSplitCutArray() const { return split_cuts_top_ || split_cuts_bottom_; }
  bool isCutArray() const
  {
    return !isSplitCutArray() && (array_core_x_ != 1 || array_core_y_ != 1);
  }

  Enclosure* getBottomEnclosure() const { return bottom_enclosure_.get(); }
  Enclosure* getTopEnclosure() const { return top_enclosure_.get(); }

  bool isPreferredOver(const ViaGenerator* other) const;

  int getGeneratorWidth(bool bottom) const;
  int getGeneratorHeight(bool bottom) const;

  bool recheckConstraints(const odb::Rect& rect, bool bottom);

 protected:
  int getMaxRows() const { return max_rows_; }
  int getMaxColumns() const { return max_cols_; }

  bool isCutClass(odb::dbTechLayerCutClassRule* cutclass) const;
  void setCut(const odb::Rect& cut);

  int getCuts(int width,
              int cut,
              int bot_enc,
              int top_enc,
              int pitch,
              int max_cuts) const;

  int getCutsWidth(int cuts, int cut_width, int spacing, int enc) const;

  int getViaCoreRows() const { return core_row_; }
  int getViaCoreColumns() const { return core_col_; }
  int getViaLastRows() const { return end_row_; }
  bool hasViaLastRows() const { return end_row_ != 0; }
  int getViaLastColumns() const { return end_col_; }
  bool hasViaLastColumns() const { return end_col_ != 0; }

  int getArraySpacingX() const { return array_spacing_x_; }
  int getArraySpacingY() const { return array_spacing_y_; }

  int getArrayCoresX() const { return array_core_x_; }
  int getArrayCoresY() const { return array_core_y_; }

  utl::Logger* getLogger() const { return logger_; }
  odb::dbTech* getTech() const;

  const Constraint& getLowerConstraint() const { return lower_constraint_; }
  const Constraint& getUpperConstraint() const { return upper_constraint_; }

  int getLowerWidth(bool only_real = true) const;
  int getUpperWidth(bool only_real = true) const;
  int getLowerHeight(bool only_real = true) const;
  int getUpperHeight(bool only_real = true) const;

  void determineCutSpacing();

  virtual void getMinimumEnclosures(std::vector<Enclosure>& bottom,
                                    std::vector<Enclosure>& top,
                                    bool rules_only) const;

 private:
  utl::Logger* logger_;

  odb::Rect lower_rect_;
  odb::Rect upper_rect_;
  odb::Rect intersection_rect_;

  Constraint lower_constraint_;
  Constraint upper_constraint_;

  odb::Rect cut_;

  odb::dbTechLayerCutClassRule* cutclass_;

  int cut_pitch_x_;
  int cut_pitch_y_;

  int max_rows_;
  int max_cols_;

  int core_row_;
  int core_col_;
  int end_row_;
  int end_col_;

  bool split_cuts_bottom_;
  bool split_cuts_top_;

  int array_spacing_x_;
  int array_spacing_y_;
  int array_core_x_;
  int array_core_y_;

  std::unique_ptr<Enclosure> bottom_enclosure_;
  std::unique_ptr<Enclosure> top_enclosure_;

  void determineCutClass();
  bool checkMinCuts() const;
  bool checkMinCuts(odb::dbTechLayer* layer, int width) const;
  bool appliesToLayers(odb::dbTechLayer* lower, odb::dbTechLayer* upper) const;

  bool checkMinEnclosure() const;

  std::vector<odb::dbTechLayerCutEnclosureRule*> getCutMinimumEnclosureRules(
      int width,
      bool above) const;

  void determineRowsAndColumns(bool use_bottom_min_enclosure,
                               bool use_top_min_enclosure,
                               const Enclosure& bottom_min_enclosure,
                               const Enclosure& top_min_enclosure);

  odb::dbTechLayerDir getRectDirection(const odb::Rect& rect) const;

  int getRectSize(const odb::Rect& rect, bool min, bool only_real) const;

  bool updateCutSpacing(int rows, int columns);
};

// Class to build a generate via, either as a single group or as an array
class GenerateViaGenerator : public ViaGenerator
{
 public:
  GenerateViaGenerator(utl::Logger* logger,
                       odb::dbTechViaGenerateRule* rule,
                       const odb::Rect& lower_rect,
                       const Constraint& lower_constraint,
                       const odb::Rect& upper_rect,
                       const Constraint& upper_constraint);

  virtual const std::string getName() const override;
  const std::string getRuleName() const;

  virtual odb::dbTechLayer* getBottomLayer() const override;
  odb::dbTechViaLayerRule* getBottomLayerRule() const;
  virtual odb::dbTechLayer* getTopLayer() const override;
  odb::dbTechViaLayerRule* getTopLayerRule() const;
  virtual odb::dbTechLayer* getCutLayer() const override;
  odb::dbTechViaLayerRule* getCutLayerRule() const;

  virtual bool isSetupValid(odb::dbTechLayer* lower,
                            odb::dbTechLayer* upper) const override;

  virtual DbBaseVia* makeBaseVia(int rows,
                                 int row_pitch,
                                 int cols,
                                 int col_pitch) const override;

 protected:
  virtual void getMinimumEnclosures(std::vector<Enclosure>& bottom,
                                    std::vector<Enclosure>& top,
                                    bool rules_only) const override;

 private:
  odb::dbTechViaGenerateRule* rule_;

  std::array<uint, 3> layers_;

  bool isLayerValidForWidth(odb::dbTechViaLayerRule*, int width) const;
  bool getLayerEnclosureRule(odb::dbTechViaLayerRule* rule,
                             int& dx,
                             int& dy) const;
  bool isBottomValidForWidth(int width) const;
  bool isTopValidForWidth(int width) const;
};

// Class to build a generate via, either as a single group or as an array
class TechViaGenerator : public ViaGenerator
{
 public:
  TechViaGenerator(utl::Logger* logger,
                   odb::dbTechVia* via,
                   const odb::Rect& lower_rect,
                   const Constraint& lower_constraint,
                   const odb::Rect& upper_rect,
                   const Constraint& upper_constraint);

  virtual const std::string getName() const override;

  virtual odb::dbTechLayer* getBottomLayer() const override { return bottom_; }
  virtual odb::dbTechLayer* getTopLayer() const override { return top_; }
  virtual odb::dbTechLayer* getCutLayer() const override { return cut_; }

  virtual const odb::Rect& getCut() const override;
  int getCutArea() const override;

  virtual int getTotalCuts() const override;

  virtual bool isSetupValid(odb::dbTechLayer* lower,
                            odb::dbTechLayer* upper) const override;

  odb::dbTechVia* getVia() const { return via_; }

  virtual DbBaseVia* makeBaseVia(int rows,
                                 int row_pitch,
                                 int cols,
                                 int col_pitch) const override;

  static std::set<odb::Rect> getViaObstructionRects(utl::Logger* logger,
                                                    odb::dbTechVia* via,
                                                    int x,
                                                    int y);

 protected:
  virtual void getMinimumEnclosures(std::vector<Enclosure>& bottom,
                                    std::vector<Enclosure>& top,
                                    bool rules_only) const override;

 private:
  odb::dbTechVia* via_;

  int cuts_;
  odb::Rect cut_outline_;

  odb::dbTechLayer* bottom_;
  odb::dbTechLayer* cut_;
  odb::dbTechLayer* top_;

  bool fitsShapes() const;
  bool mostlyContains(const odb::Rect& full_shape,
                      const odb::Rect& intersection,
                      const odb::Rect& small_shape,
                      const Constraint& constraint) const;
};

class Via
{
 public:
  Via(Connect* connect,
      odb::dbNet* net,
      const odb::Rect& area,
      const ShapePtr& lower,
      const ShapePtr& upper);

  odb::dbNet* getNet() const { return net_; }
  const odb::Rect& getArea() const { return area_; }
  const Box getBox() const;
  void setLowerShape(ShapePtr shape) { lower_ = shape; }
  const ShapePtr& getLowerShape() const { return lower_; }
  void setUpperShape(ShapePtr shape) { upper_ = shape; }
  const ShapePtr& getUpperShape() const { return upper_; }
  odb::dbTechLayer* getLowerLayer() const;
  odb::dbTechLayer* getUpperLayer() const;

  void removeShape(Shape* shape);

  bool isValid() const;

  bool containsIntermediateLayer(odb::dbTechLayer* layer) const;
  bool overlaps(const ViaPtr& via) const;
  bool startsBelow(const ViaPtr& via) const;

  Connect* getConnect() const { return connect_; }

  void writeToDb(odb::dbSWire* wire,
                 odb::dbBlock* block,
                 const ShapeTreeMap& obstructions);

  Grid* getGrid() const;

  const std::string getDisplayText() const;

  Via* copy() const;

  void markFailed(failedViaReason reason);

 private:
  odb::dbNet* net_;
  odb::Rect area_;
  ShapePtr lower_;
  ShapePtr upper_;

  Connect* connect_;

  utl::Logger* getLogger() const;
};

}  // namespace pdn
