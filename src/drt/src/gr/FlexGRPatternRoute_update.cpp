/* Authors: Zhiang Wang */
/*
 * Copyright (c) 2024, The Regents of the University of California
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the University nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "FlexGR.h"
#include "FlexGRWorker.h"

#include <omp.h>
#include <spdlog/common.h>
#include <sys/types.h>

#include <cmath>
#include <fstream>
#include <iostream>
#include <queue>


#include "db/grObj/grShape.h"
#include "db/grObj/grVia.h"
#include "db/infra/frTime.h"
#include "db/obj/frGuide.h"
#include "db/obj/frNode.h"
#include "odb/db.h"
#include "utl/exception.h"
#include "FlexGR_util.h"
#include "stt/SteinerTreeBuilder.h"

namespace drt {

using utl::ThreadException;


void FlexGR::initGR()
{
  // Route all the nets based on the sorted order 
  logger_->report("[INFO][FlexGR] Start pattern routing initialization ...");
  auto initRouteStartTimeStamp = std::chrono::high_resolution_clock::now();
  initGR_patternRoute_init_route_update();
  auto initRouteEndTimeStamp = std::chrono::high_resolution_clock::now();
  std::chrono::duration<double> initRouteTime = initRouteEndTimeStamp - initRouteStartTimeStamp;
  logger_->report("[INFO] Runtime for pattern routing initialization : {} s", initRouteTime.count());
  printPeakMemoryUsage(); 
  report2DCongestionMap_update(cmap2D_.get());

  if (VERBOSE > 0) {
    checkValidNet_update();
    logger_->report("[INFO][FlexGR] Finish checking the validity of the nets after initial pattern routing...\n");
  }

  logger_->report("[INFO][FlexGR] Start pattern routing ripup and reroute ...");
  for (int iter = 0; iter < 2; iter++) {
    logger_->report("[INFO][FlexGR] Start iteration {} for pattern routing ripup and reroute ...", iter);
    auto ripupRouteStartTimeStamp = std::chrono::high_resolution_clock::now();
    initGR_patternRoute_ripup_and_reroute_update();
    auto ripupRouteEndTimeStamp = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> ripupRouteTime = ripupRouteEndTimeStamp - ripupRouteStartTimeStamp;
    logger_->report("[INFO] Runtime for pattern routing ripup and reroute : {} s", ripupRouteTime.count());
    printPeakMemoryUsage();
    report2DCongestionMap_update(cmap2D_.get());

    if (VERBOSE > 0) {
      checkValidNet_update();
      logger_->report("[INFO][FlexGR] Finish checking the validity of the nets after pattern route ripup and reroute...\n");
    } 

    auto adjustStartTimeStamp = std::chrono::high_resolution_clock::now();
    // Adjust the tree topology based on the congestion
    initGR_patternRoute_adjust_topology_update();
    auto adjustEndTimeStamp = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> adjustTime = adjustEndTimeStamp - adjustStartTimeStamp;
    logger_->report("[INFO] Runtime for adjusting the tree topology : {} s", adjustTime.count());
    printPeakMemoryUsage();
    report2DCongestionMap_update(cmap2D_.get());

    if (VERBOSE > 0) {
      checkValidNet_update();
      logger_->report("[INFO][FlexGR] Finish checking the validity of the nets after adjusting the tree topology...\n");
    }
  }
  
  logger_->report("[INFO][FlexGR] Finish initial global routing..."); 
}

// After many experiments, we realize that L-shape pattern routing is very inefficient
// It consists of two parts: initial patten routing and ripup-and-reroute pattern routing
// In the initial pattern routing part, the tree topology is generated by FLUTE.
// For the colinear two-pin nets, we use segment shifting to reduce the congestion
// For the noncolinear two-pin nets, we use Z-shape pattern routing to reduce the congestion
// In the ripup-and-reroute pattern routing part, we use congestion-aware steiner point movement to adjust the tree topology
// Then segment shifting and Z-shape pattern routing are performed again
// To do list: how to adjust the history cost according to the congestion
void FlexGR::initGR_patternRoute_init_route_update()
{
  std::cout << "initSegPairVec_ size: " << initSegPairVec_.size() << std::endl;
  for (auto& pair: initSegPairVec_) {
    // noncolinear, Z-shape pattern routing
    initGR_patternRoute_ZShape_update(pair.first, pair.second);
  }
}



inline float getCongCostUtil(unsigned supply, unsigned demand)
{
  // congestion cost
  float exp_val = exp(std::min(10.0f, static_cast<float>(supply) - demand));  
  // Calculate the factor safely
  float factor = 8.0f / (1.0f + exp_val); 
  // Compute congestion cost with safety limits
  return demand * (1.0 + factor) / (supply + 1.0f);
}

float FlexGR::getGridCost2D_update(int xIdx, int yIdx, frDirEnum dir)
{
  float cost = 0;
  int zIdx = 0;
  auto supply = cmap2D_->getRawSupply(xIdx, yIdx, zIdx, dir) * congestionThresh_;
  auto demand = cmap2D_->getRawDemand(xIdx, yIdx, zIdx, dir);

  // congestion cost
  float exp_val = exp(std::min(10.0f, static_cast<float>(supply) - demand));  
  // Calculate the factor safely
  float factor = 8.0f / (1.0f + exp_val); 
  // Compute congestion cost with safety limits
  float congCost = demand * (1.0 + factor) / (supply + 1.0f);
  cost += congCost;
  
  //float exp_val = exp(std::min(5.0f, static_cast<float>(supply) - demand));
  //float factor = 8.0f * (demand / supply);
  //float congCost = demand * (1.0f + factor) / (supply + 1.0f); // Fixed denominator
  //cost += congCost;


  // blockage cost
  if (cmap2D_->hasBlock(xIdx, yIdx, zIdx, dir)) {
    cost += BLOCKCOST * 100;
  }
    
  // overflow cost
  //if (demand >= supply) {
  //  cost += 128;
  //}

  // history cost
  // History cost needs to be further tuned
  // uint32_t historyCost = cmap2D_->getHistoryCost(xIdx, yIdx, zIdx);
  // if (historyCost > 0) {
  //  cost += 0.1 * congCost * historyCost;
  //}

  //if (historyCost > 0) {
  //  logger_->info(DRT, 363, "historyCost: {}, congCost: {}, cost: {}", historyCost, congCost, cost);
  //}

  return cost;
}


// Helper function to calculate path cost 
float FlexGR::computeSegCost2D_update(int startIdx, int endIdx, int fixedIdx, frDirEnum dir) 
{
  double cost = 0;
  int minIdx = std::min(startIdx, endIdx);
  int maxIdx = std::max(startIdx, endIdx);
  for (int idx = minIdx; idx <= maxIdx; idx++) {
    int xIdx = (dir == frDirEnum::E) ? idx : fixedIdx;
    int yIdx = (dir == frDirEnum::E) ? fixedIdx : idx;
    cost += getGridCost2D_update(xIdx, yIdx, dir);
  }
  return cost;
}


float FlexGR::computeSegCost2D_update(Point bpIdx,  Point epIdx)
{
  if (bpIdx == epIdx) {
    return 0.0; // This is a single-gcell segment; no cost; this should be a VIA instead of a segment
  }
  
  if (epIdx < bpIdx) {
    std::swap(bpIdx, epIdx);
  }

  // Check if segment is horizontal or vertical
  const bool isHorizontal = (bpIdx.y() == epIdx.y());
  const bool isVertical = (bpIdx.x() == epIdx.x());

  if (!isHorizontal && !isVertical) {
    logger_->error(DRT, 283, "current node and parent node are are not aligned collinearly\n");
    return 0.0;
  }

  const int fixedIdx = isHorizontal ? bpIdx.y() : bpIdx.x();
  const int startIdx = isHorizontal ? bpIdx.x() : bpIdx.y();
  const int endIdx = isHorizontal ? epIdx.x() : epIdx.y();
  if (isHorizontal) {
    return computeSegCost2D_update(startIdx, endIdx, fixedIdx, frDirEnum::E);
  } else {
    return computeSegCost2D_update(startIdx, endIdx, fixedIdx, frDirEnum::N);
  }
}
   
  
// Compute the path cost from start point to end point
float FlexGR::computePathCost2D_update(const std::vector<Point>& points)    
{
  size_t pointCount = points.size();
  if (pointCount < 2) {
    return 0.0; // This is a single-gcell path; no cost
  }

  float cost = 0.0;
  for (size_t i = 0; i < pointCount - 1; i++) {
    cost += computeSegCost2D_update(points[i], points[i + 1]);
  } 

  return cost; 
}
  

// Helper function to update congestion map
void FlexGR::updateCong2D_update(int startIdx, int endIdx, int fixedIdx, frDirEnum dir, int netId) 
{
  int zIdx = 0;
  int minIdx = std::min(startIdx, endIdx);
  int maxIdx = std::max(startIdx, endIdx);
  if (dir == frDirEnum::E) {
    for (int idx = minIdx; idx < maxIdx; idx++) {
      cmap2D_->addRawDemand(idx, fixedIdx, zIdx, dir);
      cmap2D_->addRawDemand(idx + 1, fixedIdx, zIdx, dir);
    }

    if (netId != -1) {
      for (int idx = minIdx; idx <= maxIdx; idx++) {
        cmap2D_->addNet(idx, fixedIdx, zIdx, netId);
      }
    } else {
      std::cout << "error ! netId is -1" << std::endl;
    }   
  } else {
    for (int idx = minIdx; idx < maxIdx; idx++) {
      cmap2D_->addRawDemand(fixedIdx, idx, zIdx, dir);
      cmap2D_->addRawDemand(fixedIdx, idx + 1, zIdx, dir);
    }

    if (netId != -1) {
      for (int idx = minIdx; idx <= maxIdx; idx++) {
        cmap2D_->addNet(fixedIdx, idx, zIdx, netId);
      }
    } else {
      std::cout << "error ! netId is -1" << std::endl;
    }
  }
}

void FlexGR::updateSegCong2D_update(Point bpIdx, Point epIdx, int netId)
{
  if (bpIdx == epIdx) {
    return; // This is a single-gcell segment; no need to update
  }

  if (bpIdx.x() != epIdx.x() && bpIdx.y() != epIdx.y()) {
    logger_->error(DRT, 362, "current node and parent node are are not aligned collinearly in updateSegCong2D_update\n");
  }  

  if (bpIdx.x() == epIdx.x()) { // vertical
    updateCong2D_update(bpIdx.y(), epIdx.y(), bpIdx.x(), frDirEnum::N, netId);
  } else { // horizontal
    updateCong2D_update(bpIdx.x(), epIdx.x(), bpIdx.y(), frDirEnum::E, netId);
  } 
}

void FlexGR::updatePathCong2D_update(const std::vector<Point>& points, int netId)
{
  size_t pointCount = points.size();
  if (pointCount < 2) {
    return; // This is a single-gcell path; no need to update
  }

  for (size_t i = 0; i < pointCount - 1; i++) {
    updateSegCong2D_update(points[i], points[i + 1], netId);
  }
}


void FlexGR::createCornerNode2D_update(
  frNet* net, 
  frNode* child, 
  frNode* parent,
  const Point& cornerLoc) 
{
  auto uNode = std::make_unique<frNode>();
  uNode->setType(frNodeTypeEnum::frcSteiner);
  // Translate the gcell location to the center of the gcell
  uNode->setLoc(design_->getTopBlock()->getGCellCenter(cornerLoc));
  uNode->setLayerNum(2);  // Adjust layer number if necessary
  auto cornerNode = uNode.get();
  net->addNode(uNode); // transfer ownership

  // Maintain connectivity
  parent->removeChild(child);
  parent->addChild(cornerNode);
  cornerNode->setParent(parent);
  cornerNode->addChild(child);
  child->setParent(cornerNode);
}


void FlexGR::createPathNode2D_update(
  frNet* net,
  frNode* child, 
  frNode* parent,
  const std::vector<Point>& points)
{
  int pathLength = points.size();
  if (pathLength <= 2) {
    return; // This is a single-gcell path; no need to update
  }

  // Check the unique points in the path
  std::vector<Point> path;
  path.reserve(pathLength);
  path.push_back(points[0]);
  for (int i = 1; i < pathLength; i++) {
    if (path.back() != points[i]) {
      path.push_back(points[i]);
    }
  }

  if (path.size() <= 2) {
    return; // This is a single-gcell path; no need to update
  }

  parent->removeChild(child);
  pathLength = path.size();
  frNode* currNode = child;
  for (int i = 1; i < pathLength - 1; i++) {
    auto uNode = std::make_unique<frNode>();
    uNode->setType(frNodeTypeEnum::frcSteiner);
    uNode->setLoc(design_->getTopBlock()->getGCellCenter(path[i]));
    uNode->setLayerNum(2);  // Adjust layer number if necessary
    auto pathNode = uNode.get();
    net->addNode(uNode); // transfer ownership    
    // Maintain connectivity
    pathNode->addChild(currNode);
    currNode->setParent(pathNode); 
    currNode = pathNode;
    
    if (i == pathLength - 2) {
      parent->addChild(pathNode);
      pathNode->setParent(parent);
    }   
  }
}


void FlexGR::initGR_patternRoute_IShape_update(frNode* child, frNode* parent)
{
  const Point childLoc = design_->getTopBlock()->getGCellIdx(child->getLoc());
  const Point parentLoc = design_->getTopBlock()->getGCellIdx(parent->getLoc());
  updateSegCong2D_update(childLoc, parentLoc, child->getNet()->getNetId());
}


void FlexGR::initGR_patternRoute_LShape_update(frNode* child, frNode* parent)
{
  auto net = child->getNet();
  int netId = net->getNetId();
  const Point& childLoc = child->getLoc();
  const Point& parentLoc = parent->getLoc();
  const Point childGCellIdx = design_->getTopBlock()->getGCellIdx(childLoc);
  const Point parentGCellIdx = design_->getTopBlock()->getGCellIdx(parentLoc);
  if (childGCellIdx.x() == parentGCellIdx.x() || childGCellIdx.y() == parentGCellIdx.y()) {
    initGR_patternRoute_IShape_update(child, parent);
    return;
  }
 
  const Point corner1(childGCellIdx.x(), parentGCellIdx.y());
  const Point corner2(parentGCellIdx.x(), childGCellIdx.y());
  // Compute costs for both L-shaped routes
  float corner1Cost = computeSegCost2D_update(childGCellIdx, corner1) 
    + computeSegCost2D_update(corner1, parentGCellIdx);
  float corner2Cost = computeSegCost2D_update(childGCellIdx, corner2)
    + computeSegCost2D_update(corner2, parentGCellIdx);

  if (corner1Cost < corner2Cost) {
    createCornerNode2D_update(net, child, parent, corner1);
    // Update congestion
    updateSegCong2D_update(childGCellIdx, corner1, netId);
    updateSegCong2D_update(corner1, parentGCellIdx, netId);
  } else {
    createCornerNode2D_update(net, child, parent, corner2);
    // Update congestion
    updateSegCong2D_update(childGCellIdx, corner2, netId);
    updateSegCong2D_update(corner2, parentGCellIdx, netId);
  }
}

void FlexGR::initGR_patternRoute_ZShape_update(frNode* child, frNode* parent)
{
  auto net = child->getNet();
  const Point& childLoc = child->getLoc();
  const Point& parentLoc = parent->getLoc();
  const Point childGCellIdx = design_->getTopBlock()->getGCellIdx(childLoc);
  const Point parentGCellIdx = design_->getTopBlock()->getGCellIdx(parentLoc);
  // Check the I shape case
  if (childGCellIdx.x() == parentGCellIdx.x() || childGCellIdx.y() == parentGCellIdx.y()) {
    initGR_patternRoute_IShape_update(child, parent);
    return;
  }

  // Create the corner points
  int minX = std::min(childGCellIdx.x(), parentGCellIdx.x());
  int maxX = std::max(childGCellIdx.x(), parentGCellIdx.x());
  int minY = std::min(childGCellIdx.y(), parentGCellIdx.y());
  int maxY = std::max(childGCellIdx.y(), parentGCellIdx.y());

  if ((maxX - minX) == 1 && (maxY - minY) == 1) {
    initGR_patternRoute_LShape_update(child, parent);
    return;
  }

  std::vector<std::pair<Point, Point> > cornerPoints;  
  std::vector<float> ZPathCosts;
  
  // Create all the Z Shape
  // Horizontal first
  int xIncr = (childGCellIdx.x() < parentGCellIdx.x()) ? 1 : -1;
  for (int x = childGCellIdx.x(); x != parentGCellIdx.x(); x += xIncr) {
    Point p1 = Point(x, childGCellIdx.y());
    Point p2 = Point(x, parentGCellIdx.y());
    cornerPoints.emplace_back(p1, p2);
  }

  // Vertical first
  int yIncr = (childGCellIdx.y() < parentGCellIdx.y()) ? 1 : -1;
  for (int y = childGCellIdx.y(); y != parentGCellIdx.y(); y += yIncr) {
    Point p1 = Point(childGCellIdx.x(), y);
    Point p2 = Point(parentGCellIdx.x(), y);
    cornerPoints.emplace_back(p1, p2);
  }

  // add two more corner points
  Point corner1(childGCellIdx.x(), parentGCellIdx.y());
  Point corner2(parentGCellIdx.x(), childGCellIdx.y());
  cornerPoints.emplace_back(corner1, corner1);
  cornerPoints.emplace_back(corner2, corner2);

  // Compute costs for all corner points
  ZPathCosts.reserve(cornerPoints.size());
  std::vector<Point> path;
  path.resize(4);
  path[0] = childGCellIdx;
  path[3] = parentGCellIdx;  
  for (auto& corner : cornerPoints) {
    path[1] = corner.first;
    path[2] = corner.second;
    ZPathCosts.push_back(computePathCost2D_update(path));
  }

  // Pick the corner with the lowest cost
  auto minCostIter = std::min_element(ZPathCosts.begin(), ZPathCosts.end());
  int minCostIdx = std::distance(ZPathCosts.begin(), minCostIter);
  path[1] = cornerPoints[minCostIdx].first;
  path[2] = cornerPoints[minCostIdx].second;
  
  // update congestion
  updatePathCong2D_update(path, net->getNetId());
  createPathNode2D_update(net, child, parent, path);
}


void FlexGR::initGR_patternRoute_Segment_Shift_update(frNode* child, frNode* parent)
{
  auto net = child->getNet();
  const Point& childLoc = child->getLoc();
  const Point& parentLoc = parent->getLoc();
  const Point childGCellIdx = design_->getTopBlock()->getGCellIdx(childLoc);
  const Point parentGCellIdx = design_->getTopBlock()->getGCellIdx(parentLoc);
  // Check the I shape case
  if (childGCellIdx.x() != parentGCellIdx.x() && childGCellIdx.y() != parentGCellIdx.y()) {
    // noncolinear,
    logger_->error(DRT, 285, "current node and parent node are are not aligned collinearly in initGR_patternRoute_Segment_Shift_update\n");
    return;
  }

  if (childGCellIdx.x() == parentGCellIdx.x() && childGCellIdx.y() == parentGCellIdx.y()) {
    logger_->report("[INFO][FlexGR] ChildLoc = ({}, {}), ParentLoc = ({}, {})", childGCellIdx.x(), childGCellIdx.y(), parentGCellIdx.x(), parentGCellIdx.y());
    logger_->error(DRT, 368, "current node and parent node are the same in initGR_patternRoute_Segment_Shift_update");
    return;
  }


  // Create the corner points
  int minX = std::min(childGCellIdx.x(), parentGCellIdx.x());
  int maxX = std::max(childGCellIdx.x(), parentGCellIdx.x());
  int minY = std::min(childGCellIdx.y(), parentGCellIdx.y());
  int maxY = std::max(childGCellIdx.y(), parentGCellIdx.y());

  std::vector<std::pair<Point, Point> > cornerPoints;  
  int relaxStep = relaxStep_;
  if (maxX - minX <= 2 || maxY - minY <= 2) {
    relaxStep = relaxStep_ * 5;
  }

  if (minX == maxX) { // vertical
    int xStart = std::max(minX - relaxStep, 0);
    int xEnd = std::min(maxX + relaxStep, xDim_ - 1);
    for (int x = xStart; x <= xEnd; x++) {
      Point p1 = Point(x, childGCellIdx.y());
      Point p2 = Point(x, parentGCellIdx.y());
      cornerPoints.emplace_back(p1, p2);
    }
  } else { // horizontal
    int yStart = std::max(minY - relaxStep, 0);
    int yEnd = std::min(maxY + relaxStep, yDim_ - 1);
    for (int y = yStart; y <= yEnd; y++) {
      Point p1 = Point(childGCellIdx.x(), y);
      Point p2 = Point(parentGCellIdx.x(), y);
      cornerPoints.emplace_back(p1, p2);
    }
  }   

  std::vector<float> CPathCosts;
  // Compute costs for all corner points
  CPathCosts.reserve(cornerPoints.size());
  std::vector<Point> path;
  path.resize(4);
  path[0] = childGCellIdx;
  path[3] = parentGCellIdx;  
  for (auto& corner : cornerPoints) {
    path[1] = corner.first;
    path[2] = corner.second;
    CPathCosts.push_back(computePathCost2D_update(path));
  }

  // Pick the corner with the lowest cost
  auto minCostIter = std::min_element(CPathCosts.begin(), CPathCosts.end());
  int minCostIdx = std::distance(CPathCosts.begin(), minCostIter);
  path[1] = cornerPoints[minCostIdx].first;
  path[2] = cornerPoints[minCostIdx].second;

  float newCost = computePathCost2D_update(path);
  path[1] = childGCellIdx;
  path[2] = parentGCellIdx;
  float oldCost = computePathCost2D_update(path);
  if (newCost >= oldCost) {
    segmentShitfFailCnt_++;
  }

  // update congestion
  updatePathCong2D_update(path, net->getNetId());
  createPathNode2D_update(net, child, parent, path);
}


void FlexGR::initGR_patternRoute_ripup_and_reroute_update()
{
  // Get the nets that need to be rerouted
  std::set<int> nets2RR;
  for (int yIdx = 0; yIdx < yDim_; yIdx++) {
    for (int xIdx = 0; xIdx < xDim_; xIdx++) {
      auto supplyH = cmap2D_->getSupply(xIdx, yIdx, 0, frDirEnum::E);
      auto supplyV = cmap2D_->getSupply(xIdx, yIdx, 0, frDirEnum::N);
      auto demandH = cmap2D_->getDemand(xIdx, yIdx, 0, frDirEnum::E);
      auto demandV = cmap2D_->getDemand(xIdx, yIdx, 0, frDirEnum::N);
      // Reroute more nets if the congestion is higher
      if (demandH > supplyH * congestionThresh_ || demandV > supplyV * congestionThresh_) {
        for (auto netId : cmap2D_->getNets(xIdx, yIdx, 0)) {
          nets2RR.insert(netId);
        }
      }
    }
  }

  logger_->report("[INFO][FlexGR] Number of nets to be rerouted: {}", nets2RR.size());  
  initGR_decayHistCost2D_update();
  initGR_addHistCost2D_update();
  
  // Try to reroute the nets
  std::vector<std::pair<frNode*, frNode*> > segmentShiftPairs;
  segmentShiftPairs.reserve(nets2RR.size() * 10);
  std::vector<std::pair<frNode*, frNode*> > patternRoutePairs;
  patternRoutePairs.reserve(nets2RR.size() * 10);
  
  std::function<frNode*(frNode*)> addNodeToQueue = [&](frNode* node) -> frNode* {
    // Check if the node should not move
    if (node == nullptr || node->isDontMove()) {
      return node;
    }

    auto nodeLoc = design_->getTopBlock()->getGCellIdx(node->getLoc());
    //std::cout << "nodeLoc = " << nodeLoc.x() << ", " << nodeLoc.y() << std::endl;

    // Handle Steiner node case
    if (node->getType() == frNodeTypeEnum::frcSteiner) {
      int numChildSteinerNodes = 0;
      frNode* childNode = nullptr;

      // Count child Steiner nodes and stop early if more than 1
      for (const auto& child : node->getChildren()) {
        if (child->getType() == frNodeTypeEnum::frcSteiner) {
          numChildSteinerNodes++;
          childNode = child;
          if (numChildSteinerNodes > 1) { break; } // No need to continue if more than 1 child Steiner node
        }
      }

      // If exactly one Steiner child node, recursively call the function
      if (numChildSteinerNodes == 1) { 
        return addNodeToQueue(childNode); 
      }
      
      // Otherwise, return the current node
      return node;
    }

    // Default case
    return nullptr;
  };

  for (auto netId : nets2RR) {
    auto net = nets_[netId];
    auto rootNode = net->getRootGCellNode();
    std::queue<frNode*> queue;
    queue.push(rootNode);
    while (!queue.empty()) {
      auto node = queue.front();
      queue.pop();
      if (node == nullptr) { continue; }
      auto nodeLoc = node->getLoc();
      // Update the loop
      std::vector<frNode*> children;
      for (auto& child : node->getChildren()) {
        if (child->getType() == frNodeTypeEnum::frcSteiner) {
          children.push_back(child);
        }
      }

      auto nodeGCellLoc = design_->getTopBlock()->getGCellIdx(nodeLoc);
      //std::cout << "nodeGCellLoc = " << nodeGCellLoc.x() << ", " << nodeGCellLoc.y() << std::endl;      

      // Detect the loop and handle it
      for (auto& child : children) {
        auto nextNode = addNodeToQueue(child);
        auto nextNodeLoc = nextNode->getLoc();        
        if (nextNodeLoc.x() == nodeLoc.x() && nextNodeLoc.y() == nodeLoc.y()) {
          // remove the identified loop
          // I want to remove the loop here
          for (auto& subChild : nextNode->getChildren()) {
            subChild->setParent(node);
            node->addChild(subChild);
          }

          // remove the node until the node
          if (nextNode->isDontMove() == true) {
            node->setDontMove();
          }

          auto nextGCellLoc = design_->getTopBlock()->getGCellIdx(nextNode->getLoc());
          std::cout << "nextGCellLoc = " << nextGCellLoc.x() << ", " << nextGCellLoc.y() << std::endl;
          auto childLoc = design_->getTopBlock()->getGCellIdx(child->getLoc());
          std::cout << "enter here (b)" << std::endl;
          if (nextNode->getChildren().empty() == false) {
            std::cout << "Test (b) nodeGCellLoc = " << nodeGCellLoc.x() << ", " << nodeGCellLoc.y() << "  "
                      << "nextGCellLoc = " << nextGCellLoc.x() << ", " << nextGCellLoc.y() << "  "
                      << "childLoc = " << childLoc.x() << ", " << childLoc.y() << std::endl;
            auto newNode = nextNode;
            auto startNode = nextNode;
            while (newNode != node) {
              auto testLoc = design_->getTopBlock()->getGCellIdx(newNode->getLoc());
              std::cout << "Test (b) : " << testLoc.x() << ", " << testLoc.y() << std::endl;
              auto parent = newNode->getParent();
              initGR_ripupRoute_update(newNode, parent);
              if (newNode->getParent() == node) { node->removeChild(newNode); }  
              if (newNode != startNode) { net->removeNode(newNode); }
              newNode = parent;
            }
          }
          std::cout << "exit here (b)" << std::endl;
        }
      }
      
      for (auto child : node->getChildren()) {
        if (child->getType() == frNodeTypeEnum::frcSteiner) {
          auto nextNode = addNodeToQueue(child);
          if (nextNode == nullptr) { 
            logger_->error(DRT, 370, "nextNode is nullptr in initGR_patternRoute_ripup_and_reroute_update\n");
          }
          
          auto nextGCellLoc = design_->getTopBlock()->getGCellIdx(nextNode->getLoc());
          //std::cout << "nextGCellLoc = " << nextGCellLoc.x() << ", " << nextGCellLoc.y() << std::endl;
        
          auto nextNodeLoc = nextNode->getLoc();
          if (nextNodeLoc.x() != nodeLoc.x() && nextNodeLoc.y() != nodeLoc.y()) {
            queue.push(nextNode); 
            patternRoutePairs.emplace_back(nextNode, node);
          } else { // segment shifting
            if (nextNodeLoc.x() == nodeLoc.x() && nextNodeLoc.y() == nodeLoc.y()) {
              // remove the identified loop
              // I want to remove the loop here
              for (auto& child : nextNode->getChildren()) {
                child->setParent(node);
                node->addChild(child);
              }

              // remove the node until the node
              if (nextNode->isDontMove() == true) {
                node->setDontMove();
              }
              std::cout << "enter here" << std::endl;
              if (nextNode->getChildren().empty() == false) {
                auto newNode = nextNode->getChildren().front();
                while (newNode != node) {
                  auto testLoc = design_->getTopBlock()->getGCellIdx(newNode->getLoc());
                  std::cout << "Test : " << testLoc.x() << ", " << testLoc.y() << std::endl;
                  auto parent = newNode->getParent();
                  initGR_ripupRoute_update(newNode, parent);
                  net->removeNode(newNode);
                  newNode = parent;
                }
              }
              std::cout << "exit here" << std::endl;
            } else {
              segmentShiftPairs.emplace_back(nextNode, node);
              queue.push(nextNode); 
            }
          }
        }
      }
    }
  }

  logger_->report("[INFO][FlexGR] Number of effective segments for pattern routing: {}", patternRoutePairs.size());
  logger_->report("[INFO][FlexGR] Number of effective segments for shifting: {}", segmentShiftPairs.size());
  logger_->report("[INFO][FlexGR] Start rerouting...");
  // The main function for rerouting
  initGR_patternRoute_reroute_update(segmentShiftPairs, 2);
  logger_->report("[INFO][FlexGR] Finish segment shifting...");
  initGR_patternRoute_reroute_update(patternRoutePairs, 1);
  logger_->report("[INFO][FlexGR] Finish pattern routing...");
}

// The main function for pattern routing
void FlexGR::initGR_patternRoute_reroute_update(
  std::vector<std::pair<frNode*, frNode*> >& patternRoutes,
  int mode)  
{
  segmentShitfFailCnt_ = 0;
  for (auto& patternRoute : patternRoutes) {
    auto startNode = patternRoute.first;
    auto endNode = patternRoute.second;
    auto net = startNode->getNet();
    auto currNode = startNode;
    while (currNode != endNode) {
      initGR_ripupRoute_update(currNode, currNode->getParent());
      // remove from endNode if parent is endNode
      if (currNode->getParent() == endNode) { endNode->removeChild(currNode); }  
      if (currNode != startNode && currNode != endNode) { net->removeNode(currNode); }
      currNode = currNode->getParent();
    }
    
    // restore connection from start node to end node
    startNode->setParent(endNode);
    endNode->addChild(startNode);
     
    switch(mode) {
      case 1:
        initGR_patternRoute_ZShape_update(startNode, endNode);
        break;
      case 2:
        initGR_patternRoute_Segment_Shift_update(startNode, endNode);
        break;
      default:
        logger_->error(DRT, 264, "Invalid mode for pattern routing\n");
    }
  }

  if (mode == 2) {
    logger_->report("[INFO][FlexGR] Number of segments shifted: {} ({} %)", segmentShitfFailCnt_, 
      100.0 * segmentShitfFailCnt_ / patternRoutes.size());
  }
}

void FlexGR::initGR_patternRoute_adjust_topology_update()
{
  // Get the nets that need to be rerouted
  std::set<int> nets2RR;
  for (int yIdx = 0; yIdx < yDim_; yIdx++) {
    for (int xIdx = 0; xIdx < xDim_; xIdx++) {
      auto supplyH = cmap2D_->getSupply(xIdx, yIdx, 0, frDirEnum::E);
      auto supplyV = cmap2D_->getSupply(xIdx, yIdx, 0, frDirEnum::N);
      auto demandH = cmap2D_->getDemand(xIdx, yIdx, 0, frDirEnum::E);
      auto demandV = cmap2D_->getDemand(xIdx, yIdx, 0, frDirEnum::N);
      // Reroute more nets if the congestion is higher
      if (demandH > supplyH * congestionThresh_ || demandV > supplyV * congestionThresh_) {
        for (auto netId : cmap2D_->getNets(xIdx, yIdx, 0)) {
          nets2RR.insert(netId);
        }
      }
    }
  }





  logger_->report("[INFO][FlexGR] Number of nets to be adjusted: {}", nets2RR.size());  
  initGR_decayHistCost2D_update();
  initGR_addHistCost2D_update();

  std::vector<frNet*> nets2RRVec;
  nets2RRVec.reserve(nets2RR.size());
  for (auto netId : nets2RR) {
    // Check if the net can be adjusted
    bool canAdjust = false;
    for (auto& node : nets_[netId]->getNodes()) {
      if (node->getType() == frNodeTypeEnum::frcSteiner) {
        if (!(node->isDontMove())) {
          canAdjust = true;
          break;
        }
      }
    }

    if (canAdjust) {  
      nets2RRVec.push_back(nets_[netId]);
    }
  }

  logger_->report("[INFO][FlexGR] Number of nets passing through congested GCells: {}", nets2RR.size());
  logger_->report("[INFO][FlexGR] Number of nets to be adjusted: {} ( {} %)", 
    nets2RRVec.size(), 
    100.0 * nets2RRVec.size() / nets2RR.size());

  RRR_SteinerTreeShift(nets2RRVec);
  logger_->report("[INFO][FlexGR] Finish adjusting the tree topology...");
}


// child node and parent node must be colinear
void FlexGR::initGR_ripupRoute_update(frNode* child, frNode* parent)
{
  Point bpIdx = design_->getTopBlock()->getGCellIdx(child->getLoc());
  Point epIdx = design_->getTopBlock()->getGCellIdx(parent->getLoc());
  if (epIdx < bpIdx) {
    std::swap(bpIdx, epIdx);
  }

  // Check if segment is horizontal or vertical
  const bool isHorizontal = (bpIdx.y() == epIdx.y());
  const bool isVertical = (bpIdx.x() == epIdx.x());
  if (!isHorizontal && !isVertical) {
    logger_->report("[ERROR][FlexGR] Error: non-colinear segment found in initGR_ripupRoute_update\n");
    return;
  }

  // Determine the direction for checking overflow
  const frDirEnum direction = isHorizontal ? frDirEnum::E : frDirEnum::N;
  const int fixedIdx = isHorizontal ? bpIdx.y() : bpIdx.x();
  const int startIdx = isHorizontal ? bpIdx.x() : bpIdx.y();
  const int endIdx = isHorizontal ? epIdx.x() : epIdx.y();

  // Loop through the range to check for overflow
  if (isHorizontal) {
    for (int idx = startIdx; idx <= endIdx; ++idx) {
      cmap2D_->subRawDemand(idx, fixedIdx, 0, direction);
      cmap2D_->subRawDemand(idx + 1, fixedIdx, 0, direction);
    }
    for (int idx = startIdx + 1; idx < endIdx; ++idx) {
      cmap2D_->removeNet(idx, fixedIdx, 0, child->getNet()->getNetId());
    }
  } else {
    for (int idx = startIdx; idx <= endIdx; ++idx) {
      cmap2D_->subRawDemand(fixedIdx, idx, 0, direction);
      cmap2D_->subRawDemand(fixedIdx, idx + 1, 0, direction);
    }
    for (int idx = startIdx + 1; idx < endIdx; ++idx) {
      cmap2D_->removeNet(fixedIdx, idx, 0, child->getNet()->getNetId());
    }
  }
}


// Since the topology is generated by FLUTE,
// there will be non-colinear route need to be pattern routed
void FlexGR::initGR_patternRoute_update()
{
  std::vector<std::pair<frNode*, frNode*> > patternRoutes;  // <childNode, parentNode>, ripup cnt
  std::vector<std::pair<frNode*, frNode*> > ripupRoutes; // for segment shifting

  patternRoutes.reserve(nets_.size() * 100);
  ripupRoutes.reserve(nets_.size() * 100);

  // init
  initGR_patternRoute_init_update(patternRoutes, ripupRoutes);
  
  // route
  logger_->report("[INFO][FlexGR] Start pattern routing...");
  logger_->report("[INFO][FlexGR] Number of effective segments for pattern routing: {}", patternRoutes.size());
  logger_->report("[INFO][FlexGR] Number of effective segments for ripup and reroute: {}", ripupRoutes.size());  

  std::cout << "After flute check" << std::endl;

  checkValidNet_update();
  std::cout << "finish check valid net" << std::endl;

  // Initial Pattern Routing, Z-Shape-Based, 
  initGR_patternRoute_route_update(patternRoutes, 0, 1 /*Z-Shape*/);
  std::cout << "finish (trial) Z-Shape" << std::endl;
  checkValidNet_update();

 

  // Add decay history based approach
  // Then perform Z-Shape and Segment Shifting 
  for (int iter = 1; iter < 3; iter++) {
    initGR_decayHistCost2D_update();
    initGR_addHistCost2D_update();
    
    std::cout << "iter: " << iter << std::endl;
    
    initGR_patternRoute_route_update(patternRoutes, iter, 1 /*Z-Shape*/);
    std::cout << "finish Z-Shape" << std::endl;
    report2DCongestionMap_update(cmap2D_.get());
    detectNonLinearSegment_update();
    checkValidNet_update();
      
    initGR_RRR_bend_route_update(ripupRoutes);
    std::cout << "finish segment shifting" << std::endl;
    report2DCongestionMap_update(cmap2D_.get());
    detectNonLinearSegment_update();
    checkValidNet_update();
  }


  initGR_decayHistCost2D_update();
  initGR_addHistCost2D_update();
  // Then perform Steiner Point Movement
  std::vector<frNet*> nets2RR;
  getRipupRerouteNets_update(nets2RR);
  checkValidNet_update();
  RRR_SteinerTreeShift(nets2RR);
  checkValidNet_update();

  std::cout << "ReExtract the pattern routing" << std::endl;

  initGR_patternRoute_init_update(patternRoutes, ripupRoutes);

  initGR_patternRoute_route_update(patternRoutes, 1, 1 /*Z-Shape*/); 
  std::cout << "finish Z-Shape" << std::endl;

  //removeLoop();
  //std::cout << "perform 3-bend routing" << std::endl;
  //initGR_patternRoute_route_update(patternRoutes, 1, 2 /*3-Bend*/);
  //detectNonLinearSegment_update();
  //report2DCongestionMap_update(cmap2D_.get());

  std::cout << "after remove loop" << std::endl;

  // Perform Z-Shape and Segment Shifting
  for (int iter = 1; iter < 3; iter++) {
    initGR_decayHistCost2D_update();
    initGR_addHistCost2D_update();
    
    std::cout << "iter: " << iter << std::endl;

    /*
    getRipupRerouteNets_update(nets2RR);
    checkValidNet_update();
    RRR_SteinerTreeShift(nets2RR);
    checkValidNet_update();

    std::cout << "finish segment shifting" << std::endl;

    report2DCongestionMap_update(cmap2D_.get());
    detectNonLinearSegment_update(); 
    */

    initGR_patternRoute_route_update(patternRoutes, iter, 1 /*Z-Shape*/); 
    std::cout << "finish Z-Shape" << std::endl;

    report2DCongestionMap_update(cmap2D_.get());
    detectNonLinearSegment_update(); 

    initGR_RRR_bend_route_update(ripupRoutes);

    std::cout << "finish segment shifting" << std::endl;

    report2DCongestionMap_update(cmap2D_.get());
    detectNonLinearSegment_update();
  }

  // Perform 3-Bend Routing
  initGR_decayHistCost2D_update();
  initGR_addHistCost2D_update();

  std::cout << "Perform segment-level ripup-and-reroute" << std::endl;
  // Perform segment level ripup-and-reroute
  //getRipupRerouteNets_update(nets2RR);
  //checkValidNet_update();
  std::cout << "number of nets to be ripup and reroute: " << nets2RR.size() << std::endl;

  //initGR_patternRoute_route_update(patternRoutes, 1, 2 /*3-Bend*/);

  //detectNonLinearSegment_update();
  //report2DCongestionMap_update(cmap2D_.get());

  //std::cout << "finish 3-bend routing" << std::endl;

  //initGR_decayHistCost2D_update();
  //initGR_addHistCost2D_update();
  //initGR_RRR_bend_route_update(ripupRoutes);

  std::cout << "finish segment shifting" << std::endl;

  report2DCongestionMap_update(cmap2D_.get());
  detectNonLinearSegment_update();

  //initGR_patternRoute_route_update(patternRoutes, 1, 2 /*3-Bend*/);
  //removeLoop();
  logger_->report("[INFO][FlexGR] Finish initial pattern routing...\n");  
  //exit(1);
}


// Detect the nonlinear segment in the net
void FlexGR::detectNonLinearSegment_update()
{
  for (auto& net : nets_) {
    auto iter = net->getFirstNonRPinNode()->getIter();
    while (iter != net->getNodes().end()) {
      auto node = iter->get();
      auto parentNode = node->getParent();
      if (parentNode == nullptr) {
        iter++;
        continue;
      }

      if (node->getType() != frNodeTypeEnum::frcSteiner
          || parentNode->getType() != frNodeTypeEnum::frcSteiner) {
        iter++;
        continue;
      }

      Point loc = node->getLoc();
      Point parentLoc = parentNode->getLoc();
      if (loc.x() == parentLoc.x() || loc.y() == parentLoc.y()) {
        iter++;
        continue;
      }

      std::cout << "nonlinear segment found: " << " "
                << "child : " << loc.x() << " " << loc.y() << " "
                << "parent : " << parentLoc.x() << " " << parentLoc.y() << " "
                << std::endl;
    }
  }
}



// Identify the non-colinear route that need to be pattern routed
void FlexGR::initGR_patternRoute_init_update(
  std::vector<std::pair<frNode*, frNode*> >& patternRoutes,
  std::vector<std::pair<frNode*, frNode*> >& ripupRoutes)
{
  patternRoutes.clear();
  ripupRoutes.clear();
  
  for (auto& net : nets_) {
    auto iter = net->getFirstNonRPinNode()->getIter();
    while (iter != net->getNodes().end()) {
      auto node = iter->get();
      auto parentNode = node->getParent();
      if (parentNode == nullptr) {
        iter++;
        continue;
      }

      if (node->getType() != frNodeTypeEnum::frcSteiner
          || parentNode->getType() != frNodeTypeEnum::frcSteiner) {
        iter++;
        continue;
      }

      Point loc = node->getLoc();
      Point parentLoc = parentNode->getLoc();
      if (loc.x() == parentLoc.x() || loc.y() == parentLoc.y()) {
        ripupRoutes.emplace_back(std::make_pair(node, parentNode));
        iter++;
        continue;
      }

      patternRoutes.emplace_back(std::make_pair(node, parentNode));
      iter++;
    }    
  }
}


// The main function for pattern routing
void FlexGR::initGR_patternRoute_route_update(
  std::vector<std::pair<frNode*, frNode*> >& patternRoutes,
  int iter, int mode)  
{
  if (mode == 2) {
    overflowBendThresh_ = 4.0;
  } 

  int numTrueNet = 0;

  bool doRoute = false;
  for (auto& patternRoute : patternRoutes) {
    auto startNode = patternRoute.first;
    auto endNode = patternRoute.second;
    auto net = startNode->getNet();
    doRoute = (iter == 0); // the route has not been routed yet
    if (doRoute == false) { // check overflow along the path
      auto currNode = startNode;
      while (currNode != endNode) {
        if (initGR_hasOverflow2D_update(currNode, currNode->getParent())) {
          doRoute = true;
          break;
        }
        currNode = currNode->getParent();
      }
    }
    
    if (doRoute) {
      // ripup pattern routed wire and update congestion map
      if (iter > 0) {
        auto currNode = startNode;
        while (currNode != endNode) {
          initGR_ripupRoute_update(currNode, currNode->getParent());
          // remove from endNode if parent is endNode
          if (currNode->getParent() == endNode) {
            endNode->removeChild(currNode);
          }
          if (currNode != startNode && currNode != endNode) {
            net->removeNode(currNode);
          }
          currNode = currNode->getParent();
        }
        // restore connection from start node to end node
        startNode->setParent(endNode);
        endNode->addChild(startNode);
      }

      numTrueNet++;  

      checkInvalidLoop(startNode->getNet(), 
        std::string("before L Shape routing"));

      switch(mode) {
        case 0:
          initGR_patternRoute_LShape_update(startNode, endNode);
          break;
        case 1:
          initGR_patternRoute_ZShape_update(startNode, endNode);
          break;
        case 2:
          initGR_patternRoute_BendShape_update(startNode, endNode);
          break;
        default:
          logger_->error(DRT, 288, "Invalid mode for pattern routing\n");
      }

      checkInvalidLoop(startNode->getNet(), 
        std::string("after L Shape routing"));
    }
  }

  std::cout << "numTrueNet: " << numTrueNet << std::endl;

  if (mode == 2) {
    overflowBendThresh_ = 1.0;
  }
}


// Define the utility functions for pattern routing
// We set the decay factor to 0.8
void FlexGR::initGR_decayHistCost2D_update()
{
  int zIdx = 0;
  for (int xIdx = 0; xIdx < xDim_; xIdx++) {
    for (int yIdx = 0; yIdx < yDim_; yIdx++) {
      cmap2D_->decayHistoryCost(xIdx, yIdx, zIdx, 0.8);
    }
  }
}


// Set the history cost
void FlexGR::initGR_addHistCost2D_update()
{
  int zIdx = 0;
  for (int xIdx = 0; xIdx < xDim_; xIdx++) {
    for (int yIdx = 0; yIdx < yDim_; yIdx++) {
      auto supplyE = cmap2D_->getSupply(xIdx, yIdx, zIdx, frDirEnum::E) * congestionThresh_;
      auto supplyN = cmap2D_->getSupply(xIdx, yIdx, zIdx, frDirEnum::N) * congestionThresh_;
      auto demandE = cmap2D_->getDemand(xIdx, yIdx, zIdx, frDirEnum::E);
      auto demandN = cmap2D_->getDemand(xIdx, yIdx, zIdx, frDirEnum::N);
      if (demandE > supplyE || demandN > supplyN) {
        auto histCost = std::max(getCongCostUtil(supplyE, demandE), getCongCostUtil(supplyN, demandN));      
        cmap2D_->addHistoryCost(xIdx, yIdx, zIdx, histCost );
      }
    }
  }
}

// child node and parent node must be colinear
bool FlexGR::initGR_hasOverflow2D_update(frNode* child, frNode* parent)
{
  Point bpIdx = design_->getTopBlock()->getGCellIdx(child->getLoc());
  Point epIdx = design_->getTopBlock()->getGCellIdx(parent->getLoc());
  if (epIdx < bpIdx) {
    std::swap(bpIdx, epIdx);
  }

  // Check if segment is horizontal or vertical
  const bool isHorizontal = (bpIdx.y() == epIdx.y());
  const bool isVertical = (bpIdx.x() == epIdx.x());

  if (!isHorizontal && !isVertical) {
    logger_->error(DRT, 359, "Error: non-colinear segment found in initGR_hasOverflow2D_update\n");
    return false; // To handle unexpected non-colinear segments gracefully
  }

  // Determine the direction for checking overflow
  const frDirEnum direction = isHorizontal ? frDirEnum::E : frDirEnum::N;
  const int fixedIdx = isHorizontal ? bpIdx.y() : bpIdx.x();
  const int startIdx = isHorizontal ? bpIdx.x() : bpIdx.y();
  const int endIdx = isHorizontal ? epIdx.x() : epIdx.y();

  // Loop through the range to check for overflow
  for (int idx = startIdx; idx <= endIdx; ++idx) {
    if (isHorizontal) { // horizontal
      if (isOverflow2D_update(idx, fixedIdx, direction)) {
        return true;
      }
    } else { // vertical
      if (isOverflow2D_update(fixedIdx, idx, direction)) {
        return true;
      }
    }
  }

  return false;
}






float FlexGR::getOverflow2D_update(int x, int y)
{
  int demandE = cmap2D_->getDemand(x, y, 0, frDirEnum::E);
  int supplyE = cmap2D_->getSupply(x, y, 0, frDirEnum::E);
  int demandN = cmap2D_->getDemand(x, y, 0, frDirEnum::N);
  int supplyN = cmap2D_->getSupply(x, y, 0, frDirEnum::N);
  return ((demandE * 100.0 / supplyE) + (demandN * 100.0 / supplyN)) / 2.0;
}


void FlexGR::determineExtendBBox2D_update(int xMin, int yMin, int xMax, int yMax)
{
  int totalOverflow = 0;
  int totalGCellCnt = 0;

  for (int y = yMin; y <= yMax; y++) {
    for (int x = xMin; x <= xMax; x++) {
      totalGCellCnt++;
      totalOverflow += getOverflow2D_update(x, y);
    }
  }

  int incr = 0;
  int xBound, yBound, zBound;
  cmap2D_->getDim(xBound, yBound, zBound);

  while (totalOverflow / totalGCellCnt > overflowThresh_ && incr < maxIncrBBox_) {
    // Expand the bounding box
    int lx = std::max(0, xMin - 1);
    int ux = std::min(xBound - 1, xMax + 1);
    int ly = std::max(0, yMin - 1);
    int uy = std::min(yBound - 1, yMax + 1);

    // Vertical expansion
    if (lx != xMin) {
      for (int y = yMin; y <= yMax; y++) {
        totalGCellCnt++;
        totalOverflow += getOverflow2D_update(lx, y);
      }
    }

    if (ux != xMax) {
      for (int y = yMin; y <= yMax; y++) {
        totalGCellCnt++;
        totalOverflow += getOverflow2D_update(ux, y);
      }
    }

    // Horizontal expansion
    if (ly != yMin) {
      for (int x = xMin; x <= xMax; x++) {
        totalGCellCnt++;
        totalOverflow += getOverflow2D_update(x, ly);
      }
    }

    if (uy != yMax) {
      for (int x = xMin; x <= xMax; x++) {
        totalGCellCnt++;
        totalOverflow += getOverflow2D_update(x, uy);
      }
    }

    // Diagonal expansion (avoid double counting)
    if (lx != xMin && ly != yMin) {
      totalGCellCnt++;
      totalOverflow += getOverflow2D_update(lx, ly);
    }

    if (lx != xMin && uy != yMax) {
      totalGCellCnt++;
      totalOverflow += getOverflow2D_update(lx, uy);
    }


    if (ux != xMax && ly != yMin) {
      totalGCellCnt++;
      totalOverflow += getOverflow2D_update(ux, ly);
    }

    if (ux != xMax && uy != yMax) {
      totalGCellCnt++;
      totalOverflow += getOverflow2D_update(ux, uy);
    }

    incr++; 
    xMin = lx;
    xMax = ux;
    yMin = ly;
    yMax = uy; 
  }  
}

// This is only for segment shifting
void FlexGR::initGR_patternRoute_BendShape_update(frNode* child, frNode* parent)
{
  auto net = child->getNet();
  const Point& childLoc = child->getLoc();
  const Point& parentLoc = parent->getLoc();
  const Point childGCellIdx = design_->getTopBlock()->getGCellIdx(childLoc);
  const Point parentGCellIdx = design_->getTopBlock()->getGCellIdx(parentLoc);

  // Determine the expanded bounding box
  int minX = std::min(childGCellIdx.x(), parentGCellIdx.x());
  int maxX = std::max(childGCellIdx.x(), parentGCellIdx.x());
  int minY = std::min(childGCellIdx.y(), parentGCellIdx.y());
  int maxY = std::max(childGCellIdx.y(), parentGCellIdx.y());
  determineExtendBBox2D_update(minX, minY, maxX, maxY);
 
  
  std::vector<Point> terminals;
  terminals.resize(5);
  terminals[0] = childGCellIdx;
  terminals[4] = parentGCellIdx;
  auto updateBendPoints_lambda = [&](const Point& cornerGCellIdx, 
    int bendType, Point& bend_1, Point& bend_2) {    
    switch (bendType) {
      case 0:
        bend_1 = Point(childGCellIdx.x(), cornerGCellIdx.y());
        bend_2 = Point(cornerGCellIdx.x(), parentGCellIdx.y());
        break;
      case 1:
        bend_1 = Point(childGCellIdx.x(), cornerGCellIdx.y());
        bend_2 = Point(parentGCellIdx.x(), cornerGCellIdx.y()); 
        break;
      case 2:
        bend_1 = Point(cornerGCellIdx.x(), childGCellIdx.y());
        bend_2 = Point(cornerGCellIdx.x(), parentGCellIdx.y());
        break;
      case 3: 
        bend_1 = Point(cornerGCellIdx.x(), childGCellIdx.y());
        bend_2 = Point(parentGCellIdx.x(), cornerGCellIdx.y());
        break;
      default:
        logger_->error(DRT, 284, "Invalid bend type for bend shape routing\n");  
    }
  };


  auto computeBendCost_lambda = [&](
    const Point& childGCellIdx,
    const Point& parentGCellIdx,
    const Point& cornerGCellIdx,
    int bendType) -> double {

    Point& bend_1 = terminals[1];    
    Point& bend_2 = terminals[3];
    terminals[2] = cornerGCellIdx;
   
    updateBendPoints_lambda(cornerGCellIdx, bendType, bend_1, bend_2);

    return computePathCost2D_update(terminals);
  };


  // Create the corner points
  // With L shape routing for each point
  int numPossibleCorners = (maxX - minX + 1) * (maxY - minY + 1);
  std::vector<float> cornerCosts(numPossibleCorners * 4, 0.0);
  int numComb = 4;
  int idx = 0;

  for (int y = minY; y <= maxY; y++) {
    for (int x = minX; x <= maxX; x++) {
      for (int i = 0; i < numComb; i++) {
        Point cornerGCellIdx = Point(x, y);
        cornerCosts[idx++] = computeBendCost_lambda(childGCellIdx, parentGCellIdx, cornerGCellIdx, i);
      }
    }
  }


  auto minCostIter = std::min_element(cornerCosts.begin(), cornerCosts.end());
  int minCostIdx = std::distance(cornerCosts.begin(), minCostIter);
 
  if (childGCellIdx.x() == parentGCellIdx.x() || childGCellIdx.y() == parentGCellIdx.y()) {    
    // Check the original cost
    float originalCost = computeSegCost2D_update(childGCellIdx, parentGCellIdx);
    if (*minCostIter >= originalCost) {
      updateSegCong2D_update(childGCellIdx, parentGCellIdx, net->getNetId());  
      return;
    }
  }

  int cornerId = minCostIdx / numComb;
  int bendType = minCostIdx % numComb;
  int xDim = maxX - minX + 1;
  Point cornerGCellIdx = Point(minX + cornerId % xDim, minY + cornerId / xDim); 
  Point bend_1;
  Point bend_2;
  
  updateBendPoints_lambda(cornerGCellIdx, bendType, bend_1, bend_2);

  // Create the nodes and update the congestion map
  updatePathCong2D_update(terminals, net->getNetId());
  createPathNode2D_update(net, child, parent, terminals);
}


void FlexGR::initGR_RRR_bend_route_update(
  std::vector<std::pair<frNode*, frNode*> >& ripupRoutes)
{
  for (auto& patternRoute : ripupRoutes) {
    auto startNode = patternRoute.first;
    auto endNode = patternRoute.second;
    auto net = startNode->getNet();
    bool doRoute = false;
    
    // check if the path has overflow
    auto currNode = startNode;
    while (currNode != endNode) {
      if (initGR_hasOverflow2D_update(currNode, currNode->getParent())) {
        doRoute = true;
        break;
      }
      currNode = currNode->getParent();
    }

    if (doRoute) {
      // ripup pattern routed wire and update congestion map
      auto currNode = startNode;
      while (currNode != endNode) {
        initGR_ripupRoute_update(currNode, currNode->getParent());
        // remove from endNode if parent is endNode
        if (currNode->getParent() == endNode) {
          endNode->removeChild(currNode);
        }
        
        if (currNode != startNode && currNode != endNode) {
          net->removeNode(currNode);
        }
        currNode = currNode->getParent();
      }
      
      // restore connection from start node to end node
      startNode->setParent(endNode);
      endNode->addChild(startNode);

      initGR_patternRoute_BendShape_update(startNode, endNode);
    }
  }
}




} // namespace drt


